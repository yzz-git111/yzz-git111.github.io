<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://yzz-git111.github.io/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 25 Oct 2020 10:54:00 +0800</lastBuildDate>
    
	<atom:link href="https://yzz-git111.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>排序算法总结即实例</title>
      <link>https://yzz-git111.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8D%B3%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sun, 25 Oct 2020 10:54:00 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8D%B3%E5%AE%9E%E4%BE%8B/</guid>
      <description>各种排序算法的比较 应用 找出重复元素 找中位数 调度 负载均衡 </description>
    </item>
    
    <item>
      <title>堆排序应用</title>
      <link>https://yzz-git111.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 25 Oct 2020 10:53:39 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8/</guid>
      <description>无需交换的堆 假设已经有一个有序的大顶堆，当新插入一个很大的元素的时候，利用swim()对堆进行调整。 往往这样的调整会一直延申到靠近根的位置，这样的话一层层的交换会有很多无用的操作。 回顾之前的插入排序，最简单的插入排序将待插入元素a[j]从已经有序的序列a[0..j-1]最后一个元素开始比较， 如果比a[j]大，就交换。但是通过改进：如果a[0..j-1]从后起的元素比a[j]大，就将这个元素赋值给后一个元素， 同时j向前移动一个位置，最后找到第一个比待插入元素小的，记录下位置，第一个比a[j]小的后一个就是a[j]待插入的位置。 通过改进，减少了很多不必要的交换。 同样的，对于堆的调整，也可以借助这样的思想。在向大顶堆插入一个较大元素的时候，每次若父节点比插入元素小，就将 父节点赋值给当前的结点，最后在把这个插入元素插入到相应位置即可。  private void swim(int k) { Key temp=pq[k]; int index=k; while (k &amp;gt; 1 &amp;amp;&amp;amp; less(k/2, index)) { //这里的less要进行重写，在MaxHeap中是比较pq数组中的两个下标的值，  //但当我们把父节点的值赋给子节点时，这个下标的值就被改变了，  //把less重写为比较两个泛型&amp;lt;Key&amp;gt;的大小就可以实现  pq[k]=pq[k/2]; k=k/2; } pq[k]=temp; } private boolean less(Key i, Key j) { if (comparator == null) { return ((Comparable&amp;lt;Key&amp;gt;)i).compareTo(j) &amp;lt; 0; } else { return comparator.compare(i, j) &amp;lt; 0; } } //这里的Key是泛型 (泛型的名字随意 T ,elemtype都可以 就相当于自己将所有的类型都抽象成了一个Key类型，只要实现时指明即可)  //定义时：public class MaxHeap&amp;lt;Key&amp;gt; implements Iterable&amp;lt;Key&amp;gt;  //声明时：MaxHeap&amp;lt;Integer&amp;gt; x=new MaxHeap&amp;lt;Integer&amp;gt;();  //与Comparable接口不同，Comparable接口是系统自定义的一个接口，只要类实现了Comparable中的compareTo()就可以，  //并且常用的类Integer Character String都实现了Comparable，所以和泛型大多数情况一致，  //  //使用泛型而不用Comparable接口原因在于：用Comparable的话delMax()的用例就需要将返回值转换为某种具体的类型，比如String  //一般来说，应该尽量避免在用例中进行类型转换。 更进一步的，插入排序的改进中还提到了使用二分插入法，即在前面已经有序的序列中运用二分查找 来快速找到待插入的位置。这也同样的适用于堆排序的swim()调整堆。  选择过滤 给定一个问题：对于一个不知道有多少输入的数组，怎样快速的返回其中最小的10个元素呢？</description>
    </item>
    
    <item>
      <title>优先队列(堆)及堆排序</title>
      <link>https://yzz-git111.github.io/post/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 24 Oct 2020 14:39:06 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>优先队列(堆) 我们经常遇到这样的问题：要求一个很大的数组中最小/最大的前几个数。对于数组个数较小的情况，我们可以将数组排序，然后按序输出几个数。但是当数组元素个数很大的时候，先将整个数组都排序就会很浪费时间。我们的注意只要求其中最大/最小的几个数，所以可以构造一个新的数据结构，它适用于返回最大/最小的数以及插入新的元素。而（优先队列）堆就是很好的这样一个新的数据结构。
以大顶堆（最大元素的优先队列）为例。堆最重要的操作就是删除最大元素和插入新的元素。回顾之前定义栈，队列时的想法。我们可以利用两者最基本的数据结构：数组和链表来实现。并且数组实现的栈和队列适用于查找很平凡，插入删除很少的情况。而链表实现适用于查找很少，插入和删除频繁的情况。同样的，对于堆的实现，我们也可以借助最基本的数据结构。
1.利用数组实现。为了返回最大的元素，我们可以在每次插入时候都按顺序插入，这样返回最大元素可以直接返回数组的最后一个元素。为了插入元素的方便，我们又可以每次插入都将新元素放在原始数组的后面。这就又使数组实现分为有序数组和无序数组。对于有序数组，插入元素的复杂度为O(N),返回最大元素为O(1);对于无序数组,插入元素复杂度为O(1),返回最大元素为O(N)。这显然达不到我们的要求。
2.利用链表实现。链表的优势在于插入和删除元素的复杂度为O(1)。但对于堆的基本操作来说，为了删除最大元素，可以将链表排序为有序链表，也可以每次返回最大元素时遍历整个链表。插入新元素时，若要按顺序插入，复杂度也会变为O(N),与数组的实现基本一致，效果依旧不好。
引入 仿照二叉树的基本结构可以很好的实现堆。我们定义：当一棵二叉树的每个结点大于等于它的两个子节点时，这是一个大顶堆。(小顶堆类似定义)。 大顶堆的根节点就是最大元素，小顶堆的根节点就是最小元素。
 1 7 2 3 6 5 4 5 6 7 //小顶堆 4 3 2 1 //大顶堆  如果我们使用结点以及指针的方式实现，每个结点需要3个指针（左右子树各一个 父节点一个）。但是通过观察，堆是一棵完全二叉树，对于完全二叉树， 我们通常用数组来存储。即按照层次遍历的方法，将各个元素的值放入一个数组中。 为了表示方便，不使用a[0]。那么第k个结点的左右孩子结点（如果存在） 那么他们在数组中的位置就是2k和2k+1.第k个结点的父节点（如果存在），就是k/2.
由于一颗大小为N的完全二叉树的高度为logN取下整，所以保证了这样实现的堆插入和返回最大元素的复杂度都控制在了O(logN).
堆的算法 以大顶堆为例。为了保证每个结点大于等于它的两个子节点，当有一个元素的值大于父节点时，我们就需要将它与父节点交换(交换a[k]和a[k/2])。但交换后这个结点还可能比父节点大，那么继续交换直至伸展到根。 定义这个方法为swim()。
同样的，当有一个结点的值小于孩子结点的值，为了达到平衡，我们需要将它与左右孩子中值较大的那个交换。并且一直这种情况可以一直延申到叶子节点。定义这个方法为sink().
有了swim()和sink()两个方法后，当我们插入一个元素时，总将元素插入到下一个叶子结点(数组的后一个位置)，然后利用swim()进行调整。
当我们要返回最大元素时，我们将根节点和最后一个结点交换位置(数组的第一个结点和最后一个),然后利用sink()方法将现在的根节点调整到对应位置。
有一个命题：对于一个含有N个元素的堆，插入操作不超过(logN+1)次比较，删除最大元素不超过2logN次比较。（由完全二叉树的高度保证）
参考源码:
public class MaxHeap&amp;lt;Key&amp;gt; implements Iterable&amp;lt;Key&amp;gt; { private Key[] pq; private int n; private Comparator&amp;lt;Key&amp;gt; comparator; public MaxHeap(int initCapacity) { pq = (Key[]) new Object[initCapacity + 1]; //pq[0]不放元素  n = 0; } public void insert(Key x) { if (n == pq.</description>
    </item>
    
    <item>
      <title>快速排序补充</title>
      <link>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A1%A5%E5%85%85/</link>
      <pubDate>Thu, 22 Oct 2020 23:08:46 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A1%A5%E5%85%85/</guid>
      <description>鉴于快速排序的优异性 有必要对快速排序进一步讨论   1.循坏停止条件 public static int partition(Comparable[] a,int low,int high) { while(true) { while(template.less(a[++i],v)) //a[++i]&amp;gt;v时跳出循坏//从左往右找第一个比v大的元素  { if(i==high) break; //如果找第一个比v大的元素一直到了数组末尾 则说明数组都比v小  } while(template.less(v,a[--j])) { if(j==low) break; //如果找第一个比v小的元素一直到了数组开头 则说明数组都比v大  } if(i&amp;gt;=j) //如果i和j碰到一起 就说明找完了 对数组的划分完成了  break; template.exchange(a,i,j); } template.exchange(a,low,j); //最后将划分元素给到适当位置j  return j; //j就是划分元素的最终位置  } 这里从左往右找第一个满足 不小于(&amp;gt;=)v 的元素，以及从右往左找第一个满足 不大于(&amp;lt;=)v的元素。 至于为什么有等于情况，是因为如果遇到和切分元素相同的元素时我们继续扫描而不停下，可能运行时间会退化为平方量级。
考虑一个极端的情况：aaaaaaa 这样的话i(从左往右找的)会停留在high,而j(从右往左找的)会停留在low。最后交换low和j（template.exchange(a,low,j);） 这样只使得第一个元素被划分，子数组变成了除第一个元素剩下的元素。每次划分规模减小1，循环n次，每次都O(n)，所以复杂度退化到平方量级。
但如果等于情况也停下，i会停留在第二个a，j会停留在最后一个a，这样交换第一个a（用于划分的）和中间的a（mid）。后来的子问题规模就只有一般，和一般情况复杂度一样。 虽然这样会有一些无用的交换，但是可以避免在重复元素多的时候时间复杂度退化到平方量级。
  2.最佳情况 问题：试着编写一段程序来生成使得快速排序表现最佳的数组。
思考：快速排序的最好情况：无重复的元素，且每次切分后的两个子数组的大小最多相差1. 无重复的元素很容易实现，只要控制输入即可。
考察快速排序的过程，先选取第一个元素为切分元素，最后切分结束就把第一个元素和j交换。为了保证每次切分后的两个子数组大小最多差1，就要保证每次划分元素正好是原数组排序后的中间的元素。
反过来，为了找到最好的情况，就相当于是一个逆过程。此时的输入是一个已经有序的序列。每次都将第一个元素与中间元素交换即可。这就相当于partation().
采用分治算法：假如现在a[low..mid-1],a[mid+1..high]都已经是最优解，这时只要将第一个元素与中间元素交换。而为了得到子问题的最优解，以中间元素为界限，将原问题分解为a[low..mid-1],a[mid+1..high]两个子问题，只要保证子问题最优，原问题也最优。继续的递归划分，对于只有一个元素的平凡问题，由于第一个元素==中间元素，不必交换直接返回。
举一个实例，假设对abcdefg进行最好情况的构造。先对原问题进行切割，分成abc和efg。接着处理子问题abc，继续切分，切分成a和c，都是平凡问题，不用处理。返回到子问题abc，交换a(第一个元素/切分元素)和b(中间元素)，得到bac，这样子问题abc已经处理完。处理完abc再处理子问题efg，重复上述步骤，子问题efg的解应该为feg。最后返回到原问题，此时的原问题数组已经变成了bacdfeg。进行最后一次交换，得到最终的结果dacbfeg。
参考代码:</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 21 Oct 2020 16:39:25 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>思想 考虑这样的一个情况：如果给定你一个方法partition(),此方法能够实现将一个序列进行划分。 以序列的第一个元素a[low]作为划分的依据，将原序列划分成为(小于a[low])(a[low])(大于a[low]).
那么将可以怎么利用这个方法对序列进行排序呢？ 运用分而治之（Divid &amp;amp; conquer）的思想：首先对于原始的大的序列，取第一个元素进行划分，将原问题划分为两个小的子问题。 要使得整个序列都有序，且因为这个划分的元素已经处于其对应的有序序列的位置，所以只要保证两个子问题有序即可。 对于划分的两个子问题，其中一个子问题是所有小于划分元素的，另一个子问题是所有大于划分元素的。再递归的对这两个子问题进行划分， 直至将问题划分到只有一个元素，这就是平凡问题（一个元素的序列已经有序）。 这时由于每个子问题都已经有序，且所有的划分元素都在其对应的有序序列的位置，所以整个序列都保证有序。
那么如何实现对问题的划分呢？ 我们可以总是以序列的首元素进行划分元素。从左往右直至选到一个大于等于划分元素的，同时从右往左直至选到一个小于等于比划分元素的。 这时交换两个元素。如此继续下去，就可以保证左指针i左侧的所有元素都不大于切分元素，右指针j右侧的所有元素都不小于切分元素。 最后当两个指针相遇时，就说明遍历完了数组，此时只要将切分元素（序列的首元素）与左子序列最右侧的元素（a[j]）交换并返回j。 其中返回j时为了下面进行更小子序列的划分。直到子序列只有一个元素，就可以直接返回。
源码 public class QuickSort { public static void sort(Comparable[] a) { StdRandom.shuffle(a); //对初始序列进行随机打乱  sort(a,0,a.length-1); } public static void sort(Comparable[] a,int low ,int high) { if(high&amp;lt;=low) return; int j = partition(a,low,high); sort(a,low,j-1); sort(a,j+1,high); //划分成三分 小于j的 j 大于j的  } public static int partition(Comparable[] a,int low,int high) { int i=low; // low是切分元素 low+1是第一个扫描的元素  int j=high+1; // high+1 是数组最后一个元素的后一个 high才是第一个扫描的元素  Comparable v=a[low]; //第一个元素为切分元素  while(true) { while(template.</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://yzz-git111.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 18 Oct 2020 21:28:01 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>基础 考虑这样一种情况：对于两个已经有序的子序列，如何实现将这两个子序列排序。(重点：带归并的子序列已经有序) 这就相当于对于两个有序链表合并为一个大的有序链表的问题。 方法：用两个“指针”分别指向子序列的第一个元素。先比较两个子序列的第一个元素哪个小，把小的放到另一个数组（从数组第一个位置开始放）。 然后将较小元素的指针往后移动一个，指向下一个元素。再次比较这两个指针所指元素的大小，每次把较小的元素放到另一个数组。 若有一个子序列的所有元素已经放完（指针移动到了最后一个元素之后）。由于子序列都有序，这时只要将另一个子序列的元素依次放入即可。 实例：1 3 5 | 2 4 6 8 新的数组 1 3 5 | 2 4 6 8 新的数组 1 2 3 5 | 4 6 8 新的数组 1 2 3 5 | 4 6 8 新的数组 1 2 3 4 5 | 6 8 新的数组 1 2 3 4 5 | 6 8 //这时一个子序列已经没了 新的数组 1 2 3 4 5 6 新的数组 1 2 3 4 5 6 8   merge源码 public static void merge(Comparable[] a,int low, int mid,int high) { int i=low; int j=mid+1; for(int k=low;k&amp;lt;=high;k++) //赋值到辅助数组中  { aux[k] = a[k]; } for(int k=low;k&amp;lt;=high;k++) { if(i&amp;gt;mid) //左半边归并光了  { a[k] = aux[j++]; } else if(j&amp;gt;high) //右半边归并光了  { a[k] = aux[i++]; } else if(template.</description>
    </item>
    
    <item>
      <title>初级排序算法</title>
      <link>https://yzz-git111.github.io/post/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 12 Oct 2020 20:10:17 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>选择排序（SelectSort） 算法思想  结合现实中的例子，每次都从一堆数据中找出最小的数，将他放在第一位。为了将一堆数据排序，需要进行n次（从0到n-1，n为数据个数） 抽象来看，将待排序数据存放到一个数组中。外循环执行n次(遍历整个数组)。每次外循环都实现取未排序的最小的元素。 为了在一堆数据中找到最小的元素，当然需要再用一个内循环来遍历数组。初始时，对于未排序的元素都将第一个作为最小元素min。 循环从i到n，若第j个元素小于现在的min，则min=j；内循环最后只要将a[min]与a[j]交换就满足了将一个数据排序好。  算法特点 运行时间和输入无关：即使给定的数据已经有序，选择排序任然要遍历数组。 减缓次数和数组大小是线性关系：每次外循环都只会交换两个数。而其他算法数据的移动都比这个多。  源码实现 public static void SelectSort(Comparable[] a) { int N = a.length; for(int i=0;i&amp;lt;N;i++) { int min = i; for(int j=i+1;j&amp;lt;N;j++) { if(template.less(a[j],a[min])) //自己在template类实现 Comparable接口的less方法  { min = j; } } template.exchange(a,i,min); //自己在template类实现exchange方法  } } 复杂度 命题：对于长度为N的数组，选择排序大约需要(N^2)/2次比较和N次交换 时间复杂度： 外循环O(n),内循环O(n),数据交换O(1) T(n) = O(n)*(O(n)+O(1)) =O(n^2); 最好最坏情况都为O(n^2) 空间复杂度： 只需要在交换a[min]与a[j]时申请一个变量temp 所以S(n) = O(1) 相对来说 选择排序算法时间复杂度太高，不适合处理大规模问题。但是其实现简单。   插入排序（InsertSort） 算法思想 插入排序类似于平时打扑克牌，对于每张牌都按顺序插入到适当位置。 对于给定的数组，将其看作三部分组成。其中a[0..i-1]为已经有序部分（初始时仅将a[0]看作有序）； a[i]为待排元素；a[i+1.</description>
    </item>
    
    <item>
      <title>进程的软件同步算法</title>
      <link>https://yzz-git111.github.io/post/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 29 Sep 2020 16:23:45 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95/</guid>
      <description>Dekker算法 算法1 共享变量 想法 对于两个进程Pi，Pj，给定一个共享变量turn。当turn==i时，表示允许Pi进入临界区。  算法实现 while(1) while(1) { { while(turn != i) while(turn != j) ; //空操作 ; //空操作 临界区 临界区 turn = j; turn = i; 剩余区 剩余区 } } 这里满足了同步机制的规则之一：忙则等待 但是未满足“空闲让进”规则
考虑如下情况： 情况一：某一时刻turn == i;Pi进入了临界区后，由于某种情况Pi进程直接退出，不能执行下面的turn = j;语句。 那么turn一直为i，Pj始终不能进入临界区。
情况二：在Pi执行完一次后，turn == j;此时Pj可以进入临界区，但是Pj不需要执行，Pi需要再次执行。 但是由于Pj始终没执行，turn一直是j。Pi也一直不能执行。即Pi和Pj必须交替执行。   算法2 增加标志 想法 设置一个标志位表明临界区是否为被占用。一旦有进程进入，就将标志位置为忙碌。 用ture表示临界区被占用，false表示临界区空闲。flag[x]表示进程Px对临界区的操作。  增加标志方法1 while(1) while(1) { { while(flag[j]) while(flag[i]) ; ; flag[i] = true; flag[j] = true; 临界区 临界区 flag[i] = false; flag[j] = false; 剩余区 剩余区 } } 实例化理解 借助在网上看到的一个很好的例子。假设Pi和Pj进程是两个人，临界区是每次只有一个人的公共厕所。 厕所有一个灯，当有人进去就将灯打开告诉外面里面有人。当灯亮了外面的人就要等待。 在某一时刻，i和j同时想要进去。他们观察到里面灯没亮，即while语句的flag[i,j]都是false。 于是两人都想进去后将灯点亮来占有厕所。于是出现了两人一起进到厕所的情况。 抽象来看：由于多道程序的走走停停的特性。 可能先执行while(flag[j])，flag[j]是false，表示Pj没占用临界区。于是Pi准备进入。 此时执行while(flag[i])。同样的Pj认为Pi没占有临界区，也准备进入。 然后执行flag[i] = ture; 和 flag[j] = ture; 出现了Pi，Pj同时进入临界区的bug 即未能保证进程互斥的访问临界区的原则。   增加标志方法2 交换 while(flag[j]) while(flag[i]) 这两条语句的位置。 ; ; flag[i] = true; flag[j] = true;  即在while前先将flag[]置为1，表示将要占用临界区;</description>
    </item>
    
    <item>
      <title>Union Find算法</title>
      <link>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Sep 2020 18:26:44 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%95/</guid>
      <description>union-find|并查集 问题引入 假设给定一个数组A[0..n]。将它的每个点都看作一个独立的，每个点都可以用来表示任何一种数据类型。 对于给定的一对整数对，判断是否属于同一个集合。 若不属于同一个集合，则将两者所在的集合并为同一个集合。 参考第1.5节1的内容，将对象成为触点，将整数对称为连接，将等价类称为连通分量。
引入算法的目的 可以用于计算机网络，假设每个点都是一台计算机。 对于想要通信的两台计算机可以抽象为输入的一个整数对。算法可以判断两台计算机之间是否可以有连接能够通信。若没有连接则需要建立连接。
同时假设有一个十分庞大的人际关系网，使用算法可以很快的判断出对于输入的两人是否相识。并查集是一种简单有效的算法。
 API 首先给出算法的API
UF（） //构造方法 初始化N个触点 void union(int p,int q) //将p和q连接到一个连通分量里 int find(int p) //返回p所在的连通分量的表示符(称为id) boolean connected(int p,int q) //判断p和q是否处于同一个连通分量 int getCount() //返回总的连通分量的个数 想法 有一个直观的想法：判断是否在同一连通分量只要看两个连通分量的id是否相同。因为 一个连通分量的所有触点的id都是一样的。
所有对于给定的一个整数对，先用find()找出两者所在的连通分量的id。 若id相同即说明二者在同一连通分量内，无需union 若id不同，则说明二者处在不同的连通分量内。调用union()。 union:循环遍历整个触点的数组 将id与触点p的id相同的所有触点该称q所在的连通分量的id，这就保证了将p所在的连通分量连接到q的连通分量上。 union()的最后不能忘记将count&amp;ndash; 说明整个连通分量的数目减1.实现 UF() class UF { private int[]id; //以触点作为索引  private int count; public UF(int N) //构造方法 用于初始化触点  { count = N; id = new int[N]; for(int i=0;i&amp;lt;N;i++) { id[i] = i; } } getCount() public int getCount() //用于返回private成员count 即连通分量的数目  { return count; } find() public int find(int p) //返回p的连通分量  { return id[p]; } union public void union(int p,int q) //将触点p和q连接到统一连通分量  { int pID = find(p); int qID = find(q); if(pID == qID) //p,q已经统一连通分量 空操作  { return; } for(int i=0;i&amp;lt;id.</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://yzz-git111.github.io/post/discribtion/</link>
      <pubDate>Sat, 26 Sep 2020 12:25:39 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/discribtion/</guid>
      <description>简介 这是我的个人博客
从今天开始我会陆续更新一些文章
文章主要内容是自己在学习编程路上的一些笔记或者总结
希望大家关注！
我的Github 克隆了一些看到的优秀的代码资源
 附加markdown文件的一些语法   标题
 一级标题 # 二级标题 ## 三级标题 ###    字体
 斜体:字符串两边加 * 粗体:字符串两边加 ** 粗斜体:字符串两边加 *** 例如：哈哈 嘿嘿 嘻嘻    删除线
 在文字的两端加上两个波浪线 ~~ 即可 例如：123 1230    下划线
 下划线可以通过 HTML的标签来实现 例如：Hello World!     脚注
 创建一个脚注用于注释 1    区块
 区块1 (用一个&amp;gt;)
 区块二 (用两个&amp;gt;) 区块三</description>
    </item>
    
  </channel>
</rss>