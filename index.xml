<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://yzz-git111.github.io/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 08 Nov 2020 13:32:15 +0800</lastBuildDate>
    
	<atom:link href="https://yzz-git111.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>查找算法总结</title>
      <link>https://yzz-git111.github.io/post/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 08 Nov 2020 13:32:15 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>回顾 查找，或者借助《算法四》中的名词“符号表”的关键就是键值对&amp;lt;Key,Value&amp;gt;：给出一个键，返回相对应的值;插入新的键值对;删除或修改原来的键值对。
在书中介绍了几种符号表来实现查找算法：基于数组或者链表的初级实现、基于二叉查找树实现、基于平衡二叉查找树实现、基于哈希表实现。
  先给出了符号表的基本API接口：查找键对应的值get()、插入新的键值对put()、删除一对键值对delete()、判断键是否在表中contains()、返回键值对的数量size()、判断表是否为空isEmpty()等。 其中对于有序的符号表，还可以定义更多的API接口：返回最大/最小的键min()/max()、返回小于等于给定的键的最大的键floor()、返回大于等于给定的键的最小的键ceiling()、返回小于给定的键的排名(返回给定的键在键序列中的排名)rank()、返回排名为给定数值的键select()、删除最大/最小的键deleteMin()/deleteMax()等。
  首先最开始我们的想法就是用最基本的数据结构：数组和链表来实现。
  链表的实现：通过定义内部类，即结点类，结点存放了Key类型的键和Value类型的值，同时还存放了下一个结点的引用(相当于C/C++的指针)。
对于链表实现无序的符号表，优点是插入时可以直接在头插入，时间复杂度仅为O(1)。但是查找和删除时就需要遍历整个链表才能找到指定的键值对。这时复杂度达到了O(N)。
对于链表实现有序的符号表，其唯一的优点：插入，这时为了找寻插入的位置，也需要遍历链表。那么查询，插入，删除的复杂度都达到了O(N)。
  数组的实现：通过定义两个数组，数组的各个元素一一对应，一个Key[]数组存放键，一个Value[]数组用于存放值。
对于数组实现的无序符号表，插入可以随机在数组下一个位置插入，也很简单。但是无序列表的查找和删除就需要遍历整个数组，复杂度为O(N)。(删除时可以直接将最后一个元素赋值给当前的元素，然后N&amp;ndash;即可完成快速删除)。 对于数组实现的有序符号表，在插入和删除时为了维护符号表的有序性，需要从前往后的删除和从后往前的插入，复杂度为O(N)。 但是数组实现的符号表的查询可以借助著名的二分查找算法，每次将问题分解为一半能够快速的进行查询。
  但是注意：二分查找算法只适用于有序的序列，对于无序的序列不能使用。
并且二分查找不适用于链表。
    借助二分查找和树的想法，将二叉树应用在查找中：保证对任意的子树，其根结点键的值大于左子树的所有结点且小于右子树的所有结点。这样的二叉树称作二叉查找树(BST)。且二叉查找树的中序遍历可以得到一个键的递增序列。
  具体实现：定义一个BST类，类中只有一个Node类型的变量root，用于存放根结点的引用。Node为在BST的内部类，即树的结点类。类中有一个Key类型的变量存放键，一个Value类型的变量存放值，Node类型的变量left和right存放左右子树的引用，还有一个int型的变量N存放以该结点为根的子树的所有结点个数(为了方便实现某些方法)。
  二叉查找树的查找每次和当前结点比较，然后递归的在左、右子树进行查找，直到遇到了空链接&amp;ndash;未命中，或者查找到了，在逐层返回。这种思想类似于二分查找。
  二叉查找树的插入：递归的查找新的键待插入的顺序，然后返回一个新的结点即可。
删除：当待删除结点只有一个子结点(或者没有子结点)，直接用子结点代替待删除结点即可(没有子结点用null代替).当待删除结点有两个子结点时，用它的后继结点(中序遍历的后一个结点)代替该结点，然后删除该结点右子树的最小结点deleteMin(x.right)。
  二叉树的有关操作都要有递归的思想。
  但是二叉查找树的形态和键值对的插入顺序有关，最好情况下的二叉查找树是完全二叉树的形态，高度仅为（log2N取下整+1）。最坏情况即键是递增/递减的插入，这样构造出来的二叉查找树高度达到N,直接退化成了链表。
    平衡查找树的引入：为了克服二叉查找树的缺点，引入平衡树。对于平衡二叉搜索树(AVL树)，它可以通过左旋/右旋来使得每个结点的平衡因子绝对值不超过1。但是这样的操作的成本是很高的。通过在二叉查找树的结点中假如一个新的变量color就能较轻易的实现平衡。即红黑树。
  首先引入了2-3查找树的概念，二叉查找树是一棵平衡查找树，且2-3查找树的所有空链接到根结点的距离是相等的。2-3查找树的构造过程保证了即使对于二叉查找树的最坏情况，2-3查找树也是能很好应对的。
  红黑二叉查找树与2-3查找树都是一一对应的。虽然2-3查找树不是严格意义的平衡查找树(不看结点的颜色时它可能不平衡)，但是红黑树保证了树的黑色平衡(任意黑色空链接到根结点的路径上的黑链接数量相同)。
  红黑树的插入，删除操作较为复杂，但是由于红黑树是一棵二叉查找树，所以可以借助二叉查找树所有与颜色变量color无关的方法。比如查找。
  红黑树较二叉查找树只增加了一个color变量便实现了平衡，平均情况下将查找和插入的复杂度从1.39logN降低到1.00logN 。
    值得注意的是：书中介绍的只是红黑树的一种实现。在其他的实现中有的允许红色右链接和4-结点。 书中规定只允许左链接是为了代码实现的方便。</description>
    </item>
    
    <item>
      <title>哈希表</title>
      <link>https://yzz-git111.github.io/post/%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <pubDate>Sat, 07 Nov 2020 21:21:31 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <description>概述 散列函数 基于拉链法的散列表 基于线性探测的散列表 复杂度分析 </description>
    </item>
    
    <item>
      <title>平衡查找树</title>
      <link>https://yzz-git111.github.io/post/%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91/</link>
      <pubDate>Wed, 04 Nov 2020 23:28:42 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91/</guid>
      <description>引入：
二叉查找树各种方法的复杂度都与树的高度成正比，但是在最坏的情况(键按序插入)下二叉查找树的高度为h，这是非常糟糕的。
若树的每个结点的左右子树高度之差(即平衡因子)绝对值小于1，则称这棵树是平衡的；
显然，完全二叉树就是一个完美平衡的二叉树。
我们引入平衡查找树(Balanced-Search-Tree，BST)。
对于二叉平衡查找树，即AVL树(简称平衡二叉树)能够保证二叉查找树的高度为~logN.
（平衡二叉树只是平衡查找树的一部分，也是最常见的一部分）
但是维护AVL树的平衡(即左旋，右旋等操作)的代价很大，所以可以降低要求实现，即红黑树。
虽然红黑树不是严格意义的平衡，但是它的黑结点是完全平衡的。
 一、2-3查找树 为了保证平衡，给二叉树增加了一些灵活性，允许一个结点保存多个键。
 将一棵标准二叉查找树中的结点称作2-结点(一个键和两条链接) 类似的，k-结点有k-1个键和k条链接
  2-3查找树的定义：一棵2-3查找树或为一棵空树，或由2-结点/3-结点组成。
那么m-n查找树的定义：一棵m-n查找树或为一棵空树，或由m-结点到n结点组成
将指向一棵空树的链接称为空链接，那么一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都相等。 1、查找 2-3查找树的查找算法和二叉查找树类似，唯一不同的只是二叉查找树每个结点都是2-结点(只有一个键)，所以二叉查找树只需要将key和结点x.key相比，然后递归的在左或者右子树查找;
而2-3查找树可能有3-结点，那么判断时就需要将结点的所有键与key比较，然后递归的在左，中间或者右子树查找。
2、插入 保证插入后树仍然平衡
2、1 &amp;mdash; 向2-结点插入新键 把插入的键保存在结点中，使得2-结点变成3-结点即可。
2、2 &amp;mdash; 向一棵只有一个3-结点的树插入新键 先考虑特殊情况：这棵树只有一个根结点为3-结点。在插入之后先让他成为临时4-结点，然后进行分裂。分裂成为3个2-结点，三个键的中间的键作为新的根结点，最小的与根结点的左链接相连，最大的与根结点的右链接相连。保持了平衡。
插入前树的高度为0，插入后树的高度增加了1。
2、3 &amp;mdash; 向一个父节点为2-结点的3-结点插入新键 3-结点插入了新键后变为一个4-结点，需要分裂。因为父结点是2-结点，所以父结点有空间。它将中间的键给到父节点，然后中间键的左右链接指向分裂的两个键。
2、4 &amp;mdash; 向一个父节点为3-结点的3-结点插入新键 将中间的键给到父节点，自己分裂称2个2-结点。但是父节点由原来的3-结点变为4-结点，也需要继续向它的父节点继续给出中间键。这样的操作最多持续到根结点或者遇到一个2-结点的祖父结点。
2、5 &amp;mdash; 根结点分裂 若从插入结点到根结点的路径上都是3-结点，那么根结点最后也会变成一个4-结点，需要进行2、2的分裂。此时树高加1.
分析 与标准的二叉查找树从上而下的构造不同，2-3树的生长是从下而上的。
按照升序插入的10个键，对于二叉查找树会得到一个高度为9的树，但是对于2-3树，树高仅仅为2。
对于最坏情况，2-3查找树也有很好的表现。
命题：在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过logN个。
每个操作中处理每个结点的时间都不会超过很小的一个常数，所以任何查找或者插入操作的成本都不会超过对数级别。但是2-结点和3-结点之间的转换却需要很大的成本。这是得不偿失的。
所以我们引入了红黑树。
 二、红黑二叉查找树 定义 关于红黑树有两种定义：
  借助2-3树。
将2-3树中的3-结点表示为由一条左斜的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2-结点。
将红链接画平时，一棵红黑树就是一棵2-3树。
  红黑树是含有红黑链接并且满足下面条件的二叉查找树：
   根结点为黑结点 红链接均为左链接。 没有任意一个结点同时和两条红链接相连。 该树是完美黑色平衡的，即任意空链接到根结点路径上的黑链接数量相同。  红黑树既是二叉查找树又是2-3树。将二叉查找树的查找方法和2-3树的平衡插入算法结合起来。</description>
    </item>
    
    <item>
      <title>二叉查找树</title>
      <link>https://yzz-git111.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Mon, 02 Nov 2020 12:50:56 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>符号表的实现除了数组和链表的实现。还有一种借助二叉树的实现。即二叉查找树(二叉排序树)。
二叉查找树(Binary-Search-Tree)是一棵二叉树，每个结点都含有一个Comparable的键(以及相关联的值)，且每个结点的键都大于其左子树中任意结点的键而小于右子数的任意结点的键。
 数据结构 二叉查找树的数据结构的实现和二叉树类似。也可以利用数组和链表的方式。
使用数组存储即将二叉查找树看作完全二叉树，并按照层次遍历依次存放进数组中。
可见数组存储二叉查找树是很浪费，只有当二叉树是近似完全二叉树时用这种方式既不浪费空间又可以快速按照下标访问元素。
所以二叉查找树使用链表的方式存储。
和链表一样，嵌套定义一个私有类来表示一个结点。每个结点都含有一个键，一个值，一个左链接，一个右链接和一个结点计数器。
几个细节：
 类BST采用泛型，且其中只有键Key实现了Comparable，因为只比较键的大小。 定义的size来存储以这个结点为根的树的结点的个数，方便了后面方法的实现。 类BST的new的对象只有一个null的结点成员，需要通过插入新结点来构造成二叉树。  public class BST&amp;lt;Key extends Comparable&amp;lt;Key&amp;gt;, Value&amp;gt; { private Node root; private class Node { private Key key; private Value val; private Node left, right; private int size; public Node(Key key, Value val, int size) { this.key = key; this.val = val; this.size = size; } } public BST() {} public boolean isEmpty() { return size() == 0; } public int size() { return size(root); } private int size(Node x) { if (x == null) return 0; else return x.</description>
    </item>
    
    <item>
      <title>扔鸡蛋问题</title>
      <link>https://yzz-git111.github.io/post/%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 31 Oct 2020 22:51:50 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/</guid>
      <description>问题描述 问题1：有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层？
问题2：更一般的：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &amp;lt;= F &amp;lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？
问题1 明确一个想法：只有一个鸡蛋时，只能一层层的测试。
想法1 对于第一个问题，最简单的想法就是二分查找：先从50层往下扔，碎了的话问题就退化成1个鸡蛋测试1-50层。那么这时只能从第一次开始逐层测试，最坏情况一直测试到第49层。如果没有碎，那还有两个鸡蛋，继续在50-100间进行二分查找，即从75层往下扔。又分为碎和没碎的情况。碎了就退化成为线性测试，没碎就一直二分查找。这个想法最坏的情况是第一次测试在50层碎了，然后一直从第一层测试到第49层，需要进行50次测试。
想法2 二分查找的想法就是对半减小问题的规模，但是对于这题，问题的关键就在于试图减小问题规模的步幅太大。第一次就试图将问题规模减小为原来的一半。这使得对于最坏情况下需要进行N/2次测试。 若采用平凡根，或者斐波那契数来减小规模，可能会有一定的提高。 对于斐波那契数(1,1,2,3,5,8,13,21,34,55,89&amp;hellip;),可以第一次在第1层扔，若鸡蛋不碎，就继续按照斐波那契数进行测试。最坏情况下在第55层没有碎，在89层碎，然后只能从56&amp;ndash;88层逐层测试，一直需要测试到第88层才能得到答案。总得次数为9+23=32次。 对于平方根数，第一次在第10层扔，没碎的话每次加上10继续，若碎了改为线性测试。最坏情况下第90层没碎，然后线性测试到100层。总次数为9+10=19次。
想法3 想法2的两个情况对于想法1有改进，减小了最坏情况下问题的规模，但是这种规模是“不均衡的”。比较好的情况是：若确定一个子问题规模需要的实验次数多，那么子问题的规模就需要小。即把最坏情况平摊到每个子问题中。
想法3：假设问题存在最优解，使得最大测试次数为x，那么在第x层扔就会得到最优解。
简单证明：假设第一次扔在第x+1层，如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。 假设第二次扔在第x-1层，鸡蛋没有碎，浪费了一次测试，继续在2(x-1)层测试，那么确定子问题测试的次数+对子问题线性测试的次数也一定大于x。 那么第x层就是最好的解。  如果第一次扔鸡蛋没有碎，那么已经消耗了一次测试，问题就变为两个鸡蛋在100-x的楼往下扔，最好情况为x-1次。那么第二次的子问题规模应该弥补第一次没用的测试（实现将最坏情况均分到每个子问题），即第二次应该在x+(x-1)层。
以此类推，得到一个方程 x+(x-1)+(x-2)+&amp;hellip;+1=100.解之得，x=14;
所以，在第一个鸡蛋没有碎的情况下，楼层依次为14,27,39,50,60,69,77,84,90,95,99,100。且最坏情况不会超过14次。
问题1的总结 对于特定的问题：2个鸡蛋，100层楼。我们可以采取特定的方法。对于3个鸡蛋，那么我们可以用两个鸡蛋来缩小子问题的规模(采用2次二分查询/斐波那契/平方数)。但这不具有一般性。
 问题2 这题实际是一个动态规划1的问题。给定K个鸡蛋，N层楼。记作f(K,N)
若一个鸡蛋在第i层碎了，则问题转化为f(K-1,N-i).
若鸡蛋在第i层没碎，则问题转化为f(K,N-i).
  问题留着以后动态规划、分治算法的专题时再来研究 &amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>基本的查找算法</title>
      <link>https://yzz-git111.github.io/post/%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 31 Oct 2020 15:12:26 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description>根据书中的定义：符号表是一种存储键值对的数据结构。支持插入操作：将一组新的键值对存入表中。和查找操作：根据给定的键得到相对应的值
典型的符号表的应用：查字典时，单词就是键，释义就是值。通过单词来找到意思。
网络搜索时，关键字就是键，网页名称就是值，通过关键字来找到网页。
约定  每个键只对应一个值(而一个值可以对应于多个键)。即索引是唯一的。 键不能为空。 查找成功成为命中，不成功返回null为不命中 采用泛型的设计思想，在具体实现时在规定特定的类型。  最基本的符号表的API：
基于链表实现 符号表作为一种数据结构可以通过最基本的链表来实现。
public class SequentialSearchST&amp;lt;Key,Value&amp;gt; { private Node first; //相当于头结点指针  private class Node { Key key; Value val; Node next; public Node(Key key, Value val, Node next) { this.key=key; this.val=val; this.next=next; } } } 这里给出了链表实现的方法：使用一个内部私有类Node来存放键和值。链表只有一个私有成员first，类型为私有内部类Node，用来指示下一个结点的位置，初始值是null。
/*这是根据键查找值 以及 插入一对新的键值对的方法*/ public Value get(Key key) { for(Node x=first;x!=null;x=x.next) { if(key.equals(x.key)) { return x.val; } } return null; } public void put(Key key,Value val) { for(Node x=first;x!</description>
    </item>
    
    <item>
      <title>浅析堆区和栈区</title>
      <link>https://yzz-git111.github.io/post/%E6%B5%85%E6%9E%90%E5%A0%86%E5%8C%BA%E5%92%8C%E6%A0%88%E5%8C%BA/</link>
      <pubDate>Thu, 29 Oct 2020 20:34:14 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E6%B5%85%E6%9E%90%E5%A0%86%E5%8C%BA%E5%92%8C%E6%A0%88%E5%8C%BA/</guid>
      <description>java的内存分为堆区，栈区和方法区三类。
堆 特点：
 堆区中不存放基本类型和对象引用，只存放对象本身（通过new生成的对象）。 堆是可以被所有的线程所共享的。 内存分配是连续分配的，即，所分配的内存是在一块连续的内存区域内．  堆的优点是：可以动态的分配内存大小，在运行时动态分配内存，Java的垃圾收集器会自动收走这些不再使用的数据。 但是缺点是：存取速度较慢。
栈 特点：
 栈区存储基本变量类型,并且包含这个基本类型的具体数据。 栈区存储堆中对象的引用（引用在堆区中的地址） 方法调用时进栈，当方法执行完时退栈。栈空时程序执行完。 内存中的分布不是连续的，它们是不同区域的内存块通过指针链接起来的．  方法区  被线程共享的区域 包括常量池和静态区 存储被static修饰的常量和所有的class  实例1 实例2 如上图：
 定义了一个Pet类，包括name和age两个属性，一个shout()方法。类是存放在方法区里。 main()方法首先进入栈区(main也可以传递参数String args[]) 在main中定义了Pet的两个对象：dog和cat。通过new的对象本身存放在堆区。而引用存放在栈区中。 为赋值前，name默认null，age默认0.赋值后，堆区相应的值改变，而栈区仍然存放的是dog和cat这两个对象的引用。 字符串“旺财”作为常量，被存放在常量池中。  实例3 每次通过String构造的一个String的对象，即使给定的字符串一样，但是这两个String的对象不一样。这是因为判断两个对象是否一样比较的是对象的引用。每次new一个对象都会在堆区申请相应的空间，然后栈区存储这个对象的引用。存储的是不同的引用。
而通过String c = &amp;ldquo;abc&amp;rdquo;; String d = &amp;ldquo;abc&amp;rdquo;; 判断c==d返回的是true。 这是因为字符串&amp;quot;abc&amp;quot;是常量，被存储在常量池中。这里是把常量池的&amp;quot;abc&amp;quot;的引用给了这两个对象。 （java除了基本数据类型是值传递 其他都是引用传递）</description>
    </item>
    
    <item>
      <title>排序算法总结及实例</title>
      <link>https://yzz-git111.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8D%B3%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Sun, 25 Oct 2020 10:54:00 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%8D%B3%E5%AE%9E%E4%BE%8B/</guid>
      <description>各种排序算法的比较 在大多数实际情况中，快速排序是最佳选择。但是如果稳定很重要而空间又不是问题，那么归并排序是最好的选择。
注意：在java中，我们除了原始数字类型之外，操作的总是数据的引用（指针），而非数据本身。使用引用的好处是对于一些复杂的数据类型，数组保存的是待排序对象的引用，移动元素时只需要移动引用而不是整个元素。 但是对于将数字排序的情况，更合理的做法是跳过引用而直接将原始数组类型排序。例如：一个double类型的数组和一个Double类型的数组。对于前者可以直接交换这些元素并且排序；而对于后者交换的存储了数字的Double对象的引用。跳过引用可以节省存储引用的空间和通过引用访问数字的成本，以及调用compareTo()和less()的开销。 跳过引用的方法就是把Comparable接口替换为原始数组类型名，重新定义less()或者直接使用a[i]&amp;lt;a[j].
应用 找第k个数 对于找中位数，利用一个大顶堆和一个小顶堆可以实现。
除此之外，还有一种方法能够快速的找到中位数。更一般的，可以找到任意第k小的数。
还有一种想法：每调用一次快速排序的partition()就返回划分元素所在对应的有序数组中的下标。如果返回的下标正好满足对应的有序序列中位数的下标(n/2)就说明划分元素就是中位数。如果下标大于n/2就说明小于划分元素的数的个数大于n/2，那么中位数一定在小于划分元素的那个序列中，对这个序列继续partition()，直至返回的下标为n/2即找到中位数。
public static Comparable select(Comparable[] a,int k) { StdRandom.shuffle(a); int low=0,high=a.length-1; int i=partition(a,low,high); while (i!=k) //当下标不为要求的下标时就继续  { if(i&amp;gt;k) //中位数在元素多的数组中  { high=i-1; i=partition(a,low,high); } else { low=i+1; i=partition(a,low,high); } } return a[i]; } 当select(a,n/2)时就是返回中位数。若想返回其他的数(第k小的数)，只要传递相应的k值即可.
复杂度：
可能出现最坏的情况：每次划分元素都只能将范围缩小1，那么需要partition()O(N)次，且每次的partition()需要遍历数组，比较O(N)次，那么复杂度会O(N^2).但是通过随机打乱数组能尽可能避免这种情况。
假设每次恰好将数组二分，那么比较的总次数为(N+ N/2 + N/4 +&amp;hellip;)直到找到第k小的元素，这个和小于2N.T(N)=O(N).
当然还有更好的算法保证最坏情况下也是O(N).
指定的排序顺序 如何实现按照某一特定的顺序进行排序？ 问题：为了制止对名字在字母结尾出现的候选人的偏见，加利福尼亚使用以下顺序对出现在其2003年州长选举中的候选人进行了排序：RWQOJMVAHBSGZXNTCIEKUPDYFL
public class California { public static final Comparator&amp;lt;String&amp;gt; CANDIDATE_ORDER = new CandidateComparator(); //在California类中有一个final的静态变量,静态变量是CandidateComparator类  private static class CandidateComparator implements Comparator&amp;lt;String&amp;gt; {//又定义了California的内部类CandidateComparator  //并且内部类CandidateComparator实现了接口Comparator ,即要重写compare方法  //&amp;lt;String&amp;gt;表示Comparator的泛型T在这里用String特定实现。  private static String order = &amp;#34;RWQOJMVAHBSGZXNTCIEKUPDYFL&amp;#34;; //内部类CandidateComparator有一个静态成员变量order，指定了排序的顺序  public int compare(String a, String b) {//实现Comparator接口的compare()  int n = Math.</description>
    </item>
    
    <item>
      <title>堆排序应用</title>
      <link>https://yzz-git111.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 25 Oct 2020 10:53:39 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%BA%94%E7%94%A8/</guid>
      <description>无需交换的堆 假设已经有一个有序的大顶堆，当新插入一个很大的元素的时候，利用swim()对堆进行调整。 往往这样的调整会一直延申到靠近根的位置，这样的话一层层的交换会有很多无用的操作。 回顾之前的插入排序，最简单的插入排序将待插入元素a[j]从已经有序的序列a[0..j-1]最后一个元素开始比较， 如果比a[j]大，就交换。但是通过改进：如果a[0..j-1]从后起的元素比a[j]大，就将这个元素赋值给后一个元素， 同时j向前移动一个位置，最后找到第一个比待插入元素小的，记录下位置，第一个比a[j]小的后一个就是a[j]待插入的位置。 通过改进，减少了很多不必要的交换。 同样的，对于堆的调整，也可以借助这样的思想。在向大顶堆插入一个较大元素的时候，每次若父节点比插入元素小，就将父节点赋值给当前的结点，最后在把这个插入元素插入到相应位置即可。  private void swim(int k) { Key temp=pq[k]; int index=k; while (k &amp;gt; 1 &amp;amp;&amp;amp; less(k/2, index)) { //这里的less要进行重写，在MaxHeap中是比较pq数组中的两个下标的值，  //但当我们把父节点的值赋给子节点时，这个下标的值就被改变了，  //把less重写为比较两个泛型&amp;lt;Key&amp;gt;的大小就可以实现  pq[k]=pq[k/2]; k=k/2; } pq[k]=temp; } private boolean less(Key i, Key j) { if (comparator == null) { return ((Comparable&amp;lt;Key&amp;gt;)i).compareTo(j) &amp;lt; 0; } else { return comparator.compare(i, j) &amp;lt; 0; } } //这里的Key是泛型 (泛型的名字随意 T ,elemtype都可以 就相当于自己将所有的类型都抽象成了一个Key类型，只要实现时指明即可)  //定义时：public class MaxHeap&amp;lt;Key&amp;gt; implements Iterable&amp;lt;Key&amp;gt;  //声明时：MaxHeap&amp;lt;Integer&amp;gt; x=new MaxHeap&amp;lt;Integer&amp;gt;();  //与Comparable接口不同，Comparable接口是系统自定义的一个接口，只要类实现了Comparable中的compareTo()就可以，  //并且常用的类Integer Character String都实现了Comparable，所以和泛型大多数情况一致，  //  //使用泛型而不用Comparable接口原因在于：用Comparable的话delMax()的用例就需要将返回值转换为某种具体的类型，比如String  //一般来说，应该尽量避免在用例中进行类型转换。 更进一步的，插入排序的改进中还提到了使用二分插入法，即在前面已经有序的序列中运用二分查找 来快速找到待插入的位置。这也同样的适用于堆排序的swim()调整堆。  选择过滤 给定一个问题：对于一个不知道有多少输入的数组，怎样快速的返回其中最小的10个元素呢？</description>
    </item>
    
    <item>
      <title>优先队列(堆)及堆排序</title>
      <link>https://yzz-git111.github.io/post/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 24 Oct 2020 14:39:06 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%A0%86%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>优先队列(堆) 我们经常遇到这样的问题：要求一个很大的数组中最小/最大的前几个数。对于数组个数较小的情况，我们可以将数组排序，然后按序输出几个数。但是当数组元素个数很大的时候，先将整个数组都排序就会很浪费时间。我们的注意只要求其中最大/最小的几个数，所以可以构造一个新的数据结构，它适用于返回最大/最小的数以及插入新的元素。而（优先队列）堆就是很好的这样一个新的数据结构。
以大顶堆（最大元素的优先队列）为例。堆最重要的操作就是删除最大元素和插入新的元素。回顾之前定义栈，队列时的想法。我们可以利用两者最基本的数据结构：数组和链表来实现。并且数组实现的栈和队列适用于查找很平凡，插入删除很少的情况。而链表实现适用于查找很少，插入和删除频繁的情况。同样的，对于堆的实现，我们也可以借助最基本的数据结构。
  利用数组实现。为了返回最大的元素，我们可以在每次插入时候都按顺序插入，这样返回最大元素可以直接返回数组的最后一个元素。为了插入元素的方便，我们又可以每次插入都将新元素放在原始数组的后面。这就又使数组实现分为有序数组和无序数组。对于有序数组，插入元素的复杂度为O(N),返回最大元素为O(1);对于无序数组,插入元素复杂度为O(1),返回最大元素为O(N)。这显然达不到我们的要求。
  利用链表实现。链表的优势在于插入和删除元素的复杂度为O(1)。但对于堆的基本操作来说，为了删除最大元素，可以将链表排序为有序链表，也可以每次返回最大元素时遍历整个链表。插入新元素时，若要按顺序插入，复杂度也会变为O(N),与数组的实现基本一致，效果依旧不好。
  引入 仿照二叉树的基本结构可以很好的实现堆。我们定义：当一棵二叉树的每个结点大于等于它的两个子节点时，这是一个大顶堆。(小顶堆类似定义)。
大顶堆的根节点就是最大元素，小顶堆的根节点就是最小元素。
 1 7 2 3 6 5 4 5 6 7 //小顶堆 4 3 2 1 //大顶堆  如果我们使用结点以及指针的方式实现，每个结点需要3个指针（左右子树各一个 父节点一个）。但是通过观察，堆是一棵完全二叉树，对于完全二叉树，我们通常用数组来存储。即按照层次遍历的方法，将各个元素的值放入一个数组中。 为了表示方便，不使用a[0]。那么 第k个结点的左右孩子结点（如果存在）那么他们在数组中的位置就是2k和2k+1.第k个结点的父节点（如果存在）,就是k/2
由于一颗大小为N的完全二叉树的高度为logN取下整，所以保证了这样实现的堆插入和返回最大元素的复杂度都控制在了O(logN).
堆的算法 以大顶堆为例。为了保证每个结点大于等于它的两个子节点，当有一个元素的值大于父节点时，我们就需要将它与父节点交换(交换a[k]和a[k/2])。但交换后这个结点还可能比父节点大，那么继续交换直至伸展到根。 定义这个方法为swim()。
同样的，当有一个结点的值小于孩子结点的值，为了达到平衡，我们需要将它与左右孩子中值较大的那个交换。并且一直这种情况可以一直延申到叶子节点。 定义这个方法为sink().
有了swim()和sink()两个方法后，当我们插入一个元素时，总将元素插入到下一个叶子结点(数组的后一个位置)，然后利用swim()进行调整。
当我们要返回最大元素时，我们将根节点和最后一个结点交换位置(数组的第一个结点和最后一个),然后利用sink()方法将现在的根节点调整到对应位置。
命题：对于一个含有N个元素的堆，插入操作不超过(logN+1)次比较，删除最大元素不超过2logN次比较。（由完全二叉树的高度保证）
参考源码:
public class MaxHeap&amp;lt;Key&amp;gt; implements Iterable&amp;lt;Key&amp;gt; { private Key[] pq; private int n; private Comparator&amp;lt;Key&amp;gt; comparator; public MaxHeap(int initCapacity) { pq = (Key[]) new Object[initCapacity + 1]; //pq[0]不放元素  n = 0; } public void insert(Key x) { if (n == pq.</description>
    </item>
    
    <item>
      <title>快速排序补充</title>
      <link>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A1%A5%E5%85%85/</link>
      <pubDate>Thu, 22 Oct 2020 23:08:46 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A1%A5%E5%85%85/</guid>
      <description>鉴于快速排序的优异性 有必要对快速排序进一步讨论   1.循坏停止条件 public static int partition(Comparable[] a,int low,int high) { while(true) { while(template.less(a[++i],v)) //a[++i]&amp;gt;v时跳出循坏//从左往右找第一个比v大的元素  { if(i==high) break; //如果找第一个比v大的元素一直到了数组末尾 则说明数组都比v小  } while(template.less(v,a[--j])) { if(j==low) break; //如果找第一个比v小的元素一直到了数组开头 则说明数组都比v大  } if(i&amp;gt;=j) //如果i和j碰到一起 就说明找完了 对数组的划分完成了  break; template.exchange(a,i,j); } template.exchange(a,low,j); //最后将划分元素给到适当位置j  return j; //j就是划分元素的最终位置  } 这里从左往右找第一个满足 不小于(&amp;gt;=)v 的元素，以及从右往左找第一个满足 不大于(&amp;lt;=)v的元素。 至于为什么有等于情况，是因为如果遇到和切分元素相同的元素时我们继续扫描而不停下，可能运行时间会退化为平方量级。
考虑一个极端的情况：aaaaaaa 这样的话i(从左往右找的)会停留在high,而j(从右往左找的)会停留在low。最后交换low和j（template.exchange(a,low,j);） 这样只使得第一个元素被划分，子数组变成了除第一个元素剩下的元素。每次划分规模减小1，循环n次，每次都O(n)，所以复杂度退化到平方量级。
但如果等于情况也停下，i会停留在第二个a，j会停留在最后一个a，这样交换第一个a（用于划分的）和中间的a（mid）。后来的子问题规模就只有一般，和一般情况复杂度一样。 虽然这样会有一些无用的交换，但是可以避免在重复元素多的时候时间复杂度退化到平方量级。
遇到相同的元素停止的情况:
  2.最佳情况 问题：试着编写一段程序来生成使得快速排序表现最佳的数组。
思考：快速排序的最好情况：无重复的元素，且每次切分后的两个子数组的大小最多相差1. 无重复的元素很容易实现，只要控制输入即可。
考察快速排序的过程，先选取第一个元素为切分元素，最后切分结束就把第一个元素和j交换。为了保证每次切分后的两个子数组大小最多差1，就要保证每次划分元素正好是原数组排序后的中间的元素。
反过来，为了找到最好的情况，就相当于是一个逆过程。此时的输入是一个已经有序的序列。每次都将第一个元素与中间元素交换即可。这就相当于partation().
采用分治算法：假如现在a[low..mid-1],a[mid+1..high]都已经是最优解，这时只要将第一个元素与中间元素交换。而为了得到子问题的最优解，以中间元素为界限，将原问题分解为a[low..mid-1],a[mid+1..high]两个子问题，只要保证子问题最优，原问题也最优。继续的递归划分，对于只有一个元素的平凡问题，由于第一个元素==中间元素，不必交换直接返回。
举一个实例，假设对abcdefg进行最好情况的构造。先对原问题进行切割，分成abc和efg。接着处理子问题abc，继续切分，切分成a和c，都是平凡问题，不用处理。返回到子问题abc，交换a(第一个元素/切分元素)和b(中间元素)，得到bac，这样子问题abc已经处理完。处理完abc再处理子问题efg，重复上述步骤，子问题efg的解应该为feg。最后返回到原问题，此时的原问题数组已经变成了bacdfeg。进行最后一次交换，得到最终的结果dacbfeg。</description>
    </item>
    
    <item>
      <title>快速排序</title>
      <link>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 21 Oct 2020 16:39:25 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>思想 考虑这样的一个情况：如果给定你一个方法partition(),此方法能够实现将一个序列进行划分:以序列的第一个元素a[low]作为划分的依据，将原序列划分成为(小于a[low])(a[low])(大于a[low]).
那么将可以怎么利用这个方法对序列进行排序呢？
运用 分而治之(Divid &amp;amp; conquer) 的思想：首先对于原始的大的序列，取第一个元素进行划分，将原问题划分为两个小的子问题。
要使得整个序列都有序，且因为这个划分的元素已经处于其对应的有序序列的位置，所以只要保证两个子问题有序即可。
对于划分的两个子问题，其中一个子问题是所有小于划分元素的，另一个子问题是所有大于划分元素的。再递归的对这两个子问题进行划分，
直至将问题划分到只有一个元素，这就是平凡问题（一个元素的序列已经有序）。
这时由于每个子问题都已经有序，且所有的划分元素都在其对应的有序序列的位置，所以整个序列都保证有序。
那么如何实现对问题的划分呢？
我们可以总是 以序列的首元素进行划分元素。从左往右直至选到一个大于等于划分元素的，同时从右往左直至选到一个小于等于比划分元素的。
这时交换两个元素。如此继续下去，就可以保证左指针i左侧的所有元素都不大于切分元素，右指针j右侧的所有元素都不小于切分元素。
最后当两个指针相遇时，就说明遍历完了数组，此时只要 将切分元素（序列的首元素）与左子序列最右侧的元素（a[j]）交换并返回j。
其中返回j是为了下面进行更小子序列的划分。直到子序列只有一个元素，就可以直接返回。
源码 public class QuickSort { public static void sort(Comparable[] a) { StdRandom.shuffle(a); //对初始序列进行随机打乱  sort(a,0,a.length-1); } public static void sort(Comparable[] a,int low ,int high) { if(high&amp;lt;=low) return; int j = partition(a,low,high); sort(a,low,j-1); sort(a,j+1,high); //划分成三分 小于j的 j 大于j的  } public static int partition(Comparable[] a,int low,int high) { int i=low; // low是切分元素 low+1是第一个扫描的元素  int j=high+1; // high+1 是数组最后一个元素的后一个 high才是第一个扫描的元素  Comparable v=a[low]; //第一个元素为切分元素  while(true) { while(template.</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://yzz-git111.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 18 Oct 2020 21:28:01 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>基础 考虑这样一种情况：对于两个已经有序的子序列，如何实现将这两个子序列排序。(重点：待归并的子序列已经有序)
这就相当于对于两个有序链表合并为一个大的有序链表的问题。
方法：创建一个大小足够的辅助数组。先将两个子序列都复制到辅助数组中。用两个“指针”分别指向辅助数组中两个子序列的第一个元素。先比较两个子序列的第一个元素哪个小，把小的放到原来的数组（从第一个位置开始放）。
然后将较小元素的指针往后移动一个，指向下一个元素。再次比较这两个指针所指元素的大小，每次把较小的元素放回到原来的数组中。
若有一个子序列的所有元素已经放完（指针移动到了此子数组最后一个元素之后）。由于子序列都有序，这时只要将另一个子序列的元素依次放入即可。
 辅助数组: 1 3 5 | 2 4 6 8 初始数组 1 3 5 | 2 4 6 8 初始数组 1 2 3 5 | 4 6 8 初始数组 1 2 3 5 | 4 6 8 初始数组 1 2 3 4 5 | 6 8 初始数组 1 2 3 4 5 | 6 8 //这时一个子序列已经没了 初始数组 1 2 3 4 5 6 初始数组 1 2 3 4 5 6 8   merge源码 public static void merge(Comparable[] a,int low, int mid,int high) { int i=low; int j=mid+1; for(int k=low;k&amp;lt;=high;k++) //赋值到辅助数组中  { aux[k] = a[k]; } for(int k=low;k&amp;lt;=high;k++) { if(i&amp;gt;mid) //左半边归并光了  { a[k] = aux[j++]; } else if(j&amp;gt;high) //右半边归并光了  { a[k] = aux[i++]; } else if(template.</description>
    </item>
    
    <item>
      <title>初级排序算法</title>
      <link>https://yzz-git111.github.io/post/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 12 Oct 2020 20:10:17 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>选择排序（SelectSort） 算法思想 结合现实中的例子，每次都从一堆数据中找出最小的数，将他放在第一位。为了将一堆数据排序，需要进行n次（从0到n-1，n为数据个数）
抽象来看，将待排序数据存放到一个数组中。外循环执行n次(遍历整个数组)。每次外循环都实现将未排序序列最小的元素放到已经有序的序列末尾。
为了在一堆数据中找到最小的元素，当然需要再用一个内循环来遍历数组。初始时，对于未排序的元素都将第一个作为最小元素min。
循环从i到n，若第j个元素小于现在的min，则min=j；内循环最后只要将a[min]与a[j]交换就满足了将一个数据排序好。
算法特点 运行时间和输入无关：即使给定的数据已经有序，选择排序任然要遍历数组。
交换次数和数组大小是线性关系：每次外循环都只会交换两个数。而其他算法数据的移动都比这个多。
源码实现 public static void SelectSort(Comparable[] a) { int N = a.length; for(int i=0;i&amp;lt;N;i++) { int min = i; for(int j=i+1;j&amp;lt;N;j++) { if(template.less(a[j],a[min])) //自己在template类实现 Comparable接口的less方法  { min = j; } } template.exchange(a,i,min); //自己在template类实现exchange方法  } } 复杂度 命题：对于长度为N的数组，选择排序大约需要(N^2)/2次比较和N次交换
时间复杂度：
外循环O(n),内循环O(n),数据交换O(1) T(n) = O(n)(O(n)+O(1)) =O(n^2) 最好最坏情况都为O(n^2)
空间复杂度：
只需要在交换a[min]与a[j]时申请一个变量temp 所以S(n) = O(1)
相对来说 选择排序算法时间复杂度太高，不适合处理大规模问题。但是其实现简单。
 插入排序（InsertSort） 算法思想 插入排序类似于平时打扑克牌，对于每张牌都按顺序插入到适当位置。
对于给定的数组，将其看作三部分组成。其中a[0..i-1]为已经有序部分（初始时仅将a[0]看作有序） a[i]为待排元素；a[i+1..n-1]为无序部分。 现遍历整个数组，每次循环将待排序元素插入到已经有序部分中。
那么在数组中怎么实现将某个待排序数插入到适当位置？
首先每次循环将待排序的元素保存到某个变量temp中(严蔚敏版的数据结构中采用将数组下标为0的位置用于存放待排序变量，有几点好处)</description>
    </item>
    
    <item>
      <title>进程的软件同步算法</title>
      <link>https://yzz-git111.github.io/post/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 29 Sep 2020 16:23:45 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95/</guid>
      <description>Dekker算法 算法1 共享变量 想法 对于两个进程Pi，Pj，给定一个共享变量turn。当turn==i时，表示允许Pi进入临界区。  算法实现 while(1) while(1) { { while(turn != i) while(turn != j) ; //空操作 ; //空操作 临界区 临界区 turn = j; turn = i; 剩余区 剩余区 } } 这里满足了同步机制的规则之一：忙则等待 但是未满足“空闲让进”规则
考虑如下情况： 情况一：某一时刻turn == i;Pi进入了临界区后，由于某种情况Pi进程直接退出，不能执行下面的turn = j;语句。 那么turn一直为i，Pj始终不能进入临界区。
情况二：在Pi执行完一次后，turn == j;此时Pj可以进入临界区，但是Pj不需要执行，Pi需要再次执行。 但是由于Pj始终没执行，turn一直是j。Pi也一直不能执行。即Pi和Pj必须交替执行。   算法2 增加标志 想法 设置一个标志位表明临界区是否为被占用。一旦有进程进入，就将标志位置为忙碌。 用ture表示临界区被占用，false表示临界区空闲。flag[x]表示进程Px对临界区的操作。  增加标志方法1 while(1) while(1) { { while(flag[j]) while(flag[i]) ; ; flag[i] = true; flag[j] = true; 临界区 临界区 flag[i] = false; flag[j] = false; 剩余区 剩余区 } } 实例化理解 借助在网上看到的一个很好的例子。假设Pi和Pj进程是两个人，临界区是每次只有一个人的公共厕所。 厕所有一个灯，当有人进去就将灯打开告诉外面里面有人。当灯亮了外面的人就要等待。 在某一时刻，i和j同时想要进去。他们观察到里面灯没亮，即while语句的flag[i,j]都是false。 于是两人都想进去后将灯点亮来占有厕所。于是出现了两人一起进到厕所的情况。 抽象来看：由于多道程序的走走停停的特性。 可能先执行while(flag[j])，flag[j]是false，表示Pj没占用临界区。于是Pi准备进入。 此时执行while(flag[i])。同样的Pj认为Pi没占有临界区，也准备进入。 然后执行flag[i] = ture; 和 flag[j] = ture; 出现了Pi，Pj同时进入临界区的bug 即未能保证进程互斥的访问临界区的原则。   增加标志方法2 交换 while(flag[j]) while(flag[i]) 这两条语句的位置。 ; ; flag[i] = true; flag[j] = true;  即在while前先将flag[]置为1，表示将要占用临界区;</description>
    </item>
    
    <item>
      <title>Union Find算法</title>
      <link>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Sep 2020 18:26:44 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%95/</guid>
      <description>union-find|并查集 问题引入 假设给定一个数组A[0..n]。将它的每个点都看作一个独立的，每个点都可以用来表示任何一种数据类型。
对于给定的一对整数对，判断是否属于同一个集合。
若不属于同一个集合，则将两者所在的集合并为同一个集合。 参考第1.5节1的内容，将对象成为触点，将整数对称为连接，将等价类称为连通分量。
引入算法的目的 可以用于计算机网络，假设每个点都是一台计算机。
对于想要通信的两台计算机可以抽象为输入的一个整数对。算法可以判断两台计算机之间是否可以有连接能够通信。若没有连接则需要建立连接。
同时假设有一个十分庞大的人际关系网，使用算法可以很快的判断出对于输入的两人是否相识。并查集是一种简单有效的算法。
 API 首先给出算法的API
UF（） //构造方法 初始化N个触点 void union(int p,int q) //将p和q连接到一个连通分量里 int find(int p) //返回p所在的连通分量的表示符(称为id) boolean connected(int p,int q) //判断p和q是否处于同一个连通分量 int getCount() //返回总的连通分量的个数 想法 有一个直观的想法：判断是否在同一连通分量只要看两个连通分量的id是否相同。因为 一个连通分量的所有触点的id都是一样的。
所有对于给定的一个整数对，先用find()找出两者所在的连通分量的id。
若id相同即说明二者在同一连通分量内，无需union
若id不同，则说明二者处在不同的连通分量内。调用union()。
union:循环遍历整个触点的数组 将id与触点p的id相同的所有触点该称q所在的连通分量的id，这就保证了将p所在的连通分量连接到q的连通分量上。
union()的最后不能忘记将count&amp;ndash; 说明整个连通分量的数目减1.实现 UF() class UF { private int[]id; //以触点作为索引  private int count; public UF(int N) //构造方法 用于初始化触点  { count = N; id = new int[N]; for(int i=0;i&amp;lt;N;i++) { id[i] = i; } } getCount() public int getCount() //用于返回private成员count 即连通分量的数目  { return count; } find() public int find(int p) //返回p的连通分量  { return id[p]; } union public void union(int p,int q) //将触点p和q连接到统一连通分量  { int pID = find(p); int qID = find(q); if(pID == qID) //p,q已经统一连通分量 空操作  { return; } for(int i=0;i&amp;lt;id.</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://yzz-git111.github.io/post/discribtion/</link>
      <pubDate>Sat, 26 Sep 2020 12:25:39 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/discribtion/</guid>
      <description>简介 这是我的个人博客
从今天开始我会陆续更新一些文章
文章主要内容是自己在学习编程路上的一些笔记或者总结
希望大家关注！
我的Github 克隆了一些看到的优秀的代码资源
 附加markdown文件的一些语法   标题
 一级标题 # 二级标题 ## 三级标题 ###    字体
 斜体:字符串两边加 * 粗体:字符串两边加 ** 粗斜体:字符串两边加 *** 例如：哈哈 嘿嘿 嘻嘻    删除线
 在文字的两端加上两个波浪线 ~~ 即可 例如：123 1230    下划线
 下划线可以通过 HTML的标签来实现 例如：Hello World!     脚注
 创建一个脚注用于注释 1    区块
 区块1 (用一个&amp;gt;)
 区块二 (用两个&amp;gt;) 区块三</description>
    </item>
    
  </channel>
</rss>