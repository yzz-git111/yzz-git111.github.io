<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on yzz也想变成学霸</title>
    <link>https://yzz-git111.github.io/post/</link>
    <description>Recent content in Posts on yzz也想变成学霸</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Sep 2020 12:27:58 +0800</lastBuildDate>
    
	<atom:link href="https://yzz-git111.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Unionfind算法2,3</title>
      <link>https://yzz-git111.github.io/post/unionfind%E7%AE%97%E6%B3%952/</link>
      <pubDate>Sun, 27 Sep 2020 12:27:58 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/unionfind%E7%AE%97%E6%B3%952/</guid>
      <description>quickfind算法反思 对于quickfind算法，其影响时间复杂度的主要是union()方法。 union遍历整个触点数组，将一个触点所在的连通分量的所有触点的id都换位另一个连通分量的值 即union(int p,int q) {id[i] = qID}  quickunion算法想法 初始状态下，每个触点都看作一个独立的连通分量，而每个连通分量又可以抽象成为一棵树，虽然此时只有根节点。 显然，根触点满足id[i] = i这一条件 假若一个触点p与另一个触点q进行union。只要将p连接到q的树（q所在连通分量）上。即将p的id改为q的id； 对于普通情况，假如将p连接到q上 因为p，q分别在两棵不同的树上(属于不同的连通分量)， 此时就要找到q所在的连通分量的根触点的id值qRoot，同时找到p所在的连通分量的根触点pRoot。只要将id[pRoot]赋值为qRoot即可 将根节点q所在的树作为子树连接到p所在的树上。  find()  public int find(int p) //返回p的连通分量 { while(p != id[p]) //满足p == id[p]的才是根结点 { p = id[p]; } return p; } union()  int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) //p,q已经统一连通分量 空操作 { return; } id[pRoot] = qRoot; //直接连接到根触点下 count--; //一次union count自减1 实例 假设union(5,9) i | 0 1 2 3 4 5 6 7 8 9 id| 1 1 1 8 3 0 5 1 8 8 find(5)：触点5的id是0（触点5在连通分量0中）所以5不是根触点，向上找根触点，触点0的id是1，1不是根触点。 继续向上找，触点1的id为1(触点1在连通分量1（初始的连通分量）中) 所有连通分量1就是触点5所在的连通分量，且1就是根触点 find(9):同理找到触点9所在的连通分量的根触点 为8 （根触点的连通分量就是本身，即id[8]=8） 此时只要 id[1]=8即可 union(5,9)的结果为 i | 0 1 2 3 4 5 6 7 8 9 id| 1 8 1 8 3 0 5 1 8 8  算法分析 在最坏情况下，每次都是union(p,q)的p都是只有一个触点的连通分量，q是另一个连通分量的最末尾的触点 每次find()都要遍历整个连通分量所抽象出来的树才能找到根触点。 因此处理n对整数所需的所有的find()操作访问数组的总次数为3+5+7+.</description>
    </item>
    
    <item>
      <title>Union Find算法1(quick-find算法)</title>
      <link>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%951/</link>
      <pubDate>Sat, 26 Sep 2020 18:26:44 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%951/</guid>
      <description>union-find|并查集 问题引入 假设给定一个数组A[0..n]。将它的每个点都看作一个独立的，每个点都可以用来表示任何一种数据类型。 现在把每个点都当作一个集合。对于给定的一对整数对，可以判断是否属于同一个集合。 若不属于同一个集合，则将两者所在的集合并为同一个集合。 参考《算法(第四版)》第1.5节的内容，将对象成为触点，将整数对称为连接，将等价类称为连通分量。  引入算法的目的 可以用于计算机网络，假设每个点都是一台计算机。 对于想要通信的两台计算机可以抽象为输入的一个整数对。算法可以判断两台计算机之间是否可以有连接能够通信。若没有连接则需要建立连接。 同时假设有一个十分庞大的人际关系网，使用算法可以很快的判断出对于输入的两人是否相识。并查集是一种简单有效的算法。   API 首先给出算法的API  UF（） //构造方法 初始化N个触点 void union(int p,int q) //将p和q连接到一个连通分量里 int find(int p) //返回p所在的连通分量的表示符(称为id) boolean connected(int p,int q) //判断p和q是否处于同一个连通分量 int getCount() //返回总的连通分量的个数 想法 有一个直观的想法：判断是否在同一连通分量只要看两者的连通分量的id是否相同。因为一个连通分量的所有触点的id都是一样的。 所有对于给定的一个整数对，先用find()找出两者所在的连通分量的id。 若id相同即说明二者在同一连通分量内，无需union 若id不同，则说明二者处在不同的连通分量内。调用union()。 循环遍历整个触点的数组 将id与触点p的id相同的所有触点该称q所在的连通分量的id，这就保证了将p所在的连通分量连接到q的连通分量上。 union()的最后不能忘记将count-- 说明整个连通分量的数目减1.  实现 UF() class UF { private int[]id; //以触点作为索引 private int count; public UF(int N) //构造方法 用于初始化触点 { count = N; id = new int[N]; for(int i=0;i&amp;lt;N;i++) { id[i] = i; } } getCount()  public int getCount() //用于返回private成员count 即连通分量的数目 { return count; } find()  public int find(int p) //返回p的连通分量 { return id[p]; } union  public void union(int p,int q) //将触点p和q连接到统一连通分量 { int pID = find(p); int qID = find(q); if(pID == qID) //p,q已经统一连通分量 空操作 { return; } for(int i=0;i&amp;lt;id.</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://yzz-git111.github.io/post/discribtion/</link>
      <pubDate>Sat, 26 Sep 2020 12:25:39 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/discribtion/</guid>
      <description>这是我的个人博客
从今天开始我会陆续更新一些文章
文章主要内容是自己在学习编程路上的一些笔记或者总结
希望大家关注！
 这是我的Github 克隆了一些看到的优秀的代码资源</description>
    </item>
    
  </channel>
</rss>