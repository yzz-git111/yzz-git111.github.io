<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>https://yzz-git111.github.io/post/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 21 Oct 2020 16:39:25 +0800</lastBuildDate>
    
	<atom:link href="https://yzz-git111.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>快速排序</title>
      <link>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 21 Oct 2020 16:39:25 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>思想 考虑这样的一个情况：如果给定你一个方法partition(),此方法能够实现将一个序列进行划分。 以序列的第一个元素a[low]作为划分的依据，将原序列划分成为(小于a[low])(a[low])(大于a[low]).
那么将可以怎么利用这个方法对序列进行排序呢？ 运用分而治之（Divid &amp;amp; conquer）的思想：首先对于原始的大的序列，取第一个元素进行划分，将原问题划分为两个小的子问题。 要使得整个序列都有序，且因为这个划分的元素已经处于其对应的有序序列的位置，所以只要保证两个子问题有序即可。 对于划分的两个子问题，其中一个子问题是所有小于划分元素的，另一个子问题是所有大于划分元素的。再递归的对这两个子问题进行划分， 直至将问题划分到只有一个元素，这就是平凡问题（一个元素的序列已经有序）。 这时由于每个子问题都已经有序，且所有的划分元素都在其对应的有序序列的位置，所以整个序列都保证有序。
那么如何实现对问题的划分呢？ 我们可以总是以序列的首元素进行划分元素。从左往右直至选到一个大于等于划分元素的，同时从右往左直至选到一个小于等于比划分元素的。 这时交换两个元素。如此继续下去，就可以保证左指针i左侧的所有元素都不大于切分元素，右指针j右侧的所有元素都不小于切分元素。 最后当两个指针相遇时，就说明遍历完了数组，此时只要将切分元素（序列的首元素）与左子序列最右侧的元素（a[j]）交换并返回j。 其中返回j时为了下面进行更小子序列的划分。直到子序列只有一个元素，就可以直接返回。
源码 public class QuickSort { public static void sort(Comparable[] a) { StdRandom.shuffle(a); //对初始序列进行随机打乱  sort(a,0,a.length-1); } public static void sort(Comparable[] a,int low ,int high) { if(high&amp;lt;=low) return; int j = partition(a,low,high); sort(a,low,j-1); sort(a,j+1,high); //划分成三分 小于j的 j 大于j的  } public static int partition(Comparable[] a,int low,int high) { int i=low; // low是切分元素 low+1是第一个扫描的元素  int j=high+1; // high+1 是数组最后一个元素的后一个 high才是第一个扫描的元素  Comparable v=a[low]; //第一个元素为切分元素  while(true) { while(template.</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://yzz-git111.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 18 Oct 2020 21:28:01 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>基础 考虑这样一种情况：对于两个已经有序的子序列，如何实现将这两个子序列排序。(重点：带归并的子序列已经有序) 这就相当于对于两个有序链表合并为一个大的有序链表的问题。 方法：用两个“指针”分别指向子序列的第一个元素。先比较两个子序列的第一个元素哪个小，把小的放到另一个数组（从数组第一个位置开始放）。 然后将较小元素的指针往后移动一个，指向下一个元素。再次比较这两个指针所指元素的大小，每次把较小的元素放到另一个数组。 若有一个子序列的所有元素已经放完（指针移动到了最后一个元素之后）。由于子序列都有序，这时只要将另一个子序列的元素依次放入即可。 实例：1 3 5 | 2 4 6 8 新的数组 1 3 5 | 2 4 6 8 新的数组 1 2 3 5 | 4 6 8 新的数组 1 2 3 5 | 4 6 8 新的数组 1 2 3 4 5 | 6 8 新的数组 1 2 3 4 5 | 6 8 //这时一个子序列已经没了 新的数组 1 2 3 4 5 6 新的数组 1 2 3 4 5 6 8   merge源码 public static void merge(Comparable[] a,int low, int mid,int high) { int i=low; int j=mid+1; for(int k=low;k&amp;lt;=high;k++) //赋值到辅助数组中  { aux[k] = a[k]; } for(int k=low;k&amp;lt;=high;k++) { if(i&amp;gt;mid) //左半边归并光了  { a[k] = aux[j++]; } else if(j&amp;gt;high) //右半边归并光了  { a[k] = aux[i++]; } else if(template.</description>
    </item>
    
    <item>
      <title>初级排序算法</title>
      <link>https://yzz-git111.github.io/post/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 12 Oct 2020 20:10:17 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>选择排序（SelectSort） 算法思想  结合现实中的例子，每次都从一堆数据中找出最小的数，将他放在第一位。为了将一堆数据排序，需要进行n次（从0到n-1，n为数据个数） 抽象来看，将待排序数据存放到一个数组中。外循环执行n次(遍历整个数组)。每次外循环都实现取未排序的最小的元素。 为了在一堆数据中找到最小的元素，当然需要再用一个内循环来遍历数组。初始时，对于未排序的元素都将第一个作为最小元素min。 循环从i到n，若第j个元素小于现在的min，则min=j；内循环最后只要将a[min]与a[j]交换就满足了将一个数据排序好。  算法特点 运行时间和输入无关：即使给定的数据已经有序，选择排序任然要遍历数组。 减缓次数和数组大小是线性关系：每次外循环都只会交换两个数。而其他算法数据的移动都比这个多。  源码实现 public static void SelectSort(Comparable[] a) { int N = a.length; for(int i=0;i&amp;lt;N;i++) { int min = i; for(int j=i+1;j&amp;lt;N;j++) { if(template.less(a[j],a[min])) //自己在template类实现 Comparable接口的less方法  { min = j; } } template.exchange(a,i,min); //自己在template类实现exchange方法  } } 复杂度 命题：对于长度为N的数组，选择排序大约需要(N^2)/2次比较和N次交换 时间复杂度： 外循环O(n),内循环O(n),数据交换O(1) T(n) = O(n)*(O(n)+O(1)) =O(n^2); 最好最坏情况都为O(n^2) 空间复杂度： 只需要在交换a[min]与a[j]时申请一个变量temp 所以S(n) = O(1) 相对来说 选择排序算法时间复杂度太高，不适合处理大规模问题。但是其实现简单。   插入排序（InsertSort） 算法思想 插入排序类似于平时打扑克牌，对于每张牌都按顺序插入到适当位置。 对于给定的数组，将其看作三部分组成。其中a[0..i-1]为已经有序部分（初始时仅将a[0]看作有序）； a[i]为待排元素；a[i+1.</description>
    </item>
    
    <item>
      <title>进程的软件同步算法</title>
      <link>https://yzz-git111.github.io/post/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 29 Sep 2020 16:23:45 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%90%8C%E6%AD%A5%E7%AE%97%E6%B3%95/</guid>
      <description>Dekker算法 算法1 共享变量 想法 对于两个进程Pi，Pj，给定一个共享变量turn。当turn==i时，表示允许Pi进入临界区。  算法实现 while(1) while(1) { { while(turn != i) while(turn != j) ; //空操作 ; //空操作 临界区 临界区 turn = j; turn = i; 剩余区 剩余区 } } 这里满足了同步机制的规则之一：忙则等待 但是未满足“空闲让进”规则
考虑如下情况： 情况一：某一时刻turn == i;Pi进入了临界区后，由于某种情况Pi进程直接退出，不能执行下面的turn = j;语句。 那么turn一直为i，Pj始终不能进入临界区。
情况二：在Pi执行完一次后，turn == j;此时Pj可以进入临界区，但是Pj不需要执行，Pi需要再次执行。 但是由于Pj始终没执行，turn一直是j。Pi也一直不能执行。即Pi和Pj必须交替执行。   算法2 增加标志 想法 设置一个标志位表明临界区是否为被占用。一旦有进程进入，就将标志位置为忙碌。 用ture表示临界区被占用，false表示临界区空闲。flag[x]表示进程Px对临界区的操作。  增加标志方法1 while(1) while(1) { { while(flag[j]) while(flag[i]) ; ; flag[i] = true; flag[j] = true; 临界区 临界区 flag[i] = false; flag[j] = false; 剩余区 剩余区 } } 实例化理解 借助在网上看到的一个很好的例子。假设Pi和Pj进程是两个人，临界区是每次只有一个人的公共厕所。 厕所有一个灯，当有人进去就将灯打开告诉外面里面有人。当灯亮了外面的人就要等待。 在某一时刻，i和j同时想要进去。他们观察到里面灯没亮，即while语句的flag[i,j]都是false。 于是两人都想进去后将灯点亮来占有厕所。于是出现了两人一起进到厕所的情况。 抽象来看：由于多道程序的走走停停的特性。 可能先执行while(flag[j])，flag[j]是false，表示Pj没占用临界区。于是Pi准备进入。 此时执行while(flag[i])。同样的Pj认为Pi没占有临界区，也准备进入。 然后执行flag[i] = ture; 和 flag[j] = ture; 出现了Pi，Pj同时进入临界区的bug 即未能保证进程互斥的访问临界区的原则。   增加标志方法2 交换 while(flag[j]) while(flag[i]) 这两条语句的位置。 ; ; flag[i] = true; flag[j] = true;  即在while前先将flag[]置为1，表示将要占用临界区;</description>
    </item>
    
    <item>
      <title>Unionfind算法2,3</title>
      <link>https://yzz-git111.github.io/post/unionfind%E7%AE%97%E6%B3%952/</link>
      <pubDate>Sun, 27 Sep 2020 12:27:58 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/unionfind%E7%AE%97%E6%B3%952/</guid>
      <description>quickfind算法反思 对于quickfind算法，其影响时间复杂度的主要是union()方法。 union遍历整个触点数组，将一个触点所在的连通分量的所有触点的id都换位另一个连通分量的值 即union(int p,int q) {id[i] = qID}  quickunion算法想法 初始状态下，每个触点都看作一个独立的连通分量，而每个连通分量又可以抽象成为一棵树，虽然此时只有根节点。 显然，根触点满足id[i] = i这一条件 假若一个触点p与另一个触点q进行union。只要将p连接到q的树（q所在连通分量）上。即将p的id改为q的id； 对于普通情况，假如将p连接到q上 因为p，q分别在两棵不同的树上(属于不同的连通分量)， 此时就要找到q所在的连通分量的根触点的id值qRoot，同时找到p所在的连通分量的根触点pRoot。只要将id[pRoot]赋值为qRoot即可 将根节点q所在的树作为子树连接到p所在的树上。  find() public int find(int p) //返回p的连通分量  { while(p != id[p]) //满足p == id[p]的才是根结点  { p = id[p]; } return p; } union() int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot) //p,q已经统一连通分量 空操作  { return; } id[pRoot] = qRoot; //直接连接到根触点下  count--; //一次union count自减1 实例 假设union(5,9) i | 0 1 2 3 4 5 6 7 8 9 id| 1 1 1 8 3 0 5 1 8 8 find(5)：触点5的id是0（触点5在连通分量0中）所以5不是根触点，向上找根触点，触点0的id是1，1不是根触点。 继续向上找，触点1的id为1(触点1在连通分量1（初始的连通分量）中) 所有连通分量1就是触点5所在的连通分量，且1就是根触点 find(9):同理找到触点9所在的连通分量的根触点 为8 （根触点的连通分量就是本身，即id[8]=8） 此时只要 id[1]=8即可 union(5,9)的结果为 i | 0 1 2 3 4 5 6 7 8 9 id| 1 8 1 8 3 0 5 1 8 8  算法分析 在最坏情况下，每次都是union(p,q)的p都是只有一个触点的连通分量，q是另一个连通分量的最末尾的触点 每次find()都要遍历整个连通分量所抽象出来的树才能找到根触点。 因此处理n对整数所需的所有的find()操作访问数组的总次数为3+5+7+.</description>
    </item>
    
    <item>
      <title>Union Find算法1(quick-find算法)</title>
      <link>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%951/</link>
      <pubDate>Sat, 26 Sep 2020 18:26:44 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/union-find%E7%AE%97%E6%B3%951/</guid>
      <description>union-find|并查集 问题引入 假设给定一个数组A[0..n]。将它的每个点都看作一个独立的，每个点都可以用来表示任何一种数据类型。 现在把每个点都当作一个集合。对于给定的一对整数对，可以判断是否属于同一个集合。 若不属于同一个集合，则将两者所在的集合并为同一个集合。 参考《算法(第四版)》第1.5节的内容，将对象成为触点，将整数对称为连接，将等价类称为连通分量。  引入算法的目的 可以用于计算机网络，假设每个点都是一台计算机。 对于想要通信的两台计算机可以抽象为输入的一个整数对。算法可以判断两台计算机之间是否可以有连接能够通信。若没有连接则需要建立连接。 同时假设有一个十分庞大的人际关系网，使用算法可以很快的判断出对于输入的两人是否相识。并查集是一种简单有效的算法。   API 首先给出算法的API  UF（） //构造方法 初始化N个触点 void union(int p,int q) //将p和q连接到一个连通分量里 int find(int p) //返回p所在的连通分量的表示符(称为id) boolean connected(int p,int q) //判断p和q是否处于同一个连通分量 int getCount() //返回总的连通分量的个数 想法 有一个直观的想法：判断是否在同一连通分量只要看两者的连通分量的id是否相同。因为一个连通分量的所有触点的id都是一样的。 所有对于给定的一个整数对，先用find()找出两者所在的连通分量的id。 若id相同即说明二者在同一连通分量内，无需union 若id不同，则说明二者处在不同的连通分量内。调用union()。 循环遍历整个触点的数组 将id与触点p的id相同的所有触点该称q所在的连通分量的id，这就保证了将p所在的连通分量连接到q的连通分量上。 union()的最后不能忘记将count-- 说明整个连通分量的数目减1.  实现 UF() class UF { private int[]id; //以触点作为索引  private int count; public UF(int N) //构造方法 用于初始化触点  { count = N; id = new int[N]; for(int i=0;i&amp;lt;N;i++) { id[i] = i; } } getCount() public int getCount() //用于返回private成员count 即连通分量的数目  { return count; } find() public int find(int p) //返回p的连通分量  { return id[p]; } union public void union(int p,int q) //将触点p和q连接到统一连通分量  { int pID = find(p); int qID = find(q); if(pID == qID) //p,q已经统一连通分量 空操作  { return; } for(int i=0;i&amp;lt;id.</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://yzz-git111.github.io/post/discribtion/</link>
      <pubDate>Sat, 26 Sep 2020 12:25:39 +0800</pubDate>
      
      <guid>https://yzz-git111.github.io/post/discribtion/</guid>
      <description>这是我的个人博客
从今天开始我会陆续更新一些文章
文章主要内容是自己在学习编程路上的一些笔记或者总结
希望大家关注！
 这是我的Github 克隆了一些看到的优秀的代码资源</description>
    </item>
    
  </channel>
</rss>