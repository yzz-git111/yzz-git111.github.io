<!doctype html>
<html lang="en-us">
  <head>
    <title>二叉查找树 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="二叉查找树"/>
<meta name="twitter:description" content="符号表的实现除了数组和链表的实现。还有一种借助二叉树的实现。即二叉查找树(二叉排序树)。
二叉查找树(Binary-Search-Tree)是一棵二叉树，每个结点都含有一个Comparable的键(以及相关联的值)，且每个结点的键都大于其左子树中任意结点的键而小于右子数的任意结点的键。
 数据结构 二叉查找树的数据结构的实现和二叉树类似。也可以利用数组和链表的方式。
使用数组存储即将二叉查找树看作完全二叉树，并按照层次遍历依次存放进数组中。
可见数组存储二叉查找树是很浪费，只有当二叉树是近似完全二叉树时用这种方式既不浪费空间又可以快速按照下标访问元素。
所以二叉查找树使用链表的方式存储。
和链表一样，嵌套定义一个私有类来表示一个结点。每个结点都含有一个键，一个值，一个左链接，一个右链接和一个结点计数器。
几个细节：
 类BST采用泛型，且其中只有键Key实现了Comparable，因为只比较键的大小。 定义的size来存储以这个结点为根的树的结点的个数，方便了后面方法的实现。 类BST的new的对象只有一个null的结点成员，需要通过插入新结点来构造成二叉树。  public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; { private Node root; private class Node { private Key key; private Value val; private Node left, right; private int size; public Node(Key key, Value val, int size) { this.key = key; this.val = val; this.size = size; } } public BST() {} public boolean isEmpty() { return size() == 0; } public int size() { return size(root); } private int size(Node x) { if (x == null) return 0; else return x."/>

    <meta property="og:title" content="二叉查找树" />
<meta property="og:description" content="符号表的实现除了数组和链表的实现。还有一种借助二叉树的实现。即二叉查找树(二叉排序树)。
二叉查找树(Binary-Search-Tree)是一棵二叉树，每个结点都含有一个Comparable的键(以及相关联的值)，且每个结点的键都大于其左子树中任意结点的键而小于右子数的任意结点的键。
 数据结构 二叉查找树的数据结构的实现和二叉树类似。也可以利用数组和链表的方式。
使用数组存储即将二叉查找树看作完全二叉树，并按照层次遍历依次存放进数组中。
可见数组存储二叉查找树是很浪费，只有当二叉树是近似完全二叉树时用这种方式既不浪费空间又可以快速按照下标访问元素。
所以二叉查找树使用链表的方式存储。
和链表一样，嵌套定义一个私有类来表示一个结点。每个结点都含有一个键，一个值，一个左链接，一个右链接和一个结点计数器。
几个细节：
 类BST采用泛型，且其中只有键Key实现了Comparable，因为只比较键的大小。 定义的size来存储以这个结点为根的树的结点的个数，方便了后面方法的实现。 类BST的new的对象只有一个null的结点成员，需要通过插入新结点来构造成二叉树。  public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; { private Node root; private class Node { private Key key; private Value val; private Node left, right; private int size; public Node(Key key, Value val, int size) { this.key = key; this.val = val; this.size = size; } } public BST() {} public boolean isEmpty() { return size() == 0; } public int size() { return size(root); } private int size(Node x) { if (x == null) return 0; else return x." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" />
<meta property="article:published_time" content="2020-11-02T12:50:56+08:00" />
<meta property="article:modified_time" content="2020-11-02T12:50:56+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">二叉查找树</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 2, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>符号表的实现除了数组和链表的实现。还有一种借助二叉树的实现。即二叉查找树(二叉排序树)。<br>
二叉查找树(Binary-Search-Tree)是一棵二叉树，每个结点都含有一个Comparable的键(以及相关联的值)，且<strong>每个结点的键都大于其左子树中任意结点的键而小于右子数的任意结点的键。</strong></p>
<hr>
<h2 id="数据结构">数据结构</h2>
<p>二叉查找树的数据结构的实现和二叉树类似。也可以利用数组和链表的方式。<br>
使用数组存储即将二叉查找树看作完全二叉树，并按照层次遍历依次存放进数组中。<br>
可见数组存储二叉查找树是很浪费，<strong>只有当二叉树是近似<em>完全二叉树</em>时用这种方式既不浪费空间又可以快速按照下标访问元素。</strong></p>
<p>所以二叉查找树使用链表的方式存储。<br>
和链表一样，嵌套定义一个私有类来表示一个结点。每个结点都含有一个键，一个值，一个左链接，一个右链接和一个结点计数器。<br>
几个细节：</p>
<ol>
<li>类BST采用泛型，且其中只有键Key实现了Comparable，因为只比较键的大小。</li>
<li>定义的size来存储以这个结点为根的树的结点的个数，方便了后面方法的实现。</li>
<li>类BST的new的对象只有一个null的结点成员，需要通过插入新结点来构造成二叉树。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BST</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;,</span> Value<span style="color:#f92672">&gt;</span> 
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Node root<span style="color:#f92672">;</span>             

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> 
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">private</span> Key key<span style="color:#f92672">;</span>           
        <span style="color:#66d9ef">private</span> Value val<span style="color:#f92672">;</span>    
        <span style="color:#66d9ef">private</span> Node left<span style="color:#f92672">,</span> right<span style="color:#f92672">;</span>  
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>          

        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">)</span> 
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> size<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BST</span><span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> size<span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> size<span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.2.1bst-subtree-count.png" alt=""><br>
二叉树有先序，中序，后续和层次遍历4种方法。其中通过<strong>中序遍历</strong>一颗二叉查找树可以得到一个<strong>有序序列</strong>。</p>
<hr>
<h2 id="基本方法-递归">基本方法 递归</h2>
<p>对于树的方法的实现，一定要有 <em><strong>递归</strong></em> 的思想。</p>
<ol>
<li>查找
<strong>如果树是空的，则查找未命中;若被查找的键和根结点的键相等</strong>，查找命中。若被查找的键比根结点小就继续在左子树中递归查找;若比根结点大就继续在右子数递归查找。当找到一个含有被查找的键的结点(命中)或者当前子树变为空(未命中)才结束。<br>
<img src="/chapter3/3.2.2bst-search.png" alt=""></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls get() with a null key&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span>              <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="2">
<li>插入
<strong>如果树是空的，就返回一个含有该键值对的新结点</strong>;如果被查找的键小于根结点的键，就在左子树中插入;如果被查找的键大于根结点的键，就在右子数中插入。否则就更新当前键的值。 <br>
插入之后要更新各个结点的size。而size也会递归的调用，直到根结点为空时size=1.根结点不为空size(x)=size(x.left)+size(x.right)+1;
<img src="/chapter3/3.2.3bst-insert.png" alt=""></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls put() with a null key&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>val <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        delete<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    root <span style="color:#f92672">=</span> put<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">assert</span> check<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> val<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span>  <span style="color:#f92672">=</span> put<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span>  key<span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> put<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span>              x<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span>   <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>    <span style="color:#75715e">//更新键的值
</span><span style="color:#75715e"></span>    x<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> 1 <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">//更新size()的值。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>   <span style="color:#75715e">//返回新插入的结点
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><ol start="3">
<li>分析
使用二叉查找树的运行时间取决于树的形状，而<strong>树的形状取决于键被插入的先后顺序。</strong>
<strong>最好情况一颗含有N个结点的树是完全平衡，最坏情况搜索路径可能有N个结点。</strong> <br>
假设<strong>键的插入顺序是随机的</strong>，那么二叉查找树和<strong>快速排序</strong>很类似。<strong>树的根结点就是快速排序的第一个切分元素。且对所有子树都适用，这和快速排序中对子数组的递归排序完全一致。</strong></li>
</ol>
<p>命题：在由N个随机键构造的二叉查找树，查找命中平均所需的比较次数为~2logN(约1.39logN)<br>
命题：在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2logN(约1.39logN) <br>
<strong>虽然二叉查找树查找的平均成本比二分查找高约39%.但是这是值得的，因为插入一个新键的成本是对数级别O(logN)的（而二分查找插入的成本是线性的O(N)）</strong> <br>
<img src="/chapter3/3.2.4bst-best.png" alt="">
<img src="/chapter3/3.2.5bst-typical.png" alt="">
<img src="/chapter3/3.2.6bst-worst.png" alt=""></p>
<hr>
<p>下面学习一些二叉查找树的其他操作，也都用到了<strong>递归</strong>的方法</p>
<h2 id="最大键和最小键">最大键和最小键</h2>
<p>回顾二叉查找树的性质：<strong>左子树所有结点的键值比根结点小，右子树比根结点大。</strong><br>
那么查找二叉查找树的最大/最小结点方法：<strong>如当前根结点左子树为空，则这棵二叉查找树最小结点就是根结点。如果左子树不为空。那么就是左子树的最小结点</strong>。这个方法有递归性质，<strong>只有在以某一个结点为根结点的左子树为空才会一层层返回。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">min</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls min() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> min<span style="color:#f92672">(</span>root<span style="color:#f92672">).</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span>                <span style="color:#66d9ef">return</span> min<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">max</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls max() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> max<span style="color:#f92672">(</span>root<span style="color:#f92672">).</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span>                 <span style="color:#66d9ef">return</span> max<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<h2 id="向上取整和向下取整">~~向上取整和向下取整</h2>
<p>定义floor(Key key)返回小于等于key的最大结点；ceiling(Key key)返回大于等于key的最小结点。<br>
对于floor()方法，<strong>如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大键一定在根结点的左子树;如果key大于二叉查找树的根结点，那么只有当根结点的右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中。否则根结点就是小于等于key的最大键。</strong><br>
<strong>先判断是否等于，等于直接返回根结点。然后判断是否继续在左子树找。如果都不是就在右子树中找，如果没找到返回null就返回右子树的根结点。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">floor</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to floor() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls floor() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    Node x <span style="color:#f92672">=</span> floor<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to floor() is too small&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">floor</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>     <span style="color:#75715e">//找到相等的直接返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span>  0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> floor<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>   <span style="color:#75715e">//在左子树找有没有小于等于x的
</span><span style="color:#75715e"></span>    Node t <span style="color:#f92672">=</span> floor<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>   
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>  <span style="color:#75715e">//右子树没找到满足条件的就直接返回这个根结点
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>


<span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">ceiling</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to ceiling() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls ceiling() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    Node x <span style="color:#f92672">=</span> ceiling<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to floor() is too large&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">ceiling</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node t <span style="color:#f92672">=</span> ceiling<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> ceiling<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.2.7bst-floor.png" alt=""></p>
<hr>
<h2 id="选择和排名">选择和排名</h2>
<p>在定义数据结构时维护一个子树结点计数器变量N主要就是为了实现这两个方法的。</p>
<ol>
<li>选择 select(int k):返回排名第k的键(<strong>即树中刚好有k个键小于它</strong>).（k从0开始）
想法：<strong>若左子树的结点t大于k，就说明这个键在左子树中，就继续递归地在左子树中查找。如果等于k，就说明这个根结点就是要找的。如果t小于k，就递归地在右子树中查找排名为(k-t-1)的键。</strong></li>
</ol>
<h1 id="注意点">注意点</h1>
<p>这里的每个方法都对应着一个私有方法，私有方法额外接受一个链接作为参数指向某个结点。<strong>目的是方便递归的调用，且别人在使用时只需要给出键不需要输入根结点。对别人来说是透明的。</strong></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
