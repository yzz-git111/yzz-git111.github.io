<!doctype html>
<html lang="en-us">
  <head>
    <title>二叉查找树 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="二叉查找树"/>
<meta name="twitter:description" content="符号表的实现除了数组和链表的实现。还有一种借助二叉树的实现。即二叉查找树(二叉排序树)。
二叉查找树(Binary-Search-Tree)是一棵二叉树，每个结点都含有一个Comparable的键(以及相关联的值)，且每个结点的键都大于其左子树中任意结点的键而小于右子数的任意结点的键。
 数据结构 二叉查找树的数据结构的实现和二叉树类似。也可以利用数组和链表的方式。
使用数组存储即将二叉查找树看作完全二叉树，并按照层次遍历依次存放进数组中。
可见数组存储二叉查找树是很浪费，只有当二叉树是近似完全二叉树时用这种方式既不浪费空间又可以快速按照下标访问元素。
所以二叉查找树使用链表的方式存储。
和链表一样，嵌套定义一个私有类来表示一个结点。每个结点都含有一个键，一个值，一个左链接，一个右链接和一个结点计数器。
几个细节：
 类BST采用泛型，且其中只有键Key实现了Comparable，因为只比较键的大小。 定义的size来存储以这个结点为根的树的结点的个数，方便了后面方法的实现。 类BST的new的对象只有一个null的结点成员，需要通过插入新结点来构造成二叉树。  public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; { private Node root; private class Node { private Key key; private Value val; private Node left, right; private int size; public Node(Key key, Value val, int size) { this.key = key; this.val = val; this.size = size; } } public BST() {} public boolean isEmpty() { return size() == 0; } public int size() { return size(root); } private int size(Node x) { if (x == null) return 0; else return x."/>

    <meta property="og:title" content="二叉查找树" />
<meta property="og:description" content="符号表的实现除了数组和链表的实现。还有一种借助二叉树的实现。即二叉查找树(二叉排序树)。
二叉查找树(Binary-Search-Tree)是一棵二叉树，每个结点都含有一个Comparable的键(以及相关联的值)，且每个结点的键都大于其左子树中任意结点的键而小于右子数的任意结点的键。
 数据结构 二叉查找树的数据结构的实现和二叉树类似。也可以利用数组和链表的方式。
使用数组存储即将二叉查找树看作完全二叉树，并按照层次遍历依次存放进数组中。
可见数组存储二叉查找树是很浪费，只有当二叉树是近似完全二叉树时用这种方式既不浪费空间又可以快速按照下标访问元素。
所以二叉查找树使用链表的方式存储。
和链表一样，嵌套定义一个私有类来表示一个结点。每个结点都含有一个键，一个值，一个左链接，一个右链接和一个结点计数器。
几个细节：
 类BST采用泛型，且其中只有键Key实现了Comparable，因为只比较键的大小。 定义的size来存储以这个结点为根的树的结点的个数，方便了后面方法的实现。 类BST的new的对象只有一个null的结点成员，需要通过插入新结点来构造成二叉树。  public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; { private Node root; private class Node { private Key key; private Value val; private Node left, right; private int size; public Node(Key key, Value val, int size) { this.key = key; this.val = val; this.size = size; } } public BST() {} public boolean isEmpty() { return size() == 0; } public int size() { return size(root); } private int size(Node x) { if (x == null) return 0; else return x." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" />
<meta property="article:published_time" content="2020-11-02T12:50:56+08:00" />
<meta property="article:modified_time" content="2020-11-02T12:50:56+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">二叉查找树</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 2, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>符号表的实现除了数组和链表的实现。还有一种借助二叉树的实现。即二叉查找树(二叉排序树)。<br>
二叉查找树(Binary-Search-Tree)是一棵二叉树，每个结点都含有一个Comparable的键(以及相关联的值)，且<strong>每个结点的键都大于其左子树中任意结点的键而小于右子数的任意结点的键。</strong></p>
<hr>
<h2 id="数据结构">数据结构</h2>
<p>二叉查找树的数据结构的实现和二叉树类似。也可以利用数组和链表的方式。<br>
使用数组存储即将二叉查找树看作完全二叉树，并按照层次遍历依次存放进数组中。<br>
可见数组存储二叉查找树是很浪费，<strong>只有当二叉树是近似<em>完全二叉树</em>时用这种方式既不浪费空间又可以快速按照下标访问元素。</strong></p>
<p>所以二叉查找树使用链表的方式存储。<br>
和链表一样，嵌套定义一个私有类来表示一个结点。每个结点都含有一个键，一个值，一个左链接，一个右链接和一个结点计数器。<br>
几个细节：</p>
<ol>
<li>类BST采用泛型，且其中只有键Key实现了Comparable，因为只比较键的大小。</li>
<li>定义的size来存储以这个结点为根的树的结点的个数，方便了后面方法的实现。</li>
<li>类BST的new的对象只有一个null的结点成员，需要通过插入新结点来构造成二叉树。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BST</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;,</span> Value<span style="color:#f92672">&gt;</span> 
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Node root<span style="color:#f92672">;</span>             

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> 
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">private</span> Key key<span style="color:#f92672">;</span>           
        <span style="color:#66d9ef">private</span> Value val<span style="color:#f92672">;</span>    
        <span style="color:#66d9ef">private</span> Node left<span style="color:#f92672">,</span> right<span style="color:#f92672">;</span>  
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>          

        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">)</span> 
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> size<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BST</span><span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> size<span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> size<span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.2.1bst-subtree-count.png" alt=""><br>
二叉树有先序，中序，后续和层次遍历4种方法。其中通过<strong>中序遍历</strong>一棵二叉查找树可以得到一个<strong>有序序列</strong>。</p>
<hr>
<h2 id="基本方法-递归">基本方法 递归</h2>
<p>对于树的方法的实现，一定要有 <em><strong>递归</strong></em> 的思想。</p>
<ol>
<li>查找
<strong>如果树是空的，则查找未命中;若被查找的键和根结点的键相等</strong>，查找命中。若被查找的键比根结点小就继续在左子树中递归查找;若比根结点大就继续在右子数递归查找。当找到一个含有被查找的键的结点(命中)或者当前子树变为空(未命中)才结束。<br>
<img src="/chapter3/3.2.2bst-search.png" alt=""></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls get() with a null key&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span>              <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="2">
<li>插入
<strong>如果树是空的，就返回一个含有该键值对的新结点</strong>;如果被查找的键小于根结点的键，就在左子树中插入;如果被查找的键大于根结点的键，就在右子数中插入。否则就更新当前键的值。 <br>
插入之后要更新各个结点的size。而size也会递归的调用，直到根结点为空时size=1.根结点不为空size(x)=size(x.left)+size(x.right)+1;</li>
</ol>
<p><img src="/chapter3/3.2.3bst-insert.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls put() with a null key&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>val <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        delete<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    root <span style="color:#f92672">=</span> put<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">assert</span> check<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> val<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span>  <span style="color:#f92672">=</span> put<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span>  key<span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> put<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span>              x<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span>   <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>    <span style="color:#75715e">//更新键的值
</span><span style="color:#75715e"></span>    x<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> 1 <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">//更新size()的值。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>   <span style="color:#75715e">//返回新插入的结点
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><ol start="3">
<li>分析
使用二叉查找树的运行时间取决于树的形状，而<strong>树的形状取决于键被插入的先后顺序。</strong>
<strong>最好情况一颗含有N个结点的树是完全平衡，最坏情况搜索路径可能有N个结点。</strong> <br>
假设<strong>键的插入顺序是随机的</strong>，那么二叉查找树和<strong>快速排序</strong>很类似。<strong>树的根结点就是快速排序的第一个切分元素。且对所有子树都适用，这和快速排序中对子数组的递归排序完全一致。</strong></li>
</ol>
<p>命题：在由N个随机键构造的二叉查找树，查找命中平均所需的比较次数为~2logN(约1.39logN)<br>
命题：在由N个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为~2logN(约1.39logN) <br>
<strong>虽然二叉查找树查找的平均成本比二分查找高约39%.但是这是值得的，因为插入一个新键的成本是对数级别O(logN)的（而二分查找插入的成本是线性的O(N)）</strong> <br>
<img src="/chapter3/3.2.4bst-best.png" alt="">
<img src="/chapter3/3.2.5bst-typical.png" alt="">
<img src="/chapter3/3.2.6bst-worst.png" alt=""></p>
<hr>
<p>二叉树由于其性质，也支持有序性的操作，也都用到了<strong>递归</strong>的方法</p>
<h2 id="最大键和最小键">最大键和最小键</h2>
<p>回顾二叉查找树的性质：<strong>左子树所有结点的键值比根结点小，右子树比根结点大。</strong><br>
那么查找二叉查找树的最大/最小结点方法：<strong>如当前根结点左子树为空，则这棵二叉查找树最小结点就是根结点。如果左子树不为空。那么就是左子树的最小结点</strong>。这个方法有递归性质，<strong>只有在以某一个结点为根结点的左子树为空才会一层层返回。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">min</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls min() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> min<span style="color:#f92672">(</span>root<span style="color:#f92672">).</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span>                <span style="color:#66d9ef">return</span> min<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">max</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls max() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> max<span style="color:#f92672">(</span>root<span style="color:#f92672">).</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span>                 <span style="color:#66d9ef">return</span> max<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<h2 id="向上取整和向下取整">~~向上取整和向下取整</h2>
<p>定义floor(Key key)返回小于等于key的最大结点；ceiling(Key key)返回大于等于key的最小结点。<br>
对于floor()方法，<strong>如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大键一定在根结点的左子树;如果key大于二叉查找树的根结点，那么只有当根结点的右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中。否则根结点就是小于等于key的最大键。</strong><br>
<strong>先判断是否等于，等于直接返回根结点。然后判断是否继续在左子树找。如果都不是就在右子树中找，如果没找到返回null就返回右子树的根结点。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">floor</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to floor() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls floor() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    Node x <span style="color:#f92672">=</span> floor<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to floor() is too small&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">floor</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>     <span style="color:#75715e">//找到相等的直接返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span>  0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> floor<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>   <span style="color:#75715e">//在左子树找有没有小于等于x的
</span><span style="color:#75715e"></span>    Node t <span style="color:#f92672">=</span> floor<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>   
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>  <span style="color:#75715e">//右子树没找到满足条件的就直接返回这个根结点
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>


<span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">ceiling</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to ceiling() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls ceiling() with empty symbol table&#34;</span><span style="color:#f92672">);</span>
    Node x <span style="color:#f92672">=</span> ceiling<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to floor() is too large&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">ceiling</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node t <span style="color:#f92672">=</span> ceiling<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> ceiling<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.2.7bst-floor.png" alt=""></p>
<hr>
<h2 id="选择和排名">选择和排名</h2>
<p>在定义数据结构时维护一个子树结点计数器变量N主要就是为了实现这两个方法的。</p>
<ol>
<li>选择
select(int k):返回排名第k的键(<strong>即树中刚好有k个键小于它</strong>).（k从0开始）
想法：<strong>若左子树的结点t大于k，就说明这个键在左子树中，就继续递归地在左子树中查找。如果等于k，就说明这个根结点就是要找的。如果t小于k，就递归地在右子树中查找排名为(k-t-1)的键。</strong></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">select</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> rank<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rank <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> rank <span style="color:#f92672">&gt;=</span> size<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to select() is invalid: &#34;</span> <span style="color:#f92672">+</span> rank<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> select<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> rank<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> Key <span style="color:#a6e22e">select</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> rank<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> leftSize <span style="color:#f92672">=</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>leftSize <span style="color:#f92672">&gt;</span> rank<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> select<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span>  rank<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>leftSize <span style="color:#f92672">&lt;</span> rank<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> select<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> rank <span style="color:#f92672">-</span> leftSize <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span>                      <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.2.8bst-select.png" alt=""></p>
<ol start="2">
<li>排名   rank()方法是select()的逆方法。<strong>如果给定的键和根结点的键相等，则返回左子树的节点总数t;如果给定的键小于根结点的键，递归返回该键在左子树中的排名;如果给定的键大于根结点，返回t+1加他在右子树的排名。</strong></li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rank</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to rank() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> root<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">// Number of keys in the subtree less than key.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rank</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 1 <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span>              <span style="color:#66d9ef">return</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

</code></pre></div><hr>
<h2 id="删除最大键和最小键">删除最大键和最小键</h2>
<p>二叉查找树的最小键一定是最左下角（一直x.left）的结点。且该结点最多只有右子树，不可能有左子树。所以可以一直通过x.left找到最小的结点，然后将最小结点的右子树链接给父结点的左子树即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteMin</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Symbol table underflow&#34;</span><span style="color:#f92672">);</span>
    root <span style="color:#f92672">=</span> deleteMin<span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">assert</span> check<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">deleteMin</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
    x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> deleteMin<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
    x<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>   <span style="color:#75715e">//deleteMin返回的是根结点的链接
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteMax</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NoSuchElementException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Symbol table underflow&#34;</span><span style="color:#f92672">);</span>
    root <span style="color:#f92672">=</span> deleteMax<span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">assert</span> check<span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">deleteMax</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
    x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> deleteMax<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
    x<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.2.9bst-deletemin.png" alt=""></p>
<p>这里不调用min()方法是因为min只返回最小结点，而不返回其父亲结点。不能将父节点的左链接接到最小结点的右子树。<br>
if (x.left == null) return x.right;遇到最小的结点就会返回最小结点的右子树的链接，然后返回到上一级的deleteMin,此时的x是最小结点的父结点，这时在x.left = deleteMin(x.left);就实现了将父节点的左链接接到最小结点的右子树。<br>
最后不能忘记更新每个结点的size(),从下往上更新.</p>
<hr>
<h2 id="删除">删除</h2>
<p>删除方法是二叉查找树的最难实现的一个方法。对于只有一个子树(或者没有子树)的结点都可以用删除最小结点的方法。但是对于两个子树都有的结点需要考虑如何放置两个子树。</p>
<p><em><strong>删除x结点后用它的后继节点(中序遍历的后一个结点)填补它的位置。</strong></em>
<em><strong>因为它x有一个右子树，因此它的后继节点就是右子树的最小结点</strong></em>
***deleMin</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;calls delete() with a null key&#34;</span><span style="color:#f92672">);</span>
        root <span style="color:#f92672">=</span> delete<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">assert</span> check<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span>  <span style="color:#f92672">=</span> delete<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span>  key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> delete<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span> <span style="color:#75715e">//处理没有右子树的情况
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span>  <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//处理没有左子树的情况
</span><span style="color:#75715e"></span>            Node t <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
            x <span style="color:#f92672">=</span> min<span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>   <span style="color:#75715e">//x指向后继节点
</span><span style="color:#75715e"></span>            x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> deleteMin<span style="color:#f92672">(</span>t<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>   <span style="color:#75715e">//x的右链接指向deleteMin返回的链接  --  t的右链接
</span><span style="color:#75715e"></span>            x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>    
        <span style="color:#f92672">}</span>
        x<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> size<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>  <span style="color:#75715e">//更新各个结点的size
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> x<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.2.10bst-delete.png" alt=""></p>
<hr>
<h2 id="范围查找">范围查找</h2>
<p>由于二叉查找树的左子树结点的键均小于根结点的键，而右子树的所有结点的键均大于根结点的键。  <br>
利用二叉树的中序遍历便可以得到二叉查找树所有结点的键的非递减排序。那么如何做才能返回所有结点有序序列的一部分(给出最小的键low和最大的键high，返回low..high的所有的键)?</p>
<p>回顾二叉树的中序遍历：</p>
<ul>
<li>递归实现：先递归到最左下的顶点(没有左子树的结点为止)。然后输出这个结点的键。接着在递归的对右子树遍历。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">//伪代码
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inorderTraverse</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    inorderTraverse<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
    printf<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    inorderTraverse<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>非递归实现：由于中序遍历按照LDR的顺序进行遍历，所以要先输出最小的结点(最左下角的没有左子树的结点)，然后遍历当前访问结点的右子树(如果有的话)，然后逐层返回。这就是要从下往上输出，而给定的根结点位于最上方，所以需要一个栈。将根结点一直到最左下角的顶点压入栈，在依次以栈顶元素为根进行遍历。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">nonRecursiveInorderTraverse</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>1<span style="color:#f92672">):</span>
        <span style="color:#66d9ef">while</span> 有左子树<span style="color:#f92672">:</span>
        stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>当前结点<span style="color:#f92672">);</span>   <span style="color:#75715e">//根结点及左侧的结点入栈
</span><span style="color:#75715e"></span>    
        <span style="color:#66d9ef">if</span> 栈不空<span style="color:#960050;background-color:#1e0010">：</span>
        取栈顶元素并访问

        <span style="color:#66d9ef">if</span> 栈顶元素有右子树<span style="color:#960050;background-color:#1e0010">：</span>
            <span style="color:#66d9ef">while</span> 有左子树<span style="color:#f92672">:</span>
            stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>当前结点<span style="color:#f92672">);</span>   <span style="color:#75715e">//以当前为根结点的树的左侧结点入栈
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>同样的，对于范围查找也需要利用中序遍历。首先沿着左子树找到最小的结点。然后按照中序遍历的顺序依次访问每个属于这个范围的结点(小于等于low且大于等于high)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">keys</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">,</span> Key lo<span style="color:#f92672">,</span> Key hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmplo <span style="color:#f92672">=</span> lo<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> cmphi <span style="color:#f92672">=</span> hi<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmplo <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> keys<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>   <span style="color:#75715e">//沿着左子树找到最小的结点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmplo <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> cmphi <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;   &#34;</span><span style="color:#f92672">);</span>    <span style="color:#75715e">//访问每个属于这个范围的结点(小于等于low且大于等于high)。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmphi <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> keys<span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>   <span style="color:#75715e">//遍历当前访问结点的右子树(如果有的话)
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><hr>
<h2 id="注意点">注意点</h2>
<p>这里的每个方法都对应着一个私有方法，私有方法额外接受一个链接作为参数指向某个结点。<strong>目的是方便递归的调用，且别人在使用时只需要给出键不需要输入根结点。对别人来说是透明的。</strong></p>
<hr>
<h2 id="复杂度分析">复杂度分析</h2>
<p><em><strong>在二叉查找树中，所有操作在最坏情况下所需的时间都和树的高度成正比。</strong></em></p>
<p>当二叉查找树是一棵完全二叉树时，树高达到最低。此时复杂度为O(logN)。<br>
平均情况下，随机插入键构造的二叉查找树的平均高度近似于2.99logN。<br>
<em><strong>但是当键按照顺序或者逆序插入时，二叉查找树高度达到最高,h=n，此时复杂度为O(N)。</strong></em></p>
<p>对于最坏的情况我们时不允许的，而平衡二叉查找树就是解决这一问题的。</p>
<hr>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
