<!doctype html>
<html lang="en-us">
  <head>
    <title>加权有向图 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="加权有向图"/>
<meta name="twitter:description" content="加权有向图的数据结构 加权有向图和加权无向图的关系类似于有向图和无向图，给边加了一个方向作为限制。在表示其数据结构时，也能借助加权无向图的几种方式：
  利用邻接矩阵存储。和有向图的邻接矩阵表示一致，只是用边的权值代替布尔值来作为矩阵的元素。
  回顾之前有向图邻接表的实现：将V个顶点用0~V-1代替，用一个大小为V的数组的索引(0~V-1)对应于V个顶点。对于数组的每个元素都存放了一个集合数据类型Bag的引用(Bag用链表实现，可以理解为不支持删除操作的无序链表)，链表的每个结点都只存储了一个顶点和指向下个结点的指针。Bag里每个结点的顶点数据都表示和当前数组索引代表的顶点相邻的顶点。即用两个边的两个顶点确定一条边。 对于加权有向图，可以扩展Bag的链表的结点域，让它存储边的终点(起点即存储这个Bag的数组的索引)和这两个顶点确定的边的权重。
  DirectedEdge对象。与方法2类似，将V个顶点用0~V-1代替，用一个大小为V的数组的索引(0~V-1)对应于V个顶点。对于数组的每个元素都存放了一个集合数据类型Bag的引用。这与邻接表的实现都是一样的。 但是不同的是Bag存放的是新定义的一个类DirectedEdge。而DirectedEdge包括了边的另一个顶点和边的权重。即将方法2扩充的Bag的顶点新封装成一个类存储。 除此之外，在Edge中定义了方法either()/other()用于返回边的两个顶点，定义了比较权重的方法compareTo().(通过实现接口Comparable并实现方法)
  DirectedEdge的实现：
public class DirectedEdge { private final int v; //加权有向边的起点  private final int w; //加权有向边的终点  private final double weight; //边的权重  public DirectedEdge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } public int from() { return v; //返回边的起点  } public int to() { return w; //返回边的终点  } public double weight() { return weight; //返回边的权重  } 加权有向图的实现："/>

    <meta property="og:title" content="加权有向图" />
<meta property="og:description" content="加权有向图的数据结构 加权有向图和加权无向图的关系类似于有向图和无向图，给边加了一个方向作为限制。在表示其数据结构时，也能借助加权无向图的几种方式：
  利用邻接矩阵存储。和有向图的邻接矩阵表示一致，只是用边的权值代替布尔值来作为矩阵的元素。
  回顾之前有向图邻接表的实现：将V个顶点用0~V-1代替，用一个大小为V的数组的索引(0~V-1)对应于V个顶点。对于数组的每个元素都存放了一个集合数据类型Bag的引用(Bag用链表实现，可以理解为不支持删除操作的无序链表)，链表的每个结点都只存储了一个顶点和指向下个结点的指针。Bag里每个结点的顶点数据都表示和当前数组索引代表的顶点相邻的顶点。即用两个边的两个顶点确定一条边。 对于加权有向图，可以扩展Bag的链表的结点域，让它存储边的终点(起点即存储这个Bag的数组的索引)和这两个顶点确定的边的权重。
  DirectedEdge对象。与方法2类似，将V个顶点用0~V-1代替，用一个大小为V的数组的索引(0~V-1)对应于V个顶点。对于数组的每个元素都存放了一个集合数据类型Bag的引用。这与邻接表的实现都是一样的。 但是不同的是Bag存放的是新定义的一个类DirectedEdge。而DirectedEdge包括了边的另一个顶点和边的权重。即将方法2扩充的Bag的顶点新封装成一个类存储。 除此之外，在Edge中定义了方法either()/other()用于返回边的两个顶点，定义了比较权重的方法compareTo().(通过实现接口Comparable并实现方法)
  DirectedEdge的实现：
public class DirectedEdge { private final int v; //加权有向边的起点  private final int w; //加权有向边的终点  private final double weight; //边的权重  public DirectedEdge(int v, int w, double weight) { this.v = v; this.w = w; this.weight = weight; } public int from() { return v; //返回边的起点  } public int to() { return w; //返回边的终点  } public double weight() { return weight; //返回边的权重  } 加权有向图的实现：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE/" />
<meta property="article:published_time" content="2020-11-24T18:41:57+08:00" />
<meta property="article:modified_time" content="2020-11-24T18:41:57+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">加权有向图</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 24, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="加权有向图的数据结构">加权有向图的数据结构</h1>
<p>加权有向图和加权无向图的关系类似于有向图和无向图，给边加了一个方向作为限制。在表示其数据结构时，也能借助加权无向图的几种方式：</p>
<ol>
<li>
<p>利用邻接矩阵存储。和有向图的邻接矩阵表示一致，只是用边的权值代替布尔值来作为矩阵的元素。</p>
</li>
<li>
<p>回顾之前有向图邻接表的实现：将V个顶点用0~V-1代替，用一个大小为V的数组的索引(0~V-1)对应于V个顶点。对于数组的每个元素都存放了一个集合数据类型Bag的引用(Bag用链表实现，可以理解为不支持删除操作的无序链表)，链表的每个结点都只存储了一个顶点和指向下个结点的指针。Bag里每个结点的顶点数据都表示和当前数组索引代表的顶点相邻的顶点。即用两个边的两个顶点确定一条边。 <br>
对于加权有向图，可以扩展Bag的链表的结点域，让它存储边的终点(起点即存储这个Bag的数组的索引)和这两个顶点确定的边的权重。</p>
</li>
<li>
<p>DirectedEdge对象。与方法2类似，将V个顶点用0~V-1代替，用一个大小为V的数组的索引(0~V-1)对应于V个顶点。对于数组的每个元素都存放了一个集合数据类型Bag的引用。这与邻接表的实现都是一样的。  <br>
但是不同的是Bag存放的是新定义的一个类DirectedEdge。而DirectedEdge包括了边的另一个顶点和边的权重。即将方法2扩充的Bag的顶点新封装成一个类存储。  <br>
除此之外，在Edge中定义了方法either()/other()用于返回边的两个顶点，定义了比较权重的方法compareTo().(通过实现接口Comparable并实现方法)</p>
</li>
</ol>
<p><img src="/chapter4/4.4.1edge-weighted-digraph-representation.png" alt=""></p>
<p>DirectedEdge的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DirectedEdge</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">;</span>    <span style="color:#75715e">//加权有向边的起点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> w<span style="color:#f92672">;</span>    <span style="color:#75715e">//加权有向边的终点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">double</span> weight<span style="color:#f92672">;</span>    <span style="color:#75715e">//边的权重
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DirectedEdge</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> w<span style="color:#f92672">,</span> <span style="color:#66d9ef">double</span> weight<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">w</span> <span style="color:#f92672">=</span> w<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span> <span style="color:#f92672">=</span> weight<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">from</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">;</span>   <span style="color:#75715e">//返回边的起点
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">to</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> w<span style="color:#f92672">;</span>   <span style="color:#75715e">//返回边的终点
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">weight</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> weight<span style="color:#f92672">;</span>  <span style="color:#75715e">//返回边的权重
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

</code></pre></div><p>加权有向图的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EdgeWeightedDigraph</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> V<span style="color:#f92672">;</span>                <span style="color:#75715e">// 顶点数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> E<span style="color:#f92672">;</span>                      <span style="color:#75715e">// 边数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Bag<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;[]</span> adj<span style="color:#f92672">;</span>    <span style="color:#75715e">// 存储边的数据结构Bag
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> indegree<span style="color:#f92672">;</span>             <span style="color:#75715e">// indegree[v]代表顶点v的入度
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">EdgeWeightedDigraph</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> V<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//V个顶点 0条边的构造方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">V</span> <span style="color:#f92672">=</span> V<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">E</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">indegree</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
        adj <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Bag<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;[])</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span>
            adj<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">EdgeWeightedDigraph</span><span style="color:#f92672">(</span>Scanner in<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//通过输入构造加权有向图的构造方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">V</span> <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
        indegree <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
        adj <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Bag<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;[])</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            adj<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;();</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">int</span> E <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> E<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">double</span> weight <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextDouble</span><span style="color:#f92672">();</span>
            addEdge<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> w<span style="color:#f92672">,</span> weight<span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">EdgeWeightedDigraph</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//通过已有的加权有向图构造的方法
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">E</span> <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">E</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">indegree</span><span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">indegree</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// reverse so that adjacency list is in same order as original
</span><span style="color:#75715e"></span>            Stack<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> reverse <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                reverse<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> reverse<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                adj<span style="color:#f92672">[</span>v<span style="color:#f92672">].</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>与加权有向图相关的一些常用的方法：</p>
<ul>
<li>加入一条边</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">();</span>   <span style="color:#75715e">//v为起点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>     <span style="color:#75715e">//e为终点
</span><span style="color:#75715e"></span>    adj<span style="color:#f92672">[</span>v<span style="color:#f92672">].</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>  <span style="color:#75715e">//插入起点的边的Bag集合中
</span><span style="color:#75715e"></span>    indegree<span style="color:#f92672">[</span>w<span style="color:#f92672">]++;</span>
    E<span style="color:#f92672">++;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>返回顶点v出发的有向边</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> adj<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>      <span style="color:#75715e">//直接返回Bag集合
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><hr>
<h1 id="最短路径的引入">最短路径的引入</h1>
<p>加权有向图中最重要的一个问题就是关于 <em><strong>最短路径</strong></em> 的研究。</p>
<p>最短路径问题：找到从一个顶点到达另一个顶点的权重最小的有向路径。 <br>
单点最短路径：给定一幅加权有向图和一个起点s，从s到给定的目的顶点v是否存在一条有向路径？如果有，给出这条路径。</p>
<p>对于加权有向图的最短路径问题，有几种著名的算法，但是适用方法不同：</p>
<ul>
<li>Dijkstra算法适用于 <em><strong>权重非负</strong></em> 的最短路径问题。</li>
<li>快速解法适用于 <em><strong>无环加权图</strong></em> 中解决最短路径问题，<em><strong>边的权值甚至可以是负数</strong></em> 。</li>
<li>Bellman-Ford算法适用于一般情况，其中图可以含有环，边的权重也可以是负数。</li>
</ul>
<p>几个最短路径的例子：</p>
<ul>
<li>在A到B的地图中，顶点代表交叉路口，边代表公路。</li>
<li>在任务调度中，顶点代表任务，边代表优先级限制。</li>
<li>在套汇中，顶点代表货币，边代表汇率。</li>
</ul>
<h2 id="注意点">注意点</h2>
<ul>
<li>
<p>权重不一定代表距离。还可能代表成本、时间等。</p>
</li>
<li>
<p>并不是所有顶点都可以达的。有向图存在可达性的问题，加权有向图当然也有。对于t不是从s可达的，那么就不存在最短路径问题。(假设例子中都是可达的)。</p>
</li>
<li>
<p>可能存在负权重的情况。对于有些算法不可用。</p>
</li>
<li>
<p>通常忽略构成环的零权重边。</p>
</li>
<li>
<p>最短路径不一定是唯一的。可能有多条总权重一样的路径，只需要找出一条即可。</p>
</li>
</ul>
<h2 id="最短路径树">最短路径树</h2>
<p>定义：给定一幅加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一幅子图。包含s和从s可达的所有顶点。</p>
<p>我们的问题是单点最短路径，而最短路径树可以将起点s可达的所有顶点的最短路径都显示出来。</p>
<hr>
<h1 id="理论基础">理论基础</h1>
<h2 id="额外的数据结构">额外的数据结构</h2>
<ul>
<li>
<p>为了保存路径，则和之前一样需要一个edgeTo[]数组来保存上一个点。即edgeTo[v]的值s-&gt;v的最短路径上的最后一条边。</p>
</li>
<li>
<p>为了保存每条最短路径的权重，需要一个有顶点索引的数组distTo[]。即distTo[v]为从s到v的已知最短路径的长度。(约定起点s的distTo[s]==0，任意不可达的顶点为无限大)</p>
</li>
</ul>
<p><img src="/chapter4/4.4.2spt.png" alt=""></p>
<h2 id="基本的方法">基本的方法</h2>
<ul>
<li>边的松弛  <br>
若对边e进行放松导致distTo[e.to()]和edgeTo[e.to()]发生改变，则称e的放松是成功的，否则成为失败。  <br>
假设起点s直接和顶点x可达，且边的权重为w1.而与起点s可达的另一顶点y也可达x，s-&gt;y的权重为w2，y-&gt;x的权重为w3，且w1&gt;w2+w3，那么就需要对s-&gt;x的最短路径进行更改(即放松边y-&gt;x)。</li>
</ul>
<p><img src="/chapter4/4.4.3relaxation-edge.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> 
        <span style="color:#f92672">{</span>
            distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
            edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>顶点的松弛
对顶点v的松弛即放松由v指出的所有的边。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">:</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span>
            <span style="color:#f92672">{</span>
                distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="理论依据">理论依据</h2>
<ul>
<li>最优性条件  <br>
给定一幅加权有向图G，s为起点，对于s可达的所有v。当且仅当对于v到w的任意一条边e，这些值都满足distTo[w] &lt;= distTo[v] + e.weight()时(即不存在有效的放松边)，它们是最短路径的长度。</li>
</ul>
<p>证明：必要条件(最短路径=&gt;不等式成立)   <br>
假设distTo[w]是从s到w的最短路径。如果对于某条v到w的边e有distTo[w] &gt; distTo[v] + e.weight()，那么从s-&gt;w(经过v)且经过e的路径的长度必然小于distTo[w]，即distTo[w]不是s到w的最短路径长度。矛盾。所以最优性条件是必要的。<br>
充分性(不等式成立=&gt;最短路径)  <br>
假设w是从s可达的且s=v0-&gt;v1-&gt;&hellip;-&gt;vk=w是从s到w的最短路径，且权重为Weight。对于1到k之间的i，令ei表示边vi-1到vi的边则满足</p>
<pre><code>distTo[w]=distTo[vk]&lt;=distTo[vk-1]+ek.weight()    
又有distTo[vk-1]&lt;=distTo[vk-2]+ek-1.weight() 
         ....
distTo[v2]&lt;=distTo[v1]+e2.weight()
distTo[v1]&lt;=distTo[s]+e1.weight(); 
</code></pre>
<p>综合不等式并且distTo[s]==0;得到distTo[w]&lt;=e1.weight()+e2.weight()+&hellip;+ek.weight()=Weight.  <br>
所以Weigth&lt;=distTo[w]&lt;=Weight，等号必然成立。</p>
<h2 id="通用最短路径算法">通用最短路径算法</h2>
<p>设s为起点，将distTo[s]初始化为0，其他都为无穷大。循环执行“放松G的任意边，直到不存在(放松)有效边”即可得到最短路径。</p>
<p>证明：放松边v-&gt;w必然会将distTo[w]的值设为s到w的某条路径的长度。对于s可达的任意顶点w，只要distTo[w]任然是无穷大，那么到达w的最短路径上的某条边肯定任然是有效的(可以放松成功的).对于已经找到最短路径的任意顶点v，在计算过程中distTo[v]的值必然是递减的。当不存在有效边(可以放松成功的边)时，就得到了最短路径。</p>
<ul>
<li><em><strong>通用算法一定可以找到最短路径，但是它对于边的放松的顺序是没有规定的。</strong></em></li>
<li><em><strong>而改进的几种算法，要证明它们都能找到最短路径，只需要证明它们都会放松所有的边直到所有边都失效即可。</strong></em></li>
</ul>
<p>自己利用队列实现的一种通用算法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CommonSP</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>          
    <span style="color:#66d9ef">private</span> DirectedEdge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>   

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CommonSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>

        <span style="color:#75715e">//起点的distTo[s]设置为0  其他都是无穷大
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>    
        
        Queue<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;();</span>
        <span style="color:#75715e">//重新用一个队列装边是因为DiredtedEdge中edges方法返回的是一个迭代器
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//不能用作下面循环的判断条件--q.isempty()
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">:</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">edges</span><span style="color:#f92672">())</span>
        <span style="color:#f92672">{</span>
            q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">//当队列不空 即还有边未被放松时就继续
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(!</span>q<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span>
        <span style="color:#f92672">{</span>
            DirectedEdge e <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">dequeue</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> v<span style="color:#f92672">=</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> w<span style="color:#f92672">=</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>

            <span style="color:#75715e">//只对已经从起点有路径到达的顶点进行放松，找到从起点到它的更短的路径
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//若顶点不能从起点到达  那么放松一定是失败的
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]==</span>Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span> <span style="color:#f92672">&amp;&amp;</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]==</span>Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">)</span>
            <span style="color:#f92672">{</span>
                q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">else</span>
            <span style="color:#f92672">{</span>
                relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>

<span style="color:#75715e">/*
</span><span style="color:#75715e">这种通用算法的复杂度主要和边放松的顺序有关 它只有在某个顶点已经有路径到达的时候才对某条边进行放松。     
</span><span style="color:#75715e">可是一般情况下不能保证从起点出发的每条边的终点都已经从起点有路径了
</span><span style="color:#75715e">这样的话就需要重新把他放到队列中  等待下一次的放松
</span><span style="color:#75715e">*/</span>
</code></pre></div><hr>
<h1 id="dijkstra算法">Dijkstra算法</h1>
<p>回顾加权无向图中最小生成树的Prim算法：利用优先队列MinPQ存储所有的横切边，每次都向最小生成树中添加一条新的边(连接树和非树顶点的权重最小的边)，并将新加入的顶点的边都加入MinPQ。</p>
<p>Dijkstra算法类似：首先将distTo[s]初始化为0，distTo[]中其他元素初始化为正无穷。然后将distTo[]最小的非树(最短路径树)顶点加入树中并放松(放松由它指出的所有的边)。循环上述操作，直到所有顶点都在树中或者所有非树顶点的distTo[]值均为无穷大(不可达)。</p>
<p>为了快速找到distTo[]最小的非树顶点，也需要用一个优先队列MinPQ。而索引优先队列IndexMinPQ可以将索引和键(优先级)关联起来，关联的值就是distTo[]。</p>
<p><img src="/chapter4/4.4.4.jpg" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DijkstraSP</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>          <span style="color:#75715e">// distTo[v]表示s-&gt;v的最短路径的权重
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> DirectedEdge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>    <span style="color:#75715e">// edgeTo[v]表示最短路径的最后一个顶点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> IndexMinPQ<span style="color:#f92672">&lt;</span>Double<span style="color:#f92672">&gt;</span> pq<span style="color:#f92672">;</span>    <span style="color:#75715e">// 优先队列 用于返回distTo最短的
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DijkstraSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>    
        <span style="color:#75715e">//将distTo[s]初始化为0，distTo[]中其他元素初始化为正无穷
</span><span style="color:#75715e"></span>
        pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> IndexMinPQ<span style="color:#f92672">&lt;</span>Double<span style="color:#f92672">&gt;(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">());</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]);</span>    <span style="color:#75715e">//用起点初始化pq
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">delMin</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
                relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// relax edge e and update pq if changed
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
            edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
            <span style="color:#75715e">//若w已经在队列中 则改变值即可
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//否则需要将新的顶点加入其中
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>w<span style="color:#f92672">))</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">decreaseKey</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
            <span style="color:#66d9ef">else</span>                pq<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">distTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasPathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>hasPathTo<span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">//一样的用栈将路径调正
</span><span style="color:#75715e"></span>        Stack<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">()])</span> <span style="color:#f92672">{</span>
            path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> path<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>Dijkstra与Prim的即时实现和相似，只不过Prim的即时实现是每次添加 <em><strong>离树最近</strong></em> 的非树顶点；而Dijkstra算法则是每次添加 <em><strong>离起点最近</strong></em> 的非树顶点。它们都可以不用marked[]数组，因为!marked[w]等价于distTo[w]为无穷大。</p>
<p>同样的，根据Prim的延迟实现也可以完成Dijkstra的延迟实现。</p>
<ul>
<li>复杂度：在一幅含有V个顶点和E条边的加权有向图中，使用Dijkstra算法计算根结点为给定起点的最短路径树所需空间与V成正比，时间与ElogV成正比。  <br>
（MinPQ存储V个顶点；E条边都要relax()&ndash;ElogV）</li>
</ul>
<h2 id="变种">变种</h2>
<ul>
<li>
<p>给定一幅加权无向图和一个起点s，是否存在一条从s到给定的顶点v的路径？如果有，找出最短的那条。  <br>
对于加权无向图，可以创建一幅由相同顶点构成的加权有向图，即把无向图的一条边看作是有向图的两条顶点相同，方向相反的边。这样就可以使用Dijkstra算法一样解决。</p>
</li>
<li>
<p>给定两点的最短路径。给定一幅加权有向图以及一个起点s和一个终点t，找到从s到t的最短路径。  <br>
可以控制循环结束的条件，在优先队列中取到t之后停止。</p>
</li>
<li>
<p>任意顶点对之间的最短路径。给定一幅加权有向图，给定一个起点s和t一个终点t，是否存在一条从s到t的路径？如果有，找出最短的那条。  <br>
为了得到任意顶点对之间的最短路径，需要对每个顶点都使用Dijkstra算法，每个顶点都作为一个根结点得到相应的最短路径树。那么所需要的时间空间都是O(EVlogV).</p>
</li>
</ul>
<hr>
<h1 id="无环加权有向图的最短路径算法">无环加权有向图的最短路径算法</h1>
<p>Dijkstra算法适用于非负权值的有向图。而有一种算法适用于 <em><strong>无环的</strong></em> 加权有向图的最短路径求解。  <br>
并且它具有以下性质：</p>
<ul>
<li>能够在 <em><strong>线性时间</strong></em> 解决单点最短路径问题。</li>
<li>能够处理 <em><strong>负权重</strong></em> 的边。</li>
</ul>
<p>由通用最短路径算法可以知道，只要将所有的边都进行放松就一定能够得到以起点为根的包括所有顶点的最短路径树。Dijkstrra算法规定的边的放松顺序是将距离起点最近的某个顶点放松，然后将其指出的边都加入优先队列。</p>
<p>若在一幅不含有环的有向图中，我们完全可以将有向图先进行拓扑排序，然后按照排序的方式对顶点进行放松。</p>
<p>具体做法：首先将distTo[s]初始化为0，其他初始化为无穷大，然后一个个按照拓扑排序的顺序放松所有的顶点。      <br>
(不需要使用marked[]，因为按照拓扑顺序处理不可能遇到已经被放松过的顶点)</p>
<p><img src="/chapter4/4.4.7.jpg" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AcyclicSP</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>        
    <span style="color:#66d9ef">private</span> DirectedEdge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>   
    <span style="color:#75715e">//利用拓扑排序进行放松  不需要一个优先队列来记载里起点最短的路径
</span><span style="color:#75715e"></span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AcyclicSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>

        Topological topological <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Topological<span style="color:#f92672">(</span>G<span style="color:#f92672">);</span>
        <span style="color:#75715e">//判断该加权有向图是否含有环 含有环的有向图不存在拓扑排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>topological<span style="color:#f92672">.</span><span style="color:#a6e22e">hasOrder</span><span style="color:#f92672">())</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Digraph is not acyclic.&#34;</span><span style="color:#f92672">);</span>

        <span style="color:#75715e">//按照拓扑排序对顶点进行放松
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> topological<span style="color:#f92672">.</span><span style="color:#a6e22e">order</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
                relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">//放松边e
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">from</span><span style="color:#f92672">(),</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
            edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>若按照拓扑排序进行放松，就能在O(E+V)的时间内解决无环加权有向图的单点最短路径问题。  <br>
(有向图的拓扑排序复杂度为O(E+V),而第二次对边放松时只会对每条边放松一次。所以总的复杂度为O(E+V)) <br>
已知某加权有向图是 <em><strong>无环图</strong></em>，这个方法是最好的。并且这个方法适用于权重是负值的情况。</p>
<h2 id="比较dijkstra算法和无环加权有向图的最短路径算法的区别">比较Dijkstra算法和无环加权有向图的最短路径算法的区别</h2>
<pre><code>* Dj算法比无环加权有向图的最短路径算法复杂度高主要高在了Dj算法需要对优先队列进行操作。
* Dj算法的放松按照最短路径的权重顺序被放松，而无环算法按照有向图的拓扑排序放松。
* Dj算法适用于边的权重非负的情况，无环算法适用于该加权有向图没有环。
</code></pre>
<h2 id="变种1">变种1</h2>
<p><strong>无环</strong>加权有向图的单点<strong>最长路径</strong>：对于一幅无环的，边的权值可正可负的加权有向图，回答是否存在一条从s到给定的v的路径，如果有，请找出最长的那条。</p>
<p>想法：复制原始无环加权有向图得到一个副本并将副本中所有的边的权值取相反数。那么副本的最短路径问题就变成了原图的最长路径问题。(绝对值最大的负数也是最小的数)</p>
<p>算法的实现和AcyclicSP没什么区别，只是初始将正无穷大改为负无穷大，并将放松e的条件的不等式改变方向即可。</p>
<h2 id="变种2">变种2</h2>
<p><strong>优先级限制下的并行</strong>任务调度:给定一组任务以及每个任务所需的时间，以及一组关于任务完成的先后次序的优先级限制。如何在若干(数量无限制)相同的处理器上安排任务并在最短的时间内完成？</p>
<p>与&quot;有向图&quot;中的调度问题不同在于，有向图中的只有一个处理器，只要将任务按照拓扑排序进行，完成任务的总耗时就是所有任务所需要的时间。  <br>
而这里的条件给定足够的处理器，只有优先级的限制。</p>
<p>解决这类方法，需要用一种叫做 <em><strong>关键路径</strong></em> 的算法。这个算法和无环加权有向图中的最长路径问题等价。   <br>
关键路径：如果将一系列任务的长度定义为完成所有任务的最早可能时间，那么最长的任务序列就是问题的关键路径。</p>
<p><img src="/chapter4/4.4.11.jpg" alt=""></p>
<p><img src="/chapter4/4.4.10scheduling-reduction.png" alt=""></p>
<p>任务调度问题的关键路径方法将问题归约为寻找 <em><strong>无环加权有向图的最长路径问题</strong></em>。<br>
且所需时间为线性级别。</p>
<h2 id="变种3">变种3</h2>
<p>相对最后期限限制下的并行调度问题。   <br>
这个问题可以归约为加权有向图中的最短路径问题，但是可能包括环和负权重的边。因此不适用于Dijkstra算法和无环加权有向图的最短路径算法。</p>
<hr>
<h1 id="一般加权有向图中的最短路径算法">一般加权有向图中的最短路径算法</h1>
<p>Dijkstra算法和无环加权有向图的最短路径算法都有局限性。而现在考虑一个普通情况，允许加权有向图有环并且有负权重的边。</p>
<h2 id="负权重的环">负权重的环</h2>
<p>如果该图中含有一个权重为负的环，那么对于在该负权重环上的所有顶点寻找最短路径就失去了意义。</p>
<h2 id="约定">约定</h2>
<ul>
<li>对于起点不可达的顶点，最短路径为正无穷。</li>
<li>对于从起点可达但是路径上的某个顶点属于一个负权重环，最短路径为负无穷。</li>
<li>对于其他的顶点，计算最短路径的权重(即一棵最短路径树)。</li>
</ul>
<h2 id="bellman-ford算法">Bellman-Ford算法</h2>
<p>在任意含有V个顶点的加权有向图中给定起点s，从s无法达到任何负权重环。那么将distTo[s]初始化为0，其他初始化为无穷大，以任意顺序放松有向图的所有边并重复V轮就可以得到s到所有可达顶点的最短路径树。  <br>
这个方法和上面所说的通用最短路径算法类型，都只要保证每条边都被放松过了就能完成。而通过数学证明可以保证这个方法执行V轮就可放松所有边。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> pass<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>pass<span style="color:#f92672">&lt;</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span>pass<span style="color:#f92672">++)</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>v<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>v<span style="color:#f92672">&lt;</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span>v<span style="color:#f92672">++)</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>DirectedEdge e<span style="color:#f92672">:</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span>
            relax<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
<span style="color:#75715e">//所需时间O(EV)，所需空间O(V).
</span></code></pre></div><h2 id="基于队列的bellman-ford算法">基于队列的Bellman-Ford算法</h2>
<p>在V轮放松中，只有上一轮distTo[]的值发生变化的顶点指出的边才能改变其他distTo[]元素的值。那么我们可以用一条FIFO的队列记录这样的顶点。</p>
<p><img src="/chapter4/4.4.9.jpg" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BellmanFordSP</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>             
    <span style="color:#66d9ef">private</span> DirectedEdge<span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>        
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> onQueue<span style="color:#f92672">;</span>    <span style="color:#75715e">// onQueue[v]代表v是否在队列中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> queue<span style="color:#f92672">;</span>          <span style="color:#75715e">// 队列存放正在放松的顶点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> cost<span style="color:#f92672">;</span>                      <span style="color:#75715e">// relax()调用的次数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Iterable<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> cycle<span style="color:#f92672">;</span>  <span style="color:#75715e">// edgeTo[]中是否含有负权重环
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BellmanFordSP</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        distTo  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedEdge<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        onQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Double<span style="color:#f92672">.</span><span style="color:#a6e22e">POSITIVE_INFINITY</span><span style="color:#f92672">;</span>
        distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">0</span><span style="color:#f92672">;</span>

        queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        queue<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        onQueue<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>  <span style="color:#75715e">//用起点来初始化
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>queue<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>hasNegativeCycle<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">dequeue</span><span style="color:#f92672">();</span>
            onQueue<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            relax<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">relax</span><span style="color:#f92672">(</span>EdgeWeightedDigraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>DirectedEdge e <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">to</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">())</span> 
            <span style="color:#f92672">{</span>
                distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">weight</span><span style="color:#f92672">();</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>onQueue<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> 
                <span style="color:#f92672">{</span>
                    queue<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                    onQueue<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(++</span>cost <span style="color:#f92672">%</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                findNegativeCycle<span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hasNegativeCycle<span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>  <span style="color:#75715e">// 找是否有负权重环
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasNegativeCycle</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> cycle <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>DirectedEdge<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">negativeCycle</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> cycle<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//找对于的有向图是否有环
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">findNegativeCycle</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> V <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        EdgeWeightedDigraph spt <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> EdgeWeightedDigraph<span style="color:#f92672">(</span>V<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>edgeTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                spt<span style="color:#f92672">.</span><span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span>edgeTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]);</span>

        EdgeWeightedDirectedCycle finder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> EdgeWeightedDirectedCycle<span style="color:#f92672">(</span>spt<span style="color:#f92672">);</span>
        cycle <span style="color:#f92672">=</span> finder<span style="color:#f92672">.</span><span style="color:#a6e22e">cycle</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>所需时间为O(EV)，所需空间为O(V)。</p>
<h2 id="负权重的边">负权重的边</h2>
<p>对于负权重边，可能在一轮放松中使得原来已经被放松过的顶点的distTo[]的值发生了变化，那么就还需要放松。如下图的顶点4：顶点4首先在顶点0被放松后加入了队列进行放松。然后再6被放松后由于6-&gt;4的权重为负，且0-&gt;..-&gt;6-&gt;4的权重比0-&gt;4的权重小，所有需要对4进行再次放松。这样由4指出的顶点的distTo[]也还可能改变。</p>
<p><img src="/chapter4/4.4.8.jpg" alt=""></p>
<h2 id="负权重环的检测">负权重环的检测</h2>
<p>这样看来，是否负权重环的检测就简单了：由于负权重环的存在，每轮的放松都会使得负权重环上的顶点的distTo[]发生改变，即使进行了V轮后，存储distTo[]发生改变的队列(需要放松的顶点)任然不为空。因为对于负权重环上的顶点，每轮distTo[]都会减小且没有下界。</p>
<p>如果V轮后任然还有顶点在队列中，就说明含有负权重环。此时问题退化为了检测有向图的环。那么只需要利用edgeTo[]构造一个有向图，并且用检测有向图的方法(深度优先搜索算法)检测有向图是否有环。并且可以返回负权重环的所有的顶点。</p>
<hr>
<h1 id="简单总结">简单总结</h1>
<p><img src="/chapter4/4.4.12.jpg" alt=""></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
