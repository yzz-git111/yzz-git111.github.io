<!doctype html>
<html lang="en-us">
  <head>
    <title>哈希表 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="哈希表"/>
<meta name="twitter:description" content="概述 散列表即通过运算(散列函数)将键转化为数组的索引来访问数组中的键值对。
散列表快速的原因在于将数组的索引和键建立了一一对应的关系。只要给出键，就能计算出索引(数组的下标)，计算出了索引，就可以直接通过下标访问数组的那个键值对。
散列表的实现通常分为两步:
 用散列函数将被查找的键转化为一个数组的一个索引。 当多个键散列到相同的索引值时，就需要处理冲突碰撞  散列表在 时间 和 空间上做出了权衡。
当空间没有限制时，假设一个足够大的数组，我们可以直接将键作为数组的索引(将数组的第键个位置放这个键值对)，那么对于给定的键key，可以直接用a[key]直接找到值，复杂度达到了O(1)。但是如果键的索引大于100，那么数组大小也需要上百，且浪费其中绝大部分。
当时间没有限制时，可以使用无序数组遍历查找，查找和插入的实现都很简单。
一个简单的散列表实例：键值对&lt;901,a&gt;&lt;904,b&gt;&lt;902,d&gt;&lt;903,s&gt;&lt;905,e&gt; 可以将键都减去900，得到键值对&lt;1,a&gt;&lt;2,d&gt;&lt;3,s&gt;&lt;4,b&gt;&lt;5,e&gt; 这时可以直接按顺序放到一个大小为5的数组中。而减去900就相当于一个简单的散列函数，key-900.
散列表的查找和插入在均摊后拥有 常数级别O(1) 的复杂度，是最为理想的一种符号表。
散列函数 为了将键转化为数组的索引，我们需要一个方法，即散列函数。
理想情况下散列函数能够满足：对于任意键，大小为M的数组的0到M-1之间的每个整数都有 等可能 对应。
最常见的散列函数就是 除留余数法
选取大小为素数M的数组，
当键是正整数时，对于任意整数k，计算 k mod M ，使得键能够均匀的分布在0~M-1的范围内。
当键是0到1的浮点数时，可以将它乘以M并四舍五入到0~M-1之间的索引值。但是这样会使得键的高位权重较大。改进的方法就是将键的表示转化为二进制后再除留余数法。
当键是字符，可以当作一个整数。对于字符串，可以给定一个很小的常数，然后计算所有字符的除留余数的值。
对于Java的是实现，由于Java都是继承了类Object，都有一个默认的方法hashcode()。
对于任意对象x，都可以调用x.hashcode()并认为有均等的机会得到一个2^32个不同整数中的任意一个。
对于我们自己实现的数据类型的散列函数，需要重写hashcode()和equals()两个方法。
因为我们需要的是数组的索引而不是32位的整数，实现中会将默认的hashcode()方法和除留余数法结合起来产生一个0~M-1的整数：
private int hash(Key x) { return (x.hashCode() &amp; 0x7ffffff) % M; } /*这段代码会将符号位屏蔽（将32位整数转化为一个31位的非负整数） 且一般会将数组的大小M取为素数以充分利用所有位*/ 均匀散列假设： 我们使用散列函数能够均匀并独立地将所有的键散布于0到M-1中
 碰撞处理 选取好散列函数之后，就需要处理多个键的散列值相同(碰撞)的情况。且在键的数目很大的情况下，碰撞发生的概率也会很大。
对于碰撞处理通常分为 基于拉链法的散列表 和 基于开放地址的散列表。
 1.基于拉链法的散列表 基于拉链表的基本思想是：将大小为M的数组中的每个元素都指向一条链表，每个链表存储不同的键但是散列值都相同(都是数组的该元素的索引)的键值对。
当M足够大时，可以使得所有链表都尽可能的短(理想情况只存储一个键值对，即没有碰撞情况)。
查找时：首先根据键计算散列值，找到与散列值相同的数组的索引的位置存放的链表。然后在这个链表中顺序查找相应的键。 插入时：首先计算散列值。然后再在以散列值为索引的数组元素的链表中插入新的键值对。
拉链法的实现可以使用原始的链表，也可以为数组的M个元素分别构建之前实现过的符号表(基于二分查找的数组实现的符号表，基于二叉查找树的符号表，基于红黑树的符号表等)来保存相同的散列值的键。
 构造方法：调用了之前实现的基于链表顺序查询的符号表SequentialSearchST 注意：在创建st[]时要进行类型转化st = (SequentialSearchST&lt;Key, Value&gt;[]) new SequentialSearchST[m]; 因为Java不允许泛型的数组。  public class SeparateChainingHashST&lt;Key, Value&gt; { private static final int INIT_CAPACITY = 4; //定义一个常量，设为默认的散列表的大小  private int n; //键值对的数目  private int m; //散列表数组大小  private SequentialSearchST&lt;Key, Value&gt;[] st; //存放链表对象的数组  //通过this调用另一个重载的构造方法  public SeparateChainingHashST() { this(INIT_CAPACITY); //默认的散列表大小为INIT_CAPACITY  } public SeparateChainingHashST(int m) { this."/>

    <meta property="og:title" content="哈希表" />
<meta property="og:description" content="概述 散列表即通过运算(散列函数)将键转化为数组的索引来访问数组中的键值对。
散列表快速的原因在于将数组的索引和键建立了一一对应的关系。只要给出键，就能计算出索引(数组的下标)，计算出了索引，就可以直接通过下标访问数组的那个键值对。
散列表的实现通常分为两步:
 用散列函数将被查找的键转化为一个数组的一个索引。 当多个键散列到相同的索引值时，就需要处理冲突碰撞  散列表在 时间 和 空间上做出了权衡。
当空间没有限制时，假设一个足够大的数组，我们可以直接将键作为数组的索引(将数组的第键个位置放这个键值对)，那么对于给定的键key，可以直接用a[key]直接找到值，复杂度达到了O(1)。但是如果键的索引大于100，那么数组大小也需要上百，且浪费其中绝大部分。
当时间没有限制时，可以使用无序数组遍历查找，查找和插入的实现都很简单。
一个简单的散列表实例：键值对&lt;901,a&gt;&lt;904,b&gt;&lt;902,d&gt;&lt;903,s&gt;&lt;905,e&gt; 可以将键都减去900，得到键值对&lt;1,a&gt;&lt;2,d&gt;&lt;3,s&gt;&lt;4,b&gt;&lt;5,e&gt; 这时可以直接按顺序放到一个大小为5的数组中。而减去900就相当于一个简单的散列函数，key-900.
散列表的查找和插入在均摊后拥有 常数级别O(1) 的复杂度，是最为理想的一种符号表。
散列函数 为了将键转化为数组的索引，我们需要一个方法，即散列函数。
理想情况下散列函数能够满足：对于任意键，大小为M的数组的0到M-1之间的每个整数都有 等可能 对应。
最常见的散列函数就是 除留余数法
选取大小为素数M的数组，
当键是正整数时，对于任意整数k，计算 k mod M ，使得键能够均匀的分布在0~M-1的范围内。
当键是0到1的浮点数时，可以将它乘以M并四舍五入到0~M-1之间的索引值。但是这样会使得键的高位权重较大。改进的方法就是将键的表示转化为二进制后再除留余数法。
当键是字符，可以当作一个整数。对于字符串，可以给定一个很小的常数，然后计算所有字符的除留余数的值。
对于Java的是实现，由于Java都是继承了类Object，都有一个默认的方法hashcode()。
对于任意对象x，都可以调用x.hashcode()并认为有均等的机会得到一个2^32个不同整数中的任意一个。
对于我们自己实现的数据类型的散列函数，需要重写hashcode()和equals()两个方法。
因为我们需要的是数组的索引而不是32位的整数，实现中会将默认的hashcode()方法和除留余数法结合起来产生一个0~M-1的整数：
private int hash(Key x) { return (x.hashCode() &amp; 0x7ffffff) % M; } /*这段代码会将符号位屏蔽（将32位整数转化为一个31位的非负整数） 且一般会将数组的大小M取为素数以充分利用所有位*/ 均匀散列假设： 我们使用散列函数能够均匀并独立地将所有的键散布于0到M-1中
 碰撞处理 选取好散列函数之后，就需要处理多个键的散列值相同(碰撞)的情况。且在键的数目很大的情况下，碰撞发生的概率也会很大。
对于碰撞处理通常分为 基于拉链法的散列表 和 基于开放地址的散列表。
 1.基于拉链法的散列表 基于拉链表的基本思想是：将大小为M的数组中的每个元素都指向一条链表，每个链表存储不同的键但是散列值都相同(都是数组的该元素的索引)的键值对。
当M足够大时，可以使得所有链表都尽可能的短(理想情况只存储一个键值对，即没有碰撞情况)。
查找时：首先根据键计算散列值，找到与散列值相同的数组的索引的位置存放的链表。然后在这个链表中顺序查找相应的键。 插入时：首先计算散列值。然后再在以散列值为索引的数组元素的链表中插入新的键值对。
拉链法的实现可以使用原始的链表，也可以为数组的M个元素分别构建之前实现过的符号表(基于二分查找的数组实现的符号表，基于二叉查找树的符号表，基于红黑树的符号表等)来保存相同的散列值的键。
 构造方法：调用了之前实现的基于链表顺序查询的符号表SequentialSearchST 注意：在创建st[]时要进行类型转化st = (SequentialSearchST&lt;Key, Value&gt;[]) new SequentialSearchST[m]; 因为Java不允许泛型的数组。  public class SeparateChainingHashST&lt;Key, Value&gt; { private static final int INIT_CAPACITY = 4; //定义一个常量，设为默认的散列表的大小  private int n; //键值对的数目  private int m; //散列表数组大小  private SequentialSearchST&lt;Key, Value&gt;[] st; //存放链表对象的数组  //通过this调用另一个重载的构造方法  public SeparateChainingHashST() { this(INIT_CAPACITY); //默认的散列表大小为INIT_CAPACITY  } public SeparateChainingHashST(int m) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E5%93%88%E5%B8%8C%E8%A1%A8/" />
<meta property="article:published_time" content="2020-11-07T21:21:31+08:00" />
<meta property="article:modified_time" content="2020-11-07T21:21:31+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">哈希表</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 7, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="概述">概述</h1>
<p>散列表即通过运算(散列函数)将键转化为数组的索引来访问数组中的键值对。</p>
<p><em>散列表快速的原因在于将数组的索引和键建立了一一对应的关系。只要给出键，就能计算出索引(数组的下标)，计算出了索引，就可以直接通过下标访问数组的那个键值对。</em></p>
<p>散列表的实现通常分为两步:</p>
<ol>
<li><em><strong>用散列函数将被查找的键转化为一个数组的一个索引。</strong></em></li>
<li><em><strong>当多个键散列到相同的索引值时，就需要处理冲突碰撞</strong></em></li>
</ol>
<p>散列表在 时间 和 空间上做出了权衡。<br>
当空间没有限制时，假设一个足够大的数组，我们可以直接将键作为数组的索引(将数组的第键个位置放这个键值对)，那么对于给定的键key，可以直接用a[key]直接找到值，复杂度达到了O(1)。但是如果键的索引大于100，那么数组大小也需要上百，且浪费其中绝大部分。<br>
当时间没有限制时，可以使用无序数组遍历查找，查找和插入的实现都很简单。</p>
<p>一个简单的散列表实例：键值对&lt;901,a&gt;&lt;904,b&gt;&lt;902,d&gt;&lt;903,s&gt;&lt;905,e&gt; <br>
可以将键都减去900，得到键值对&lt;1,a&gt;&lt;2,d&gt;&lt;3,s&gt;&lt;4,b&gt;&lt;5,e&gt; 这时可以直接按顺序放到一个大小为5的数组中。而减去900就相当于一个简单的散列函数，key-900.</p>
<p>散列表的查找和插入在均摊后拥有 <em><strong>常数级别O(1)</strong></em> 的复杂度，是最为理想的一种符号表。</p>
<h1 id="散列函数">散列函数</h1>
<p>为了将键转化为数组的索引，我们需要一个方法，即散列函数。<br>
理想情况下散列函数能够满足：对于任意键，大小为M的数组的0到M-1之间的每个整数都有 <em><strong>等可能</strong></em> 对应。</p>
<p>最常见的散列函数就是 <em><strong>除留余数法</strong></em></p>
<p>选取大小为素数M的数组，<br>
当键是正整数时，对于任意整数k，计算 k mod M ，使得键能够均匀的分布在0~M-1的范围内。<br>
当键是0到1的浮点数时，可以将它乘以M并四舍五入到0~M-1之间的索引值。但是这样会使得键的高位权重较大。改进的方法就是将键的表示转化为二进制后再除留余数法。<br>
当键是字符，可以当作一个整数。对于字符串，可以给定一个很小的常数，然后计算所有字符的除留余数的值。</p>
<p>对于Java的是实现，由于Java都是继承了类Object，都有一个默认的方法hashcode()。<br>
对于任意对象x，都可以调用x.hashcode()并认为有均等的机会得到一个2^32个不同整数中的任意一个。<br>
对于我们自己实现的数据类型的散列函数，需要重写hashcode()和equals()两个方法。</p>
<p>因为我们需要的是数组的索引而不是32位的整数，实现中会将默认的hashcode()方法和除留余数法结合起来产生一个0~M-1的整数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Key x<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;</span> 0x7ffffff<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> M<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">/*这段代码会将符号位屏蔽（将32位整数转化为一个31位的非负整数）
</span><span style="color:#75715e">且一般会将数组的大小M取为素数以充分利用所有位*/</span>

</code></pre></div><p><em><strong>均匀散列假设： 我们使用散列函数能够均匀并独立地将所有的键散布于0到M-1中</strong></em></p>
<hr>
<h1 id="碰撞处理">碰撞处理</h1>
<p>选取好散列函数之后，就需要处理多个键的散列值相同(碰撞)的情况。且在键的数目很大的情况下，碰撞发生的概率也会很大。</p>
<p>对于碰撞处理通常分为 基于拉链法的散列表 和 基于开放地址的散列表。</p>
<hr>
<h2 id="1基于拉链法的散列表">1.基于拉链法的散列表</h2>
<p>基于拉链表的基本思想是：<em><strong>将大小为M的数组中的每个元素都指向一条链表，每个链表存储不同的键但是散列值都相同(都是数组的该元素的索引)的键值对</strong></em>。<br>
当M足够大时，可以使得所有链表都尽可能的短(理想情况只存储一个键值对，即没有碰撞情况)。</p>
<p><em><strong>查找时：首先根据键计算散列值，找到与散列值相同的数组的索引的位置存放的链表。然后在这个链表中顺序查找相应的键。</strong></em>  <br>
<em><strong>插入时：首先计算散列值。然后再在以散列值为索引的数组元素的链表中插入新的键值对。</strong></em></p>
<p>拉链法的实现可以使用原始的链表，也可以为数组的M个元素分别构建之前实现过的符号表(基于二分查找的数组实现的符号表，基于二叉查找树的符号表，基于红黑树的符号表等)来保存相同的散列值的键。</p>
<p><img src="/chapter3/3.4.1separate-chaining.png" alt=""></p>
<ol>
<li>构造方法：调用了之前实现的基于链表顺序查询的符号表SequentialSearchST <br>
注意：在创建st[]时要进行类型转化st = (SequentialSearchST&lt;Key, Value&gt;[]) new SequentialSearchST[m];   <br>
因为Java不允许泛型的数组。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SeparateChainingHashST</span><span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> INIT_CAPACITY <span style="color:#f92672">=</span> 4<span style="color:#f92672">;</span> <span style="color:#75715e">//定义一个常量，设为默认的散列表的大小
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">;</span>         <span style="color:#75715e">//键值对的数目
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> m<span style="color:#f92672">;</span>         <span style="color:#75715e">//散列表数组大小
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> SequentialSearchST<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;[]</span> st<span style="color:#f92672">;</span>  <span style="color:#75715e">//存放链表对象的数组
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">//通过this调用另一个重载的构造方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SeparateChainingHashST</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>INIT_CAPACITY<span style="color:#f92672">);</span>    <span style="color:#75715e">//默认的散列表大小为INIT_CAPACITY
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SeparateChainingHashST</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">m</span> <span style="color:#f92672">=</span> m<span style="color:#f92672">;</span>
        st <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>SequentialSearchST<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;[])</span> <span style="color:#66d9ef">new</span> SequentialSearchST<span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> m<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            st<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SequentialSearchST<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;();</span>
            <span style="color:#75715e">//为每个数组都new一个SequentialSearchST的基于链表的符号表的对象
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><ol start="2">
<li>散列函数</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;</span> 0x7fffffff<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> m<span style="color:#f92672">;</span>   <span style="color:#75715e">//除留余数法
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><ol start="3">
<li>查找</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to get() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> st<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>  <span style="color:#75715e">//调用SequentialSearchST的get方法
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><ol start="4">
<li>插入新的键值对</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;first argument to put() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>val <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        delete<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;=</span> 10<span style="color:#f92672">*</span>m<span style="color:#f92672">)</span> resize<span style="color:#f92672">(</span>2<span style="color:#f92672">*</span>m<span style="color:#f92672">);</span> <span style="color:#75715e">//调整数组大小。
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>key<span style="color:#f92672">))</span> n<span style="color:#f92672">++;</span>
    st<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="5">
<li>删除</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to delete() is null&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>st<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>key<span style="color:#f92672">))</span> n<span style="color:#f92672">--;</span>
    st<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>

    <span style="color:#75715e">// halve table size if average length of list &lt;= 2
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>m <span style="color:#f92672">&gt;</span> INIT_CAPACITY <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">&lt;=</span> 2<span style="color:#f92672">*</span>m<span style="color:#f92672">)</span> resize<span style="color:#f92672">(</span>m<span style="color:#f92672">/</span>2<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em><strong>命题：在均匀散列假设成立的前提下，任意一条链表中的键的数量均在N/M的常数因子范围内的概率无限趋向1.</strong></em></p>
<p>但是在最坏情况下，散列函数不是均匀和独立的，那么查找和插入的成本就可能达到O(N),也就是退化成了链表的线性查找。</p>
<ol start="6">
<li>
<p>分析散列表的大小<br>
当M足够大时，每个链表至多只有一个键值对，虽然这种情况会浪费许多数组的空间，但是可以保证查找很快。当内存紧张的时候，选取尽可能大的数组，也可以提高性能。<br>
所以需要选取一个适当的数组大小M。</p>
</li>
<li>
<p>改进： <br>
对于最坏情况的可能，可以动态的调整链表数组的大小。当有多个键都散列到同一个数组元素时，可以扩大数组的大小M，使得链表的平均长度始终很小，也就避免了退化为线性查找。<br>
扩容后还需要重新将原来的键值对进行散列。</p>
</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> chains<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    SeparateChainingHashST<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;</span> temp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SeparateChainingHashST<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;(</span>chains<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> m<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Key key <span style="color:#f92672">:</span> st<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">keys</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> st<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>key<span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">m</span>  <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">m</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">n</span>  <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">n</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">st</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">st</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><em><strong>性质：再一张含有M条链表和N个键的散列表中，未命中查找和插入所需的比较次数为~N/M</strong></em></p>
<hr>
<h2 id="2基于开放地址的散列表">2.基于开放地址的散列表</h2>
<p>开放地址的思想：用大小M的数组保存N个键值对，且M&gt;N.用数组中多余的空位解决冲突。</p>
<p>而开放地址的最典型最简单的方法叫线性探测法:当发生冲突时(一个键的散列值已经被其他键占用)，直接检查散列表数组下一个位置(计算出的散列值亦即数组索引 加1)。<br>
此时有三种情况：</p>
<ul>
<li>命中，该位置的键和被查找的相同</li>
<li>未命中，该位置没有键</li>
<li>继续查找，该位置的键和被查找的键不同</li>
</ul>
<p>也就是说只有从散列值开始，当找到待查找的键或者找到第一个空的键才结束(这里把空元素作为查找结束的标志)。</p>
<p><img src="/chapter3/3.4.2linear-probing.png" alt=""></p>
<ol>
<li>构造方法<br>
分别用一对数组来对应地存放键值对。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LinearProbingHashST</span><span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">{</span>
    
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> INIT_CAPACITY <span style="color:#f92672">=</span> 4<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> n<span style="color:#f92672">;</span>          
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> m<span style="color:#f92672">;</span>          
    <span style="color:#66d9ef">private</span> Key<span style="color:#f92672">[]</span> keys<span style="color:#f92672">;</span>      <span style="color:#75715e">//存放键的数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Value<span style="color:#f92672">[]</span> vals<span style="color:#f92672">;</span>    <span style="color:#75715e">//存放值的数组
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LinearProbingHashST</span><span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>INIT_CAPACITY<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LinearProbingHashST</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacity<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        m <span style="color:#f92672">=</span> capacity<span style="color:#f92672">;</span>
        n <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        keys <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Key<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>
        vals <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Value<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">[</span>m<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="2">
<li>散列函数</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashTextbook</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;</span> 0x7fffffff<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> m<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">();</span>
    h <span style="color:#f92672">^=</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 20<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 12<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 7<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> h <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>m <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="3">
<li>查找</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to get() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> m<span style="color:#f92672">)</span>   <span style="color:#75715e">//和循环队列类似，用i=(i+1)%m来使得循环查找
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>key<span style="color:#f92672">))</span> 
            <span style="color:#66d9ef">return</span> vals<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="4">
<li>插入</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;first argument to put() is null&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>val <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        delete<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//如果散列因子α大于1/2 就需要扩容
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;=</span> m <span style="color:#f92672">/</span> 2<span style="color:#f92672">)</span> resize<span style="color:#f92672">(</span>2 <span style="color:#f92672">*</span> m<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> m<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>key<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            vals<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">;</span>
    vals<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>
    n<span style="color:#f92672">++;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="5">
<li>删除<br>
直接将键所在的位置置为null是不行的，因为这会引起其他键位置的改变。举一个例子：假设键key1和key2的散列值都是x，由于key1先进行散列，所以数组a<input checked="" disabled="" type="checkbox"> 存放的是key1，key2存放在了其他位置，而现在将key1删除，key2应该要放到x处。   <br>
所以如果删除某个键，就要把这个键往后直到第一个null的所有键都重新进行散列。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to delete() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>contains<span style="color:#f92672">(</span>key<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>

    <span style="color:#75715e">// find position i of key
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]))</span> <span style="color:#f92672">{</span>
        i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> m<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    vals<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

    <span style="color:#75715e">// 重新散列
</span><span style="color:#75715e"></span>    i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> m<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// delete keys[i] an vals[i] and reinsert
</span><span style="color:#75715e"></span>        Key keyToRehash <span style="color:#f92672">=</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        Value valToRehash <span style="color:#f92672">=</span> vals<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        vals<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        n<span style="color:#f92672">--;</span>
        put<span style="color:#f92672">(</span>keyToRehash<span style="color:#f92672">,</span> valToRehash<span style="color:#f92672">);</span>
        i <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">%</span> m<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    n<span style="color:#f92672">--;</span>

    <span style="color:#75715e">//当α小于1/8，就缩小
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">&lt;=</span> m <span style="color:#f92672">/</span> 8<span style="color:#f92672">)</span> resize<span style="color:#f92672">(</span>m <span style="color:#f92672">/</span> 2<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="6">
<li>
<p>分析  <br>
<em><strong>在一张大小为M并含有N=αM个键(α为散列因子)的基于线性探测的散列表，在均匀散列假设前提下，命中查找需要~(1+(1/1-α))/2次探测；未命中需要~(1+(1/1-α)^2)/2次</strong></em> <br>
<em>所以α越大，探测次数越多。当α约为1/2时，命中需要约3/2次，未命中需要约5/2次。</em><br>
当散列表快慢时(α接近1)，探测次数是很大的。当散列表满时，会一直散列。 <br>
最好要保证α取值小于1/2.</p>
</li>
<li>
<p>动态调整数组大小<br>
对于拉链法，调整数组大小可能并不是必要的，但是对于开放地址一定要考虑。<br>
如果不调整的话，考虑一个极端情况：当所有的空位都散列到了，那么再插入一个新的键值对的时候，探测的所有的键都不行，陷入死循环。当α越接近1，冲突发生的可能越大。 <br>
当元素个数很少的时候，可能不会发生冲突，而用一个很大的数组就会浪费很多空间。 <br>
当α在1/2左右时，是较为理想的一个状态。</p>
</li>
</ol>
<p>但是需要注意的一点是：<em><strong>每一次动态调整数组大小都需要将所有键重新进行散列，因为M改变了，相应的散列值也会发生变化。</strong></em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacity<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    LinearProbingHashST<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;</span> temp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinearProbingHashST<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span> Value<span style="color:#f92672">&gt;(</span>capacity<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> m<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            temp<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> vals<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    keys <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">keys</span><span style="color:#f92672">;</span>
    vals <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">vals</span><span style="color:#f92672">;</span>
    m <span style="color:#f92672">=</span> temp<span style="color:#f92672">.</span><span style="color:#a6e22e">m</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ol start="8">
<li>其他方法 <br>
除了最基本的线性探测法，还有二次探测法和再散列法。</li>
</ol>
<hr>
<h1 id="总结分析">总结分析</h1>
<p><em><strong>优点：散列表是空间和时间的一种权衡。通过建立键和数组索引的一个映射关系，平均情况下在常数时间就可以查询</strong></em>。</p>
<p><em><strong>缺点：由于均匀散列的假设，键值对在散列后完全没有顺序可以，对于于顺序相关的操作(rank,select,min,max)散列表都很难实现。</strong></em></p>
<p><em><strong>难点：散列函数的选取</strong></em></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
