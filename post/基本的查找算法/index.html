<!doctype html>
<html lang="en-us">
  <head>
    <title>基本的查找算法 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="基本的查找算法"/>
<meta name="twitter:description" content="根据书中的定义：符号表是一种存储键值对的数据结构。支持插入操作：将一组新的键值对存入表中。和查找操作：根据给定的键得到相对应的值 典型的符号表的应用：查字典时，单词就是键，释义就是值。通过单词来找到意思。 网络搜索时，关键字就是键，网页名称就是值，通过关键字来找到网页。
约定  每个键只对应一个值(而一个值可以对应于多个键)。即索引是唯一的。 键不能为空。 查找成功成为命中，不成功返回null为不命中 采用泛型的设计思想，在具体实现时在规定特定的类型。  最基本的符号表的API： 基于链表实现 符号表作为一种数据结构可以通过最基本的链表来实现。
public class SequentialSearchST&lt;Key,Value&gt; { private Node first; //相当于头结点指针  private class Node { Key key; Value val; Node next; public Node(Key key, Value val, Node next) { this.key=key; this.val=val; this.next=next; } } } 这里给出了链表实现的方法：使用一个内部私有类Node来存放键和值。链表只有一个私有成员first，类型为私有内部类Node，用来指示下一个结点的位置，初始值是null。
/*这是根据键查找值 以及 插入一对新的键值对的方法*/ public Value get(Key key) { for(Node x=first;x!=null;x=x.next) { if(key.equals(x.key)) { return x.val; } } return null; } public void put(Key key,Value val) { for(Node x=first;x!"/>

    <meta property="og:title" content="基本的查找算法" />
<meta property="og:description" content="根据书中的定义：符号表是一种存储键值对的数据结构。支持插入操作：将一组新的键值对存入表中。和查找操作：根据给定的键得到相对应的值 典型的符号表的应用：查字典时，单词就是键，释义就是值。通过单词来找到意思。 网络搜索时，关键字就是键，网页名称就是值，通过关键字来找到网页。
约定  每个键只对应一个值(而一个值可以对应于多个键)。即索引是唯一的。 键不能为空。 查找成功成为命中，不成功返回null为不命中 采用泛型的设计思想，在具体实现时在规定特定的类型。  最基本的符号表的API： 基于链表实现 符号表作为一种数据结构可以通过最基本的链表来实现。
public class SequentialSearchST&lt;Key,Value&gt; { private Node first; //相当于头结点指针  private class Node { Key key; Value val; Node next; public Node(Key key, Value val, Node next) { this.key=key; this.val=val; this.next=next; } } } 这里给出了链表实现的方法：使用一个内部私有类Node来存放键和值。链表只有一个私有成员first，类型为私有内部类Node，用来指示下一个结点的位置，初始值是null。
/*这是根据键查找值 以及 插入一对新的键值对的方法*/ public Value get(Key key) { for(Node x=first;x!=null;x=x.next) { if(key.equals(x.key)) { return x.val; } } return null; } public void put(Key key,Value val) { for(Node x=first;x!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" />
<meta property="article:published_time" content="2020-10-31T15:12:26+08:00" />
<meta property="article:modified_time" content="2020-10-31T15:12:26+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">基本的查找算法</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Oct 31, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      <p><strong>根据书中的定义：符号表是一种存储键值对的数据结构。支持插入操作：将一组新的键值对存入表中。和查找操作：根据给定的键得到相对应的值</strong>
典型的符号表的应用：查字典时，单词就是键，释义就是值。通过单词来找到意思。
网络搜索时，关键字就是键，网页名称就是值，通过关键字来找到网页。</p>
<h1 id="约定">约定</h1>
<ol>
<li>每个键只对应一个值(而一个值可以对应于多个键)。即索引是唯一的。</li>
<li>键不能为空。</li>
<li>查找成功成为命中，不成功返回null为不命中</li>
<li>采用泛型的设计思想，在具体实现时在规定特定的类型。</li>
</ol>
<p>最基本的符号表的API：
<img src="/chapter3/3.1API.png" alt=""></p>
<h1 id="基于链表实现">基于链表实现</h1>
<p>符号表作为一种数据结构可以通过最基本的链表来实现。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SequentialSearchST</span><span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">,</span>Value<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Node first<span style="color:#f92672">;</span> <span style="color:#75715e">//相当于头结点指针
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>
    <span style="color:#f92672">{</span>
        Key key<span style="color:#f92672">;</span>
        Value val<span style="color:#f92672">;</span>
        Node next<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">,</span> Node next<span style="color:#f92672">)</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">=</span>key<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">=</span>val<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">=</span>next<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里给出了链表实现的方法：使用一个内部私有类Node来存放键和值。链表只有一个私有成员first，类型为私有内部类Node，用来指示下一个结点的位置，初始值是null。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/*这是根据键查找值 以及 插入一对新的键值对的方法*/</span>
<span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">=</span>first<span style="color:#f92672">;</span>x<span style="color:#f92672">!=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>x<span style="color:#f92672">=</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">))</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span>Value val<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>Node x<span style="color:#f92672">=</span>first<span style="color:#f92672">;</span>x<span style="color:#f92672">!=</span><span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>x<span style="color:#f92672">=</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">))</span>
        <span style="color:#f92672">{</span>
            x<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">=</span>val<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    first <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span>val<span style="color:#f92672">,</span>first<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter3/3.1disorderlinkexample.png" alt=""></p>
<p>对于链表的实现又可以分为有序和无序，
有序链表需要在每次插入时控制插入的位置，时间复杂度为O(N)。
无序链表每次插入只要在头部或者尾部插入即可，时间复杂度为O(1)。
但是符号表的基本操作是通过键查找值和插入一对新的键值对。这显然不适合有序链表：有序链表插入是O(N),查找也需要O(N).
对于无序链表，插入操作很快，但是查找的复杂度也到达O(N)。</p>
<h1 id="基于数组实现">基于数组实现</h1>
<p>考虑用数组来实现符号表
当然也可以分为有序数组和无序数组。
对于无序数组，插入操作为O(1),但是查找却需要遍历数组O(N)，本质上跟无序链表一致。
但是对于有序数组，虽然插入时需要O(N)，但是查找可以通过著名的二分查找算法，将复杂度控制在O(logN).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BinarySearchST</span><span style="color:#f92672">&lt;</span>Key <span style="color:#66d9ef">extends</span> Comparable<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;,</span> Value<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Key<span style="color:#f92672">[]</span> keys<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Value<span style="color:#f92672">[]</span> vals<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BinarySearchST</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacity<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        keys <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Key<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>capacity<span style="color:#f92672">];</span>
        vals <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Value<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">[</span>capacity<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>此外，在有序数组实现符号表中，可以在很短的时间有更多的操作。比如返回最大/小的键即返回数组的下标第一个/最后一个。
<img src="/chapter3/3.1API2.png" alt=""></p>
<p>所以，在基础的实现中，有序数组实现符号表是最高效的，这得力于适用于有序序列的 <em><strong>二分查找</strong></em> 算法。</p>
<p>给出基本方法的实现。其中 <strong>rank()</strong> 操作：
<strong>如果存在key键，则返回该键的位置，否则返回小于key的键的数目。</strong>
<strong>这样做的目的是可以让别的方法调用这个方法。比如put()通过rank()确定插入位置。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> capacity<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">//扩容算法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">assert</span> capacity <span style="color:#f92672">&gt;=</span> n<span style="color:#f92672">;</span>
    Key<span style="color:#f92672">[]</span> tempk <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Key<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Comparable<span style="color:#f92672">[</span>capacity<span style="color:#f92672">];</span>
    Value<span style="color:#f92672">[]</span> tempv <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Value<span style="color:#f92672">[])</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">[</span>capacity<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        tempk<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        tempv<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> vals<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
    vals <span style="color:#f92672">=</span> tempv<span style="color:#f92672">;</span>
    keys <span style="color:#f92672">=</span> tempk<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">(){</span><span style="color:#66d9ef">return</span> n<span style="color:#f92672">;}</span>    <span style="color:#75715e">//返回符号表的大小
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">(){</span><span style="color:#66d9ef">return</span> size<span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">;}</span>   <span style="color:#75715e">//判断符号表是否为空
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">///判断符号表是否包含键key
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to contains() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> get<span style="color:#f92672">(</span>key<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>    <span style="color:#75715e">//调用get()方法
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> Value <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">//根据键返回对应的值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to get() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>  <span style="color:#75715e">//调用rank()方法
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//调用rank()要判断key是否相等
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>key<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> vals<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rank</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">//利用二分查找算法返回key在键中的排名（）
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果存在key键，则返回该键的位置，否则返回小于key的键的数目。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to rank() is null&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> hi <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>lo <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">-</span> lo<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>mid<span style="color:#f92672">]);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> hi <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> lo <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> mid<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> lo<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">,</span> Value val<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;first argument to put() is null&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>val <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//put(key,null)就相当于间接的将key这个键值对删除
</span><span style="color:#75715e"></span>        delete<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#75715e">//调用rank方法确定位置
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// key is already in table
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>key<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//如果存在就返回
</span><span style="color:#75715e"></span>        vals<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// insert new key-value pair
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">==</span> keys<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> resize<span style="color:#f92672">(</span>2 <span style="color:#f92672">*</span> keys<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;</span> i<span style="color:#f92672">;</span> j<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//若不存在就在rank的位置插入，插入与线性表插入一样，从后往前赋值
</span><span style="color:#75715e"></span>        keys<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> keys<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
        vals<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> vals<span style="color:#f92672">[</span>j <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
    keys<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> key<span style="color:#f92672">;</span>
    vals<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> val<span style="color:#f92672">;</span>
    n<span style="color:#f92672">++;</span>

    <span style="color:#75715e">//assert check();
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to delete() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isEmpty<span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>

    <span style="color:#75715e">// compute rank
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#75715e">//调用rank()
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// key not in table
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> n <span style="color:#f92672">||</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>key<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//删除操作和线性表删除一致，从前往后赋值
</span><span style="color:#75715e"></span>        keys<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> keys<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
        vals<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> vals<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    n<span style="color:#f92672">--;</span>
    keys<span style="color:#f92672">[</span>n<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>  <span style="color:#75715e">// to avoid loitering
</span><span style="color:#75715e"></span>    vals<span style="color:#f92672">[</span>n<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">//java自动回收
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// resize if 1/4 full
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> n <span style="color:#f92672">==</span> keys<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> 4<span style="color:#f92672">)</span> resize<span style="color:#f92672">(</span>keys<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">);</span>

    <span style="color:#75715e">//assert check();
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">min</span><span style="color:#f92672">(){</span><span style="color:#66d9ef">return</span> keys<span style="color:#f92672">[</span>0<span style="color:#f92672">];}</span>   <span style="color:#75715e">//返回最大最小元素
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">max</span><span style="color:#f92672">(){</span><span style="color:#66d9ef">return</span> keys<span style="color:#f92672">[</span>n <span style="color:#f92672">-</span> 1<span style="color:#f92672">];}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteMin</span><span style="color:#f92672">(){</span>delete<span style="color:#f92672">(</span>min<span style="color:#f92672">());}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deleteMax</span><span style="color:#f92672">(){</span>delete<span style="color:#f92672">(</span>max<span style="color:#f92672">());}</span>

<span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">select</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">//有序数组实现，对于查找元素很方便
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//查找第k个元素就直接通过下标访问。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> k <span style="color:#f92672">&gt;=</span> size<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;called select() with invalid argument: &#34;</span> <span style="color:#f92672">+</span> k<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> keys<span style="color:#f92672">[</span>k<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">floor</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">//返回小于等于key的最大键值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> 
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to floor() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> keys<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> 1<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> Key <span style="color:#a6e22e">ceiling</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">//返回大于等于key的最小值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument to ceiling() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> rank<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> n<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> keys<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>

</code></pre></div><p>对于上面方法的实现有几点注意：</p>
<ol>
<li>这些方法的关键在于rank(),而rank()通过二分查找提高了效率。</li>
<li>符号表的查找与数组的不同在于：数组的查找是通过a[0+k-1]下标直接访问第k个元素，而符号表的查找需要判断某个键在不在数组中。数组查找的是下标是连续的，而键不一定是连续的，它只是有序而已。</li>
</ol>
<h2 id="二分查找">二分查找</h2>
<p><img src="/chapter3/3.1BinarySearch.png" alt=""></p>
<p>二分查找的思想：<strong>对于有序数组</strong>，<em><strong>先将被查找的键和子数组的中间的键比较。如果被查找的键小于中间的键，则继续在左子数组查找；如果大于，则继续在右子数组查找；否则中间的那个键就是我们要查找的键。</strong></em>
注意点：1. <strong>有序</strong>。二分查找只适用于有序的数组。对于无序的数组不能使用，只能遍历查找。
2.<strong>数组</strong>。二分查找并不适用于链表实现的符号表。因为它每次都将待查找的键与数组中间的键比较。数组能根据下标迅速找到中间的键，但是链表却不能。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BinarySearch</span><span style="color:#f92672">(</span>Key key<span style="color:#f92672">)</span>   <span style="color:#75715e">//即上面的rank()方法
</span><span style="color:#75715e"></span><span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> lo <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span> hi <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>lo <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">-</span> lo<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> cmp <span style="color:#f92672">=</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>mid<span style="color:#f92672">]);</span> <span style="color:#75715e">//比较键的大小
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> hi <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cmp <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> lo <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> mid<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> lo<span style="color:#f92672">;</span> 
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BinarySearchByRecursion</span><span style="color:#f92672">(</span>Key key<span style="color:#960050;background-color:#1e0010">，</span><span style="color:#66d9ef">int</span> lo<span style="color:#960050;background-color:#1e0010">，</span><span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#75715e">//通过递归实现的二分查找
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>hi<span style="color:#f92672">&lt;</span>lo<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> lo<span style="color:#f92672">;</span>  <span style="color:#75715e">//返回小于key键的数目
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> mid<span style="color:#f92672">=(</span>high<span style="color:#f92672">+</span>low<span style="color:#f92672">)/</span>2<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cmp<span style="color:#f92672">=</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>keys<span style="color:#f92672">[</span>mid<span style="color:#f92672">]);</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>cmp<span style="color:#f92672">&lt;</span>0<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> BinarySearchByRecursion<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span>lo<span style="color:#f92672">,</span>mid<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>cmp<span style="color:#f92672">&gt;</span>0<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> BinarySearchByRecursion<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span>mid<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>hi<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> mid<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">(){</span><span style="color:#66d9ef">return</span> n<span style="color:#f92672">;}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">(</span>Key lo<span style="color:#f92672">,</span> Key hi<span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>lo <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;first argument to size() is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;second argument to size() is null&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>lo<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>hi<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>contains<span style="color:#f92672">(</span>hi<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> rank<span style="color:#f92672">(</span>hi<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> rank<span style="color:#f92672">(</span>lo<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> rank<span style="color:#f92672">(</span>hi<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> rank<span style="color:#f92672">(</span>lo<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>其中对于rank()方法，return lo;语句是必要的。因为rank()的作用：如果存在key键，则返回该键的位置，<strong>否则返回小于key的键的数目。</strong> <strong>目的是为了方便其他的get(),put(),delete()方法。</strong>
仅对于二分查找来说，这句话是不必要的，或者可以约定在不存在key时return null;</p>
<h2 id="二分查找的分析">二分查找的分析</h2>
<p><strong>命题：在N个键的有序数组中进行二分查找最多需要(logN+1)次比较，无论命中还是未命中。即BinarySearch()的T(N)=O(logN).</strong>
对于其他的方法，都只调用了一到两次rank()即二分查找算法。这些方法的时间最多也是对数级别的。</p>
<p>尽管二分查找算法以及将复杂度从线性级别降低到对数级别，但是仍然不能用来处理大问题。<strong>因为在键随机排列时，构造一个基于有序数组的符号标所需要访问数组的次数时O(N^2).</strong>
<strong>命题：向大小为N的有序数组插入一个新的元素在最坏情况下需要访问~2N次数组。因此向一个空符号表插入N个元素最坏情况下需要访问~N^2次数组。</strong></p>
<h2 id="启示">启示</h2>
<p><strong>对于一个静态表(不允许插入)来说，在初始时将它排序(O(NlogN))，然后再利用二分查找是值得的</strong>。
但是对于任意插入和删除的符号表来说，需要更加高效的实现。
<img src="/chapter3/allTypesOfST.jpg" alt=""></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
