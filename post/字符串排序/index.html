<!doctype html>
<html lang="en-us">
  <head>
    <title>字符串排序 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="字符串排序"/>
<meta name="twitter:description" content="引言 在第二章的排序中，学习了很多的排序算法：选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序。这些算法都是通用的算法，对于任何实现了Comparable接口的类的对象都适用(对于未实现Comparable接口的对象即自己定义的类，只要重写一下compareTo()方法即可)。
同时，第二章学习的都是基于比较的排序算法。对于基于比较的排序算法来说，其时间复杂度的下限为O(NlogN)&ndash;通过决策树可以简单证明。
除此之外，还有基于非比较的排序算法，其时间复杂度不受O(NlogN)的限制。比较常用的有计数排序，基数排序和桶排序。
而现在学习三种利用字符串的特殊性质将字符串排序：低位优先字符串排序、高位优先字符串排序和三向字符串快速排序。 注意：第二章的通用排序对字符串排序同样的适用，只不过现在介绍三种算法的更适用字符串排序。
字母表 一种偷懒的方法是用ASCII字母表或者UNICODE16字母表，虽然这种字母表对于很多的实现都是充足了，但是它有很多字符对于特定的实现是不必要的，那么我们可以自己实现一个字母表，给出每个字符在字母表中对应的值。
以构造只含有&#39;0123456789&rsquo;的数字字母表为例。
字母表要实现的方法包括 由字符给出在字母表的索引 和 由索引给出字符。
对于Unicode 16/ASCII字母表 它已经为0-9每个字符建立的一个对应的索引值，比如&#39;0&rsquo;对应48。构建我们自己的字母表需要利用它，可以先将输入的所有字符转化为一个字符数组，这个字符数组就是字母表。
下面要建立索引，直接以字母表数组的索引为索引显然不成立，因为这样的话每建立一个字母表都需要记住索引。 我们要利用已经规定要的Unicode 16.且我们已经有方法可以将char强转为一个整型(这个整型数就是它在Unicode16的索引值)。而Unicode 16 字符的索引一直到65535，那么就需要一个大小和Unicode一样大的数组inverse，用它来记录字符在我们自己实现的字母表中的索引。 for (int c = 0; c &lt; R; c&#43;&#43;) inverse[alphabet[c]] = c;
举例来说明：inverse数组大小为65536，初始化全为-1.对于字符&#39;0&rsquo;,我们可以直接(int)(&lsquo;0&rsquo;)将它转化为Unicode中的索引48，那么我们就把inverse数组下标为48那个元素赋值为它在自己实现的字母表的索引值(0)。这样一来，我们想要由&#39;0&rsquo;返回在我们实现的字母表的索引的时候可以直接返回inverse[(int)&lsquo;0&rsquo;]&lt;==&gt;inverse[48]，存储的就是0.简单来说，就是利用Unicode的索引再建立到我们自己的字母表的一个映射。
public class Alphabet { private char[] alphabet; // 记录字母表中的字符  private int[] inverse; // 记录在本字母表中各个字符对应的索引  private final int R; // 字母表的大小  public Alphabet(String alpha) {//通过输入所有的字符来构造一个字母表  // 检查是否有重复的字符  boolean[] unicode = new boolean[Character.MAX_VALUE]; for (int i = 0; i &lt; alpha."/>

    <meta property="og:title" content="字符串排序" />
<meta property="og:description" content="引言 在第二章的排序中，学习了很多的排序算法：选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序。这些算法都是通用的算法，对于任何实现了Comparable接口的类的对象都适用(对于未实现Comparable接口的对象即自己定义的类，只要重写一下compareTo()方法即可)。
同时，第二章学习的都是基于比较的排序算法。对于基于比较的排序算法来说，其时间复杂度的下限为O(NlogN)&ndash;通过决策树可以简单证明。
除此之外，还有基于非比较的排序算法，其时间复杂度不受O(NlogN)的限制。比较常用的有计数排序，基数排序和桶排序。
而现在学习三种利用字符串的特殊性质将字符串排序：低位优先字符串排序、高位优先字符串排序和三向字符串快速排序。 注意：第二章的通用排序对字符串排序同样的适用，只不过现在介绍三种算法的更适用字符串排序。
字母表 一种偷懒的方法是用ASCII字母表或者UNICODE16字母表，虽然这种字母表对于很多的实现都是充足了，但是它有很多字符对于特定的实现是不必要的，那么我们可以自己实现一个字母表，给出每个字符在字母表中对应的值。
以构造只含有&#39;0123456789&rsquo;的数字字母表为例。
字母表要实现的方法包括 由字符给出在字母表的索引 和 由索引给出字符。
对于Unicode 16/ASCII字母表 它已经为0-9每个字符建立的一个对应的索引值，比如&#39;0&rsquo;对应48。构建我们自己的字母表需要利用它，可以先将输入的所有字符转化为一个字符数组，这个字符数组就是字母表。
下面要建立索引，直接以字母表数组的索引为索引显然不成立，因为这样的话每建立一个字母表都需要记住索引。 我们要利用已经规定要的Unicode 16.且我们已经有方法可以将char强转为一个整型(这个整型数就是它在Unicode16的索引值)。而Unicode 16 字符的索引一直到65535，那么就需要一个大小和Unicode一样大的数组inverse，用它来记录字符在我们自己实现的字母表中的索引。 for (int c = 0; c &lt; R; c&#43;&#43;) inverse[alphabet[c]] = c;
举例来说明：inverse数组大小为65536，初始化全为-1.对于字符&#39;0&rsquo;,我们可以直接(int)(&lsquo;0&rsquo;)将它转化为Unicode中的索引48，那么我们就把inverse数组下标为48那个元素赋值为它在自己实现的字母表的索引值(0)。这样一来，我们想要由&#39;0&rsquo;返回在我们实现的字母表的索引的时候可以直接返回inverse[(int)&lsquo;0&rsquo;]&lt;==&gt;inverse[48]，存储的就是0.简单来说，就是利用Unicode的索引再建立到我们自己的字母表的一个映射。
public class Alphabet { private char[] alphabet; // 记录字母表中的字符  private int[] inverse; // 记录在本字母表中各个字符对应的索引  private final int R; // 字母表的大小  public Alphabet(String alpha) {//通过输入所有的字符来构造一个字母表  // 检查是否有重复的字符  boolean[] unicode = new boolean[Character.MAX_VALUE]; for (int i = 0; i &lt; alpha." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/" />
<meta property="article:published_time" content="2020-12-06T18:46:42+08:00" />
<meta property="article:modified_time" content="2020-12-06T18:46:42+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">字符串排序</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Dec 6, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="引言">引言</h1>
<p>在第二章的排序中，学习了很多的排序算法：选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序。这些算法都是通用的算法，对于任何实现了Comparable接口的类的对象都适用(对于未实现Comparable接口的对象即自己定义的类，只要重写一下compareTo()方法即可)。</p>
<p><img src="/chapter2/sort-characteristics.png" alt=""></p>
<p><em><strong>同时，第二章学习的都是基于比较的排序算法。对于基于比较的排序算法来说，其时间复杂度的下限为O(NlogN)&ndash;通过决策树可以简单证明</strong></em>。</p>
<p>除此之外，还有基于非比较的排序算法，其时间复杂度不受O(NlogN)的限制。比较常用的有计数排序，基数排序和桶排序。</p>
<p>而现在学习三种利用字符串的特殊性质将字符串排序：低位优先字符串排序、高位优先字符串排序和三向字符串快速排序。   <br>
注意：第二章的通用排序对字符串排序同样的适用，只不过现在介绍三种算法的更适用字符串排序。</p>
<h2 id="字母表">字母表</h2>
<p>一种偷懒的方法是用ASCII字母表或者UNICODE16字母表，虽然这种字母表对于很多的实现都是充足了，但是它有很多字符对于特定的实现是不必要的，那么我们可以自己实现一个字母表，给出每个字符在字母表中对应的值。</p>
<p><img src="/chapter5/5.1.0.jpg" alt=""></p>
<p>以构造只含有'0123456789&rsquo;的数字字母表为例。</p>
<p>字母表要实现的方法包括 由字符给出在字母表的索引 和 由索引给出字符。</p>
<p>对于Unicode 16/ASCII字母表 它已经为0-9每个字符建立的一个对应的索引值，比如'0&rsquo;对应48。构建我们自己的字母表需要利用它，可以先将输入的所有字符转化为一个字符数组，这个字符数组就是字母表。<br>
下面要建立索引，直接以字母表数组的索引为索引显然不成立，因为这样的话每建立一个字母表都需要记住索引。 <br>
我们要利用已经规定要的Unicode 16.且我们已经有方法可以将char强转为一个整型(这个整型数就是它在Unicode16的索引值)。而Unicode 16 字符的索引一直到65535，那么就需要一个大小和Unicode一样大的数组inverse，用它来记录字符在我们自己实现的字母表中的索引。          for (int c = 0; c &lt; R; c++)
inverse[alphabet[c]] = c;</p>
<p>举例来说明：inverse数组大小为65536，初始化全为-1.对于字符'0&rsquo;,我们可以直接(int)(&lsquo;0&rsquo;)将它转化为Unicode中的索引48，那么我们就把inverse数组下标为48那个元素赋值为它在自己实现的字母表的索引值(0)。这样一来，我们想要由'0&rsquo;返回在我们实现的字母表的索引的时候可以直接返回inverse[(int)&lsquo;0&rsquo;]&lt;==&gt;inverse[48]，存储的就是0.简单来说，就是利用Unicode的索引再建立到我们自己的字母表的一个映射。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Alphabet</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> alphabet<span style="color:#f92672">;</span>     <span style="color:#75715e">// 记录字母表中的字符
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> inverse<span style="color:#f92672">;</span>       <span style="color:#75715e">// 记录在本字母表中各个字符对应的索引
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> R<span style="color:#f92672">;</span>         <span style="color:#75715e">// 字母表的大小
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Alphabet</span><span style="color:#f92672">(</span>String alpha<span style="color:#f92672">)</span> <span style="color:#f92672">{</span><span style="color:#75715e">//通过输入所有的字符来构造一个字母表
</span><span style="color:#75715e"></span>       
        <span style="color:#75715e">// 检查是否有重复的字符
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> unicode <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>Character<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> alpha<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">char</span> c <span style="color:#f92672">=</span> alpha<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>unicode<span style="color:#f92672">[</span>c<span style="color:#f92672">])</span>
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal alphabet: repeated character = &#39;&#34;</span> <span style="color:#f92672">+</span> c <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#39;&#34;</span><span style="color:#f92672">);</span>
            unicode<span style="color:#f92672">[</span>c<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        alphabet <span style="color:#f92672">=</span> alpha<span style="color:#f92672">.</span><span style="color:#a6e22e">toCharArray</span><span style="color:#f92672">();</span> <span style="color:#75715e">//将字符串转化为字符数组
</span><span style="color:#75715e"></span>        R <span style="color:#f92672">=</span> alpha<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        inverse <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>Character<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">];</span> <span style="color:#75715e">//inverse数组大小为65536
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> inverse<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            inverse<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>

        <span style="color:#75715e">// 保证字符在Unicode 16 里面
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> c <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">;</span> c<span style="color:#f92672">++)</span>
            inverse<span style="color:#f92672">[</span>alphabet<span style="color:#f92672">[</span>c<span style="color:#f92672">]]</span> <span style="color:#f92672">=</span> c<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//由字符找在本字母表中的索引
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//用于统计频率
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">toIndex</span><span style="color:#f92672">(</span><span style="color:#66d9ef">char</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">&gt;=</span> inverse<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">||</span> inverse<span style="color:#f92672">[</span>c<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Character &#34;</span> <span style="color:#f92672">+</span> c <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; not in alphabet&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> inverse<span style="color:#f92672">[</span>c<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//由本字母表的索引返回本字母表的字符
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">char</span> <span style="color:#a6e22e">toChar</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> index <span style="color:#f92672">&gt;=</span> R<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;index must be between 0 and &#34;</span> <span style="color:#f92672">+</span> R <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> index<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> alphabet<span style="color:#f92672">[</span>index<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><hr>
<h1 id="键索引计数法">键索引计数法</h1>
<p>先学习一种适用于小整数键的简单排序算法。这是将要学习的三种字符串排序的基础。个人感觉就是 <em>计数排序</em> 。</p>
<p>小时候对扑克牌的分类的时候，在不考虑花色顺序的时候，我总会预留13堆(牌面1-13)的位置，然后一张一张的翻开牌，将它放到对应的牌面大小的位子那，相同的大小牌就叠成一堆。然后从第1堆到第13堆依次叠起来就得到了一副有序的牌。  <br>
而键索引计数法就是类似的想法。只不过他对于大小相等的牌也规定了顺序。</p>
<p>给出一个问题：如下图。将同学按照分组排序，组号都是小整数。假设数组a[]中的每个元素都保存了一个名字和一个组号，且通过a[i].key()可以返回学生的组号。
<img src="/chapter5/5.1.1.jpg" alt=""></p>
<ul>
<li>第一步 统计频率 <br>
我们new一个int类型的数组count计算每个键出现的频率。 <br>
在这里就是计算每组的人数。而count的大小和键有关。需要一个足够大的数组，使得每个键都能对应于数组的索引，在这里只需要大小为6即可(4+1+1)。  <br>
对于一般的情况，可以以键的最大值作为数组的大小，或者以7位标准的ASCII码的大小。</li>
</ul>
<p>如果键为r，那么就将count[r+1]加1.而使用下标r+1而不是r是为了第二步。 <br>
所以count[0]恒等于0；</p>
<p><img src="/chapter5/5.1.2.jpg" alt=""></p>
<ul>
<li>第二步 将频率转化为索引  <br>
这一步的作用也就是给出每个键在最终排序结果中的起始位置。假如第一组有2个人，第二组有3个人，即a[2]=2，a[3]=3。那么第四组的第一个人在最终排序的位置一定从2+3=5起。即第i组的人的起始位置等于前i-1组的人数之和。</li>
</ul>
<p>以这个实例为例子，对于第一步得到的频率数组，count[0]恒为0，因为第0组一定从0开始。这也就是为什么是count[r+1]的原因。而count[1]=count[1]+count[0]为0，因为第0组没人，第一组也就一定从0开始。同样的,count[2]=count[2]+count[1]为3，因为第二组排在第一组后面，所以第一组排完了0-2，第二组从3开始。</p>
<p><img src="/chapter5/5.1.3.jpg" alt=""></p>
<ul>
<li>第三步 数据分类  <br>
new一个辅助数组aux[],将所有元素移动到辅助数组中排序。在移动后将count[]中对应元素的值加1，以保证count[r]总是下一个键为r在aux[]中的索引位置。</li>
</ul>
<p>在这个例子中，未移动前count[2]，在将2赋值给aux[3]后，剩下的第二组的元素在最终的位置一定在aux[3]的下一个位置，所以将对应的count[]加1.话句话说，始终让count[]中对应位置存储的是对应元素在最终有序序列的起始位置。</p>
<p><img src="/chapter5/5.1.4.jpg" alt=""></p>
<ul>
<li>第四步 写回  <br>
将aux[]中的所有元素写回到原数组中</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
Student<span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Student<span style="color:#f92672">[</span>N<span style="color:#f92672">];</span> <span style="color:#75715e">//辅助数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span>count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">[</span>R<span style="color:#f92672">+</span>1<span style="color:#f92672">];</span>    <span style="color:#75715e">//用于计数   R与键的大小/字母表有关
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">key</span><span style="color:#f92672">()+</span>1<span style="color:#f92672">]++;</span>      <span style="color:#75715e">//第一步 统计频率
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">];</span>     <span style="color:#75715e">//第二步 将频率转化为索引  
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    aux<span style="color:#f92672">[</span>count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">key</span><span style="color:#f92672">()]++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>    <span style="color:#75715e">//第三步 数据分类     
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span>aux<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>               <span style="color:#75715e">//第四步 写回 
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>键索引计数法排序的时间复杂度为线性时间！  但只适用于小整数键排序。</li>
<li>键索引计数法是一种稳定的排序，去掉aux[]会导致其不稳定。</li>
</ul>
<hr>
<h1 id="低位优先的字符串排序lsd">低位优先的字符串排序(LSD)</h1>
<p>低位优先的字符串排序适用于定长的字符串排序。比如车牌排序，电话号码排序等。</p>
<p><img src="/chapter5/5.1.5.jpg" alt=""></p>
<h2 id="想法">想法</h2>
<p>假设字符串长度均为W，那么 <em><strong>从右向左</strong></em> 以每个位置的字符作为键，用上述的键索引计数法将排序W遍即可。   <br>
事实上，用任意一种 <em><strong>稳定</strong></em> 的排序都可以，且只有稳定的能行，正好 <em><strong>键索引计数法是稳定的算法</strong></em>。</p>
<h2 id="简单证明">简单证明：</h2>
<p>在将它们的最后i个字符作为键(用稳定的方式)进行排序后，任意两个键在数组中的顺序都是正确的(只考虑这些字符)。要么因为它们的倒数第i个字符不同，所以排序方法已经将它们顺序摆放正确；要么因为它们的倒数第i个字符相同，所以由排序的稳定性它们仍然有序。(有归纳法可知，对于i-1也正确)</p>
<p>换一种视角：如果由两个键，它们中还没有被检查过的字符完全相同，那么键的不同之处就仅限于已经被检查过的字符。因为这两个键已经被排序过，所以出于稳定性它们一直有序。另外，如果还没被检查的部分不同，那么已经被检查过的字符对于两者的最终顺序没有意义，之后的某轮处理会根据更高位的字符的不同修正这对键的顺序。</p>
<h2 id="实现">实现</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LSD</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> R <span style="color:#f92672">=</span> 256<span style="color:#f92672">;</span>   <span style="color:#75715e">// 以扩展后的8位的ASCII码为字母表 正常的实现足够了 字符基本都在里面
</span><span style="color:#75715e"></span>        String<span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>n<span style="color:#f92672">];</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> w<span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> d <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">;</span> d<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 从右向左的以每个位置的字符作为键进行键索引计数法
</span><span style="color:#75715e"></span>
            <span style="color:#75715e">// 第一步 统计频率
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>R<span style="color:#f92672">+</span>1<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
                count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>d<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">]++;</span>

            <span style="color:#75715e">// 第二步 将频率转化为索引
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span>
                count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">];</span>

            <span style="color:#75715e">// 第三步 数据分类
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
                aux<span style="color:#f92672">[</span>count<span style="color:#f92672">[</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">].</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>d<span style="color:#f92672">)]++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>

            <span style="color:#75715e">// 第四步 写回
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
                a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h2 id="讨论">讨论</h2>
<ul>
<li>
<p>应用：可以用于扑克牌排序，先按照牌面大小排序，然后按照花色排序。</p>
</li>
<li>
<p>无论N有多大，只需要遍历W次数据即可完成排序。</p>
</li>
<li>
<p>基于R个字符的字母表的N个以长为W的字符串为键的元素，低位优先的字符串排序需要访问~7WN+3WR次数组。使用额外空间为O(N+R).在R远小于N时，可以看作常数，那么时间复杂度为O(WN)。即低位优先的字符串排序与输入规模成正比。</p>
</li>
<li>
<p>对于字符串的长度不同的情况，稍加改进也可以应用。但是用下面的算法更好。</p>
</li>
</ul>
<hr>
<h1 id="高位优先的字符串排序msd">高位优先的字符串排序(MSD)</h1>
<h2 id="思想">思想</h2>
<p>低位优先的字符串排序从右向左排序，适用于字符串长度一样的情况。对于长度不一样的情况，用一种从左向右排序的方法更加适用。</p>
<p><img src="/chapter5/5.1.6.jpg" alt=""></p>
<p>高位优先的字符串排序：首先用键索引计数法将所有字符串按照首字母排序，然后递归地将每个首字母所对应的子数组排序(忽略首字母，因为每一类的所有字符串的首字母相同)。</p>
<p><img src="/chapter5/5.1.11.jpg" alt=""></p>
<h2 id="约定">约定</h2>
<p>由于字符串的长度不一样，所以约定将较短的字符串都排在较长字符串的前面。</p>
<p>如何实现？即对charAt()方法，当指定的位置超过了字符串的末尾时该方法返回-1。<br>
然后将所有返回值加1作为count[]的索引。(对于c语言，由于已经约定了字符串末尾有&rsquo;\0&rsquo;，则返回的应该时&rsquo;\0&rsquo;对应的值)      <br>
因为返回值有R+1种不同的值(0表示字符串结束，1表示字母表的第一个字符，2表示字母表的第二个字符……)那么count[]大小就需要比键索引计数还要再大1，即R+2.</p>
<p>换句话来讲，假设在对下标为d的字符进行排序的时候，在第一步频率统计时，若某个较短的字符串的下标d已经越界了，就返回-1，然后在count[1]的位置记录，以此来保证较短的字符在第三步和第四步写回的时候一定排在较长字符串的前面。</p>
<h2 id="实现-1">实现</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MSD</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//不同的字母表
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BITS_PER_BYTE <span style="color:#f92672">=</span>   8<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> BITS_PER_INT  <span style="color:#f92672">=</span>  32<span style="color:#f92672">;</span>   
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> R             <span style="color:#f92672">=</span> 256<span style="color:#f92672">;</span>   

    <span style="color:#75715e">//切换到插入排序的阈值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CUTOFF        <span style="color:#f92672">=</span>  15<span style="color:#f92672">;</span>   

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        String<span style="color:#f92672">[]</span> aux <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>n<span style="color:#f92672">];</span>   <span style="color:#75715e">//在递归调用之外创建 只需要一次
</span><span style="color:#75715e"></span>        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> n<span style="color:#f92672">-</span>1<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> aux<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//当指定的位置超过了字符串的末尾时该方法返回-1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">assert</span> d <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> d <span style="color:#f92672">&lt;=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>d <span style="color:#f92672">==</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>d<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//对a[low]到a[high-1]的high-low个字符串排序  以第d的字符作为标准
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">,</span> String<span style="color:#f92672">[]</span> aux<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#75715e">//小于阈值 切换到插入排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&lt;=</span> lo <span style="color:#f92672">+</span> CUTOFF<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            insertion<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">,</span> d<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>R<span style="color:#f92672">+</span>2<span style="color:#f92672">];</span>     <span style="color:#75715e">//每次递归都要创建一个//有R+2种情况
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> charAt<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> d<span style="color:#f92672">);</span>
            count<span style="color:#f92672">[</span>c<span style="color:#f92672">+</span>2<span style="color:#f92672">]++;</span>   <span style="color:#75715e">// +2 因为多了一个超过键索引的情况
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span>
            count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">];</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> charAt<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> d<span style="color:#f92672">);</span>
            aux<span style="color:#f92672">[</span>count<span style="color:#f92672">[</span>c<span style="color:#f92672">+</span>1<span style="color:#f92672">]++]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> 
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> aux<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> lo<span style="color:#f92672">];</span>

        <span style="color:#75715e">//递归的进行排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> r <span style="color:#f92672">&lt;</span> R<span style="color:#f92672">;</span> r<span style="color:#f92672">++)</span>
            sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo <span style="color:#f92672">+</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">],</span> lo <span style="color:#f92672">+</span> count<span style="color:#f92672">[</span>r<span style="color:#f92672">+</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">,</span> d<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> aux<span style="color:#f92672">);</span>
            <span style="color:#75715e">//在子数组的位置递归进行排序
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    
    <span style="color:#75715e">//插入排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertion</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;</span> lo <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">],</span> d<span style="color:#f92672">);</span> j<span style="color:#f92672">--)</span>
                exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> j<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h2 id="问题">问题</h2>
<ol>
<li>
<p>额外空间 <br>
高位优先的字符串排序的成本和字母表的字符数量有很大关系。每次递归都要创建一个大小为R+2的count数组。</p>
</li>
<li>
<p>小型子数组 <br>
在一般应用中，只需要检查若干字符就能完成所有字符串的排序。换句话说，高位优先字符串排序能够快速的将需要排序的数组切分为较小的数组，这些小型子数组对于算法复杂度很重要。对于小型子数组，要切换到插入排序。它接受一个额外的参数d并假设所需要排序的字符串a[lo]~a[hi-1]的前d个字符都是相同的。  <br>
<em><strong>对于所有的递归算法中，都可以对小型子数组进行特殊处理来提高效率</strong></em>。</p>
</li>
<li>
<p>等值键  <br>
如果等值键很多或者有大量含有相同前缀的键时，切换到插入排序将不会出现，这种情况不适用于高位优先的插入排序。</p>
</li>
</ol>
<h2 id="复杂度">复杂度</h2>
<ul>
<li>
<p>对于随机字符串输入，相对于输入数据中字符总数，算法运行时间比线性低(只会检查输入字符中的一小部分)</p>
</li>
<li>
<p>对于非随机的输入，特别是对于相等的键，需要检查它们的所有的字符。运行时间和字符总数接近正比。</p>
</li>
<li>
<p>最坏情况，字符串都是相等的，则需要见检查所有字符，与字符总数成正比。</p>
</li>
</ul>
<hr>
<h1 id="三向字符串快速排序">三向字符串快速排序</h1>
<p><img src="/chapter5/5.1.8.jpg" alt=""></p>
<h2 id="思想-1">思想</h2>
<p>高位优先的字符串排序每次利用键索引计数法对当前首字母进行分类，将它首字母相同的字符串都分为一类。然后递归的对他们进行排序。</p>
<p>而快速排序也是划分的思想，以a[0]为划分元素，将数组划分为 小于a[0] 等于a[0] 和大于a[0]三类。然后对于等于的情况不用考虑，因为它已经在最终位置了，只需要对小于和大于的两部分递归排序。</p>
<p>同样的，将高位优先字符串排序和快速排序相结合：根据键的首字母三向切分，切分为小于首字母的  等于首字母的  和大于首字母的三类。然后递归的对3个子数组排序。对于等于首字母的若干字符串，它们的最终位置已经确定。</p>
<p><img src="/chapter5/5.1.9.jpg" alt=""></p>
<h2 id="较高位优先的改进">较高位优先的改进</h2>
<ul>
<li>
<p>高位优先每次切分都需要分为字母表大小那么多组(只不过很多组可能是空的)。而三向排序只需要分为3组。</p>
</li>
<li>
<p>高位优先每次递归都需要一个count数组，大小和字母表有关。而三向字符串快速排序和快速排序一样，只需要递归所需的隐式栈，它是通过移动元素来分类的。</p>
</li>
<li>
<p>所以三向字符串快速排序能够很好的处理高位优先的最坏情况：等值键/较长公共前缀/小字母表。</p>
</li>
</ul>
<h2 id="改进">改进</h2>
<ul>
<li>对于所有的递归算法，都可以通过对小型问题进行特殊处理来提高效率。这也可以在小型数组时切换到插入排序。</li>
</ul>
<p>但是注意，切换到自己实现的小型字母表并不能得到什么收益，也没有节省空间。</p>
<h2 id="实现-2">实现</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quick3string</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CUTOFF <span style="color:#f92672">=</span>  15<span style="color:#f92672">;</span>   <span style="color:#75715e">// 切换到快速排序的阈值
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">private</span> <span style="color:#a6e22e">Quick3string</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">shuffle</span><span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">assert</span> d <span style="color:#f92672">&gt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> d <span style="color:#f92672">&lt;=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>d <span style="color:#f92672">==</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>d<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//以第d个字符为标准对a[lo..hi]的字符串进行排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#75715e">// 切换到快速排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&lt;=</span> lo <span style="color:#f92672">+</span> CUTOFF<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            insertion<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">,</span> d<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">//三向快速排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> lt <span style="color:#f92672">=</span> lo<span style="color:#f92672">,</span> gt <span style="color:#f92672">=</span> hi<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> charAt<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>lo<span style="color:#f92672">],</span> d<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;=</span> gt<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> charAt<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> d<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span>      <span style="color:#f92672">(</span>t <span style="color:#f92672">&lt;</span> v<span style="color:#f92672">)</span> exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lt<span style="color:#f92672">++,</span> i<span style="color:#f92672">++);</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">&gt;</span> v<span style="color:#f92672">)</span> exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> gt<span style="color:#f92672">--);</span>
            <span style="color:#66d9ef">else</span>              i<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//递归的对三个子问题进行排序
</span><span style="color:#75715e"></span>        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> lt<span style="color:#f92672">-</span>1<span style="color:#f92672">,</span> d<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lt<span style="color:#f92672">,</span> gt<span style="color:#f92672">,</span> d<span style="color:#f92672">+</span>1<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> gt<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> hi<span style="color:#f92672">,</span> d<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">//以第d个字符为标准对a[lo..hi]进行插入排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertion</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;</span> lo <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">],</span> d<span style="color:#f92672">);</span> j<span style="color:#f92672">--)</span>
                exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> j<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">exch</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String temp <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
        a<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> temp<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// is v less than w, starting at character d
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// DEPRECATED BECAUSE OF SLOW SUBSTRING EXTRACTION IN JAVA 7
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// private static boolean less(String v, String w, int d) {
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//    assert v.substring(0, d).equals(w.substring(0, d));
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//    return v.substring(d).compareTo(w.substring(d)) &lt; 0; 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// }
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// is v less than w, starting at character d
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">less</span><span style="color:#f92672">(</span>String v<span style="color:#f92672">,</span> String w<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> d<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">assert</span> v<span style="color:#f92672">.</span><span style="color:#a6e22e">substring</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> d<span style="color:#f92672">).</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>w<span style="color:#f92672">.</span><span style="color:#a6e22e">substring</span><span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> d<span style="color:#f92672">));</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> d<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>v<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">(),</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">());</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> w<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

</code></pre></div><h2 id="复杂度-1">复杂度</h2>
<p>和快速排序一样，在排序前将字符串打乱可以有效避免最坏情况发生的可能。</p>
<p>要将含有N个随机字符串的数组排序，三向字符串快速排序平均需要比较字符~2NlnN次。</p>
<h1 id="总结">总结</h1>
<p>事实上，之前的所有的排序都适用于字符串的排序，因为之前的各种排序都是依靠实现Comparable接口，基于比较的排序。而Java的String字符串类型实现了这个接口。</p>
<p>并且String类的compareTo()方法时从左到右访问字符串的所有字符的。换句话说，compareTo()在首字母不同时只会访问首字母，在首字母相同且第二个字母不同时只会访问前两个字母。这样来看，他也是利用高位优先字符串排序或者三向字符串快速排序。</p>
<p><img src="/chapter5/5.1.10.jpg" alt=""></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
