<!doctype html>
<html lang="en-us">
  <head>
    <title>平衡查找树 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="平衡查找树"/>
<meta name="twitter:description" content="引入：
二叉查找树各种方法的复杂度都与树的高度成正比，但是在最坏的情况(键按序插入)下二叉查找树的高度为h，这是非常糟糕的。
若树的每个结点的左右子树高度之差(即平衡因子)绝对值小于1，则称这棵树是平衡的；
显然，完全二叉树就是一个完美平衡的二叉树。
我们引入平衡查找树(Balanced-Search-Tree，BST)。
对于二叉平衡查找树，即AVL树(简称平衡二叉树)能够保证二叉查找树的高度为~logN.
（平衡二叉树只是平衡查找树的一部分，也是最常见的一部分）
但是维护AVL树的平衡(即左旋，右旋等操作)的代价很大，所以可以降低要求实现，即红黑树。
虽然红黑树不是严格意义的平衡，但是它的黑结点是完全平衡的。
 一、2-3查找树 为了保证平衡，给二叉树增加了一些灵活性，允许一个结点保存多个键。
 将一棵标准二叉查找树中的结点称作2-结点(一个键和两条链接) 类似的，k-结点有k-1个键和k条链接
  2-3查找树的定义：一棵2-3查找树或为一棵空树，或由2-结点/3-结点组成。
那么m-n查找树的定义：一棵m-n查找树或为一棵空树，或由m-结点到n结点组成
将指向一棵空树的链接称为空链接，那么一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都相等。
1、查找 2-3查找树的查找算法和二叉查找树类似，唯一不同的只是二叉查找树每个结点都是2-结点(只有一个键)，所以二叉查找树只需要将key和结点x.key相比，然后递归的在左或者右子树查找;
而2-3查找树可能有3-结点，那么判断时就需要将结点的所有键与key比较，然后递归的在左，中间或者右子树查找。
2、插入 保证插入后树仍然平衡
2、1 &mdash; 向2-结点插入新键 把插入的键保存在结点中，使得2-结点变成3-结点即可。
2、2 &mdash; 向一棵只有一个3-结点的树插入新键 先考虑特殊情况：这棵树只有一个根结点为3-结点。在插入之后先让他成为临时4-结点，然后进行分裂。分裂成为3个2-结点，三个键的中间的键作为新的根结点，最小的与根结点的左链接相连，最大的与根结点的右链接相连。保持了平衡。
插入前树的高度为0，插入后树的高度增加了1。
2、3 &mdash; 向一个父节点为2-结点的3-结点插入新键 3-结点插入了新键后变为一个4-结点，需要分裂。因为父结点是2-结点，所以父结点有空间。它将中间的键给到父节点，然后中间键的左右链接指向分裂的两个键。
2、4 &mdash; 向一个父节点为3-结点的3-结点插入新键 将中间的键给到父节点，自己分裂称2个2-结点。但是父节点由原来的3-结点变为4-结点，也需要继续向它的父节点继续给出中间键。这样的操作最多持续到根结点或者遇到一个2-结点的祖父结点。
2、5 &mdash; 根结点分裂 若从插入结点到根结点的路径上都是3-结点，那么根结点最后也会变成一个4-结点，需要进行2、2的分裂。此时树高加1.
分析 与标准的二叉查找树从上而下的构造不同，2-3树的生长是从下而上的。
按照升序插入的10个键，对于二叉查找树会得到一个高度为9的树，但是对于2-3树，树高仅仅为2。
对于最坏情况，2-3查找树也有很好的表现。
命题：在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过logN个。
每个操作中处理每个结点的时间都不会超过很小的一个常数，所以任何查找或者插入操作的成本都不会超过对数级别。但是2-结点和3-结点之间的转换却需要很大的成本。这是得不偿失的。
所以我们引入了红黑树。
 二、红黑二叉查找树 "/>

    <meta property="og:title" content="平衡查找树" />
<meta property="og:description" content="引入：
二叉查找树各种方法的复杂度都与树的高度成正比，但是在最坏的情况(键按序插入)下二叉查找树的高度为h，这是非常糟糕的。
若树的每个结点的左右子树高度之差(即平衡因子)绝对值小于1，则称这棵树是平衡的；
显然，完全二叉树就是一个完美平衡的二叉树。
我们引入平衡查找树(Balanced-Search-Tree，BST)。
对于二叉平衡查找树，即AVL树(简称平衡二叉树)能够保证二叉查找树的高度为~logN.
（平衡二叉树只是平衡查找树的一部分，也是最常见的一部分）
但是维护AVL树的平衡(即左旋，右旋等操作)的代价很大，所以可以降低要求实现，即红黑树。
虽然红黑树不是严格意义的平衡，但是它的黑结点是完全平衡的。
 一、2-3查找树 为了保证平衡，给二叉树增加了一些灵活性，允许一个结点保存多个键。
 将一棵标准二叉查找树中的结点称作2-结点(一个键和两条链接) 类似的，k-结点有k-1个键和k条链接
  2-3查找树的定义：一棵2-3查找树或为一棵空树，或由2-结点/3-结点组成。
那么m-n查找树的定义：一棵m-n查找树或为一棵空树，或由m-结点到n结点组成
将指向一棵空树的链接称为空链接，那么一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都相等。
1、查找 2-3查找树的查找算法和二叉查找树类似，唯一不同的只是二叉查找树每个结点都是2-结点(只有一个键)，所以二叉查找树只需要将key和结点x.key相比，然后递归的在左或者右子树查找;
而2-3查找树可能有3-结点，那么判断时就需要将结点的所有键与key比较，然后递归的在左，中间或者右子树查找。
2、插入 保证插入后树仍然平衡
2、1 &mdash; 向2-结点插入新键 把插入的键保存在结点中，使得2-结点变成3-结点即可。
2、2 &mdash; 向一棵只有一个3-结点的树插入新键 先考虑特殊情况：这棵树只有一个根结点为3-结点。在插入之后先让他成为临时4-结点，然后进行分裂。分裂成为3个2-结点，三个键的中间的键作为新的根结点，最小的与根结点的左链接相连，最大的与根结点的右链接相连。保持了平衡。
插入前树的高度为0，插入后树的高度增加了1。
2、3 &mdash; 向一个父节点为2-结点的3-结点插入新键 3-结点插入了新键后变为一个4-结点，需要分裂。因为父结点是2-结点，所以父结点有空间。它将中间的键给到父节点，然后中间键的左右链接指向分裂的两个键。
2、4 &mdash; 向一个父节点为3-结点的3-结点插入新键 将中间的键给到父节点，自己分裂称2个2-结点。但是父节点由原来的3-结点变为4-结点，也需要继续向它的父节点继续给出中间键。这样的操作最多持续到根结点或者遇到一个2-结点的祖父结点。
2、5 &mdash; 根结点分裂 若从插入结点到根结点的路径上都是3-结点，那么根结点最后也会变成一个4-结点，需要进行2、2的分裂。此时树高加1.
分析 与标准的二叉查找树从上而下的构造不同，2-3树的生长是从下而上的。
按照升序插入的10个键，对于二叉查找树会得到一个高度为9的树，但是对于2-3树，树高仅仅为2。
对于最坏情况，2-3查找树也有很好的表现。
命题：在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过logN个。
每个操作中处理每个结点的时间都不会超过很小的一个常数，所以任何查找或者插入操作的成本都不会超过对数级别。但是2-结点和3-结点之间的转换却需要很大的成本。这是得不偿失的。
所以我们引入了红黑树。
 二、红黑二叉查找树 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91/" />
<meta property="article:published_time" content="2020-11-04T23:28:42+08:00" />
<meta property="article:modified_time" content="2020-11-04T23:28:42+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">平衡查找树</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 4, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>引入：<br>
二叉查找树各种方法的复杂度都与树的高度成正比，但是在最坏的情况(键按序插入)下二叉查找树的高度为h，这是非常糟糕的。</p>
<p>若树的每个结点的左右子树高度之差(即平衡因子)绝对值小于1，则称这棵树是平衡的；<br>
显然，<strong>完全二叉树就是一个完美平衡的二叉树</strong>。</p>
<p>我们引入平衡查找树(Balanced-Search-Tree，BST)。<br>
对于二叉平衡查找树，即AVL树(简称平衡二叉树)能够保证二叉查找树的高度为~logN.<br>
（平衡二叉树只是平衡查找树的一部分，也是最常见的一部分）<br>
<strong>但是维护AVL树的平衡(即左旋，右旋等操作)的代价很大，所以可以降低要求实现，即红黑树。</strong></p>
<p><strong>虽然红黑树不是严格意义的平衡，但是它的黑结点是完全平衡的。</strong><br>
<img src="/chapter3/3.3.1jiegou.png" alt=""></p>
<hr>
<h1 id="一2-3查找树">一、2-3查找树</h1>
<p>为了保证平衡，给二叉树增加了一些灵活性，允许一个结点保存多个键。</p>
<ul>
<li>将一棵标准二叉查找树中的结点称作<strong>2-结点(一个键和两条链接)</strong></li>
<li>类似的，<strong>k-结点有k-1个键和k条链接</strong><br>
<img src="/chapter3/3.3.223tree-anatomy.png" alt=""></li>
</ul>
<p>2-3查找树的定义：<strong>一棵2-3查找树或为一棵空树，或由2-结点/3-结点组成。</strong></p>
<p>那么m-n查找树的定义：<strong>一棵m-n查找树或为一棵空树，或由m-结点到n结点组成</strong></p>
<p>将指向一棵空树的链接称为空链接，那么一棵完美平衡的2-3查找树中的<strong>所有空链接到根结点</strong>的距离都相等。</p>
<h2 id="1查找">1、查找</h2>
<p>2-3查找树的查找算法和二叉查找树类似，唯一不同的只是二叉查找树每个结点都是2-结点(只有一个键)，所以二叉查找树只需要将key和结点x.key相比，然后递归的在左或者右子树查找;<br>
而2-3查找树可能有3-结点，那么判断时就需要将结点的所有键与key比较，然后递归的在左，中间或者右子树查找。<br>
<img src="/chapter3/3.3.323tree-search.png" alt=""></p>
<h2 id="2插入">2、插入</h2>
<p>保证插入后树仍然平衡</p>
<h3 id="21-----向2-结点插入新键">2、1 &mdash; 向2-结点插入新键</h3>
<p>把插入的键保存在结点中，使得2-结点变成3-结点即可。<br>
<img src="/chapter3/3.3.423tree-insert2.png" alt=""></p>
<h3 id="22-----向一棵只有一个3-结点的树插入新键">2、2 &mdash; 向一棵只有一个3-结点的树插入新键</h3>
<p>先考虑特殊情况：这棵树只有一个根结点为3-结点。在插入之后先让他成为临时4-结点，然后进行分裂。分裂成为3个2-结点，三个键的中间的键作为新的根结点，最小的与根结点的左链接相连，最大的与根结点的右链接相连。保持了平衡。<br>
插入前树的高度为0，插入后树的高度增加了1。<br>
<img src="/chapter3/3.3.523tree-insert3a.png" alt=""></p>
<h3 id="23-----向一个父节点为2-结点的3-结点插入新键">2、3 &mdash; 向一个父节点为2-结点的3-结点插入新键</h3>
<p>3-结点插入了新键后变为一个4-结点，需要分裂。因为父结点是2-结点，所以父结点有空间。它将中间的键给到父节点，然后中间键的左右链接指向分裂的两个键。<br>
<img src="/chapter3/3.3.623tree-insert3b.png" alt=""></p>
<h3 id="24-----向一个父节点为3-结点的3-结点插入新键">2、4 &mdash; 向一个父节点为3-结点的3-结点插入新键</h3>
<p>将中间的键给到父节点，自己分裂称2个2-结点。但是父节点由原来的3-结点变为4-结点，也需要继续向它的父节点继续给出中间键。这样的操作最多持续到根结点或者遇到一个2-结点的祖父结点。</p>
<p><img src="/chapter3/3.3.723tree-insert3c.png" alt=""></p>
<h3 id="25-----根结点分裂">2、5 &mdash; 根结点分裂</h3>
<p>若从插入结点到根结点的路径上都是3-结点，那么根结点最后也会变成一个4-结点，需要进行2、2的分裂。此时树高加1.<br>
<img src="/chapter3/3.3.823tree-split.png" alt=""></p>
<h3 id="分析">分析</h3>
<p><strong>与标准的二叉查找树从上而下的构造不同，2-3树的生长是从下而上的。</strong><br>
按照升序插入的10个键，对于二叉查找树会得到一个高度为9的树，但是对于2-3树，树高仅仅为2。<br>
对于最坏情况，2-3查找树也有很好的表现。<br>
<img src="/chapter3/3.3.9%E3%80%82jpg" alt=""></p>
<p><strong>命题：在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过logN个。</strong></p>
<p>每个操作中处理每个结点的时间都不会超过很小的一个常数，所以任何查找或者插入操作的成本都不会超过对数级别。但是2-结点和3-结点之间的转换却需要很大的成本。这是得不偿失的。<br>
所以我们引入了红黑树。</p>
<hr>
<h1 id="二红黑二叉查找树">二、红黑二叉查找树</h1>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
