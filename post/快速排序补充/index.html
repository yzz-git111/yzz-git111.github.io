<!doctype html>
<html lang="en-us">
  <head>
    <title>快速排序补充 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="快速排序补充"/>
<meta name="twitter:description" content="鉴于快速排序的优异性 有必要对快速排序进一步讨论   1.循坏停止条件 public static int partition(Comparable[] a,int low,int high) { while(true) { while(template.less(a[&#43;&#43;i],v)) //a[&#43;&#43;i]&gt;v时跳出循坏//从左往右找第一个比v大的元素  { if(i==high) break; //如果找第一个比v大的元素一直到了数组末尾 则说明数组都比v小  } while(template.less(v,a[--j])) { if(j==low) break; //如果找第一个比v小的元素一直到了数组开头 则说明数组都比v大  } if(i&gt;=j) //如果i和j碰到一起 就说明找完了 对数组的划分完成了  break; template.exchange(a,i,j); } template.exchange(a,low,j); //最后将划分元素给到适当位置j  return j; //j就是划分元素的最终位置  } 这里从左往右找第一个满足 不小于(&gt;=)v 的元素，以及从右往左找第一个满足 不大于(&lt;=)v的元素。 至于为什么有等于情况，是因为如果遇到和切分元素相同的元素时我们继续扫描而不停下，可能运行时间会退化为平方量级。
考虑一个极端的情况：aaaaaaa 这样的话i(从左往右找的)会停留在high,而j(从右往左找的)会停留在low。最后交换low和j（template.exchange(a,low,j);） 这样只使得第一个元素被划分，子数组变成了除第一个元素剩下的元素。每次划分规模减小1，循环n次，每次都O(n)，所以复杂度退化到平方量级。
但如果等于情况也停下，i会停留在第二个a，j会停留在最后一个a，这样交换第一个a（用于划分的）和中间的a（mid）。后来的子问题规模就只有一般，和一般情况复杂度一样。 虽然这样会有一些无用的交换，但是可以避免在重复元素多的时候时间复杂度退化到平方量级。
  2.最佳情况 问题：试着编写一段程序来生成使得快速排序表现最佳的数组。
思考：快速排序的最好情况：无重复的元素，且每次切分后的两个子数组的大小最多相差1. 无重复的元素很容易实现，只要控制输入即可。
考察快速排序的过程，先选取第一个元素为切分元素，最后切分结束就把第一个元素和j交换。为了保证每次切分后的两个子数组大小最多差1，就要保证每次划分元素正好是原数组排序后的中间的元素。
反过来，为了找到最好的情况，就相当于是一个逆过程。此时的输入是一个已经有序的序列。每次都将第一个元素与中间元素交换即可。这就相当于partation().
采用分治算法：假如现在a[low..mid-1],a[mid&#43;1..high]都已经是最优解，这时只要将第一个元素与中间元素交换。而为了得到子问题的最优解，以中间元素为界限，将原问题分解为a[low..mid-1],a[mid&#43;1..high]两个子问题，只要保证子问题最优，原问题也最优。继续的递归划分，对于只有一个元素的平凡问题，由于第一个元素==中间元素，不必交换直接返回。
举一个实例，假设对abcdefg进行最好情况的构造。先对原问题进行切割，分成abc和efg。接着处理子问题abc，继续切分，切分成a和c，都是平凡问题，不用处理。返回到子问题abc，交换a(第一个元素/切分元素)和b(中间元素)，得到bac，这样子问题abc已经处理完。处理完abc再处理子问题efg，重复上述步骤，子问题efg的解应该为feg。最后返回到原问题，此时的原问题数组已经变成了bacdfeg。进行最后一次交换，得到最终的结果dacbfeg。
参考代码:"/>

    <meta property="og:title" content="快速排序补充" />
<meta property="og:description" content="鉴于快速排序的优异性 有必要对快速排序进一步讨论   1.循坏停止条件 public static int partition(Comparable[] a,int low,int high) { while(true) { while(template.less(a[&#43;&#43;i],v)) //a[&#43;&#43;i]&gt;v时跳出循坏//从左往右找第一个比v大的元素  { if(i==high) break; //如果找第一个比v大的元素一直到了数组末尾 则说明数组都比v小  } while(template.less(v,a[--j])) { if(j==low) break; //如果找第一个比v小的元素一直到了数组开头 则说明数组都比v大  } if(i&gt;=j) //如果i和j碰到一起 就说明找完了 对数组的划分完成了  break; template.exchange(a,i,j); } template.exchange(a,low,j); //最后将划分元素给到适当位置j  return j; //j就是划分元素的最终位置  } 这里从左往右找第一个满足 不小于(&gt;=)v 的元素，以及从右往左找第一个满足 不大于(&lt;=)v的元素。 至于为什么有等于情况，是因为如果遇到和切分元素相同的元素时我们继续扫描而不停下，可能运行时间会退化为平方量级。
考虑一个极端的情况：aaaaaaa 这样的话i(从左往右找的)会停留在high,而j(从右往左找的)会停留在low。最后交换low和j（template.exchange(a,low,j);） 这样只使得第一个元素被划分，子数组变成了除第一个元素剩下的元素。每次划分规模减小1，循环n次，每次都O(n)，所以复杂度退化到平方量级。
但如果等于情况也停下，i会停留在第二个a，j会停留在最后一个a，这样交换第一个a（用于划分的）和中间的a（mid）。后来的子问题规模就只有一般，和一般情况复杂度一样。 虽然这样会有一些无用的交换，但是可以避免在重复元素多的时候时间复杂度退化到平方量级。
  2.最佳情况 问题：试着编写一段程序来生成使得快速排序表现最佳的数组。
思考：快速排序的最好情况：无重复的元素，且每次切分后的两个子数组的大小最多相差1. 无重复的元素很容易实现，只要控制输入即可。
考察快速排序的过程，先选取第一个元素为切分元素，最后切分结束就把第一个元素和j交换。为了保证每次切分后的两个子数组大小最多差1，就要保证每次划分元素正好是原数组排序后的中间的元素。
反过来，为了找到最好的情况，就相当于是一个逆过程。此时的输入是一个已经有序的序列。每次都将第一个元素与中间元素交换即可。这就相当于partation().
采用分治算法：假如现在a[low..mid-1],a[mid&#43;1..high]都已经是最优解，这时只要将第一个元素与中间元素交换。而为了得到子问题的最优解，以中间元素为界限，将原问题分解为a[low..mid-1],a[mid&#43;1..high]两个子问题，只要保证子问题最优，原问题也最优。继续的递归划分，对于只有一个元素的平凡问题，由于第一个元素==中间元素，不必交换直接返回。
举一个实例，假设对abcdefg进行最好情况的构造。先对原问题进行切割，分成abc和efg。接着处理子问题abc，继续切分，切分成a和c，都是平凡问题，不用处理。返回到子问题abc，交换a(第一个元素/切分元素)和b(中间元素)，得到bac，这样子问题abc已经处理完。处理完abc再处理子问题efg，重复上述步骤，子问题efg的解应该为feg。最后返回到原问题，此时的原问题数组已经变成了bacdfeg。进行最后一次交换，得到最终的结果dacbfeg。
参考代码:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A1%A5%E5%85%85/" />
<meta property="article:published_time" content="2020-10-22T23:08:46+08:00" />
<meta property="article:modified_time" content="2020-10-22T23:08:46+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">快速排序补充</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Oct 22, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      <h2 id="鉴于快速排序的优异性-有必要对快速排序进一步讨论">鉴于快速排序的优异性 有必要对快速排序进一步讨论</h2>
<hr>
<hr>
<h1 id="1循坏停止条件">1.循坏停止条件</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> low<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> high<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>template<span style="color:#f92672">.</span><span style="color:#a6e22e">less</span><span style="color:#f92672">(</span>a<span style="color:#f92672">[++</span>i<span style="color:#f92672">],</span>v<span style="color:#f92672">))</span> <span style="color:#75715e">//a[++i]&gt;v时跳出循坏//从左往右找第一个比v大的元素
</span><span style="color:#75715e"></span>            <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i<span style="color:#f92672">==</span>high<span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>      <span style="color:#75715e">//如果找第一个比v大的元素一直到了数组末尾 则说明数组都比v小
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>template<span style="color:#f92672">.</span><span style="color:#a6e22e">less</span><span style="color:#f92672">(</span>v<span style="color:#f92672">,</span>a<span style="color:#f92672">[--</span>j<span style="color:#f92672">]))</span>
            <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>j<span style="color:#f92672">==</span>low<span style="color:#f92672">)</span>
                    <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>      <span style="color:#75715e">//如果找第一个比v小的元素一直到了数组开头 则说明数组都比v大
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i<span style="color:#f92672">&gt;=</span>j<span style="color:#f92672">)</span>            <span style="color:#75715e">//如果i和j碰到一起 就说明找完了  对数组的划分完成了
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            template<span style="color:#f92672">.</span><span style="color:#a6e22e">exchange</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>i<span style="color:#f92672">,</span>j<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        template<span style="color:#f92672">.</span><span style="color:#a6e22e">exchange</span><span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>low<span style="color:#f92672">,</span>j<span style="color:#f92672">);</span> <span style="color:#75715e">//最后将划分元素给到适当位置j
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> j<span style="color:#f92672">;</span>  <span style="color:#75715e">//j就是划分元素的最终位置
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</code></pre></div><p>这里从左往右找第一个满足 不小于(&gt;=)v 的元素，以及从右往左找第一个满足 不大于(&lt;=)v的元素。
至于为什么有等于情况，是因为如果遇到和切分元素相同的元素时我们继续扫描而不停下，可能运行时间会退化为平方量级。</p>
<p>考虑一个极端的情况：aaaaaaa 这样的话i(从左往右找的)会停留在high,而j(从右往左找的)会停留在low。最后交换low和j（template.exchange(a,low,j);）
这样只使得第一个元素被划分，子数组变成了除第一个元素剩下的元素。每次划分规模减小1，循环n次，每次都O(n)，所以复杂度退化到平方量级。</p>
<p>但如果等于情况也停下，i会停留在第二个a，j会停留在最后一个a，这样交换第一个a（用于划分的）和中间的a（mid）。后来的子问题规模就只有一般，和一般情况复杂度一样。
虽然这样会有一些无用的交换，但是可以避免在重复元素多的时候时间复杂度退化到平方量级。</p>
<hr>
<hr>
<h1 id="2最佳情况">2.最佳情况</h1>
<p>问题：试着编写一段程序来生成使得快速排序表现最佳的数组。</p>
<p>思考：快速排序的最好情况：无重复的元素，且每次切分后的两个子数组的大小最多相差1.
无重复的元素很容易实现，只要控制输入即可。</p>
<p>考察快速排序的过程，先选取第一个元素为切分元素，最后切分结束就把第一个元素和j交换。为了保证每次切分后的两个子数组大小最多差1，就要保证每次划分元素正好是原数组排序后的中间的元素。</p>
<p>反过来，为了找到最好的情况，就相当于是一个逆过程。此时的输入是一个已经有序的序列。每次都将第一个元素与中间元素交换即可。这就相当于partation().</p>
<p>采用分治算法：假如现在a[low..mid-1],a[mid+1..high]都已经是最优解，这时只要将第一个元素与中间元素交换。而为了得到子问题的最优解，以中间元素为界限，将原问题分解为a[low..mid-1],a[mid+1..high]两个子问题，只要保证子问题最优，原问题也最优。继续的递归划分，对于只有一个元素的平凡问题，由于第一个元素==中间元素，不必交换直接返回。</p>
<p>举一个实例，假设对abcdefg进行最好情况的构造。先对原问题进行切割，分成abc和efg。接着处理子问题abc，继续切分，切分成a和c，都是平凡问题，不用处理。返回到子问题abc，交换a(第一个元素/切分元素)和b(中间元素)，得到bac，这样子问题abc已经处理完。处理完abc再处理子问题efg，重复上述步骤，子问题efg的解应该为feg。最后返回到原问题，此时的原问题数组已经变成了bacdfeg。进行最后一次交换，得到最终的结果dacbfeg。</p>
<p>参考代码:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">best</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#75715e">//相当于快排的逆过程,每次都放中间点在第一个元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span>hi <span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">assert</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">]==</span>i<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>hi<span style="color:#f92672">&lt;=</span>lo<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> mid<span style="color:#f92672">=</span>lo<span style="color:#f92672">+(</span>hi<span style="color:#f92672">-</span>lo<span style="color:#f92672">)/</span>2<span style="color:#f92672">;</span>
        best<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> mid<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        best<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> mid<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
        exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>lo<span style="color:#f92672">,</span>mid<span style="color:#f92672">);</span>
        <span style="color:#75715e">//最后交换最中间的,就是因为sort里面第一个交换中间的
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> best<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> <span style="color:#f92672">[]</span> a<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span>n <span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
        <span style="color:#f92672">{</span>
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]=</span>i<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        best<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>n<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> a<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<hr>
<h1 id="3哨兵">3.哨兵</h1>
<p>问题：  对于partation()中从两端检测元素并交换的while循环，由于切分元素就是a[low]，所以从右到左的while循环在比较到a[low]时一定会退出循环，不会发生左侧越界的情况，也就不需要循环里的
if(i==high) break; 这里的a[low]充当了一个哨兵的作用。那么如何修改代码使得从左到右的while循环也不需要检测是否越界呢？</p>
<p>思考：为了省去从左到右循环的判断条件，可以借助另一个while的条件：在处理子数组的时候，由于右子数组都大于左子数组，所以可以将右子数组中最左侧的元素作为从左到右的循环的哨兵。对于初始的情况，可以先做一步预处理：遍历一次数组，将数组的最大的元素先放到a[length-1]，即让最大的元素作为最大的问题的哨兵。</p>
<p>参考代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable <span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span>
	<span style="color:#f92672">{</span>
		StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">shuffle</span><span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
		<span style="color:#66d9ef">int</span> temp<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> 
		<span style="color:#f92672">{</span>
			<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span>a<span style="color:#f92672">[</span>temp<span style="color:#f92672">]))</span>
				temp<span style="color:#f92672">=</span>i<span style="color:#f92672">;</span>
		<span style="color:#f92672">}</span>
		exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> temp<span style="color:#f92672">,</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>  <span style="color:#75715e">//预处理：遍历一次数组，将数组的最大的元素先放到a[length-1]，即让最大的元素作为最大的问题的哨兵。
</span><span style="color:#75715e"></span>		sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>0<span style="color:#f92672">,</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable <span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
	<span style="color:#f92672">{</span>
		<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>hi<span style="color:#f92672">&lt;=</span>lo<span style="color:#f92672">)</span>
			<span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
		<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>partition<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
		sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>lo<span style="color:#f92672">,</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
		sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>j<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span>hi<span style="color:#f92672">);</span>
	<span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span><span style="color:#f92672">(</span>Comparable <span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
	<span style="color:#f92672">{</span>
		<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>lo<span style="color:#f92672">;</span>
		<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>hi<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span>
		Comparable v<span style="color:#f92672">=</span>a<span style="color:#f92672">[</span>lo<span style="color:#f92672">];</span>
		<span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
		<span style="color:#f92672">{</span>
			<span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[++</span>i<span style="color:#f92672">],</span> v<span style="color:#f92672">));</span> <span style="color:#75715e">//切分元素a[low]就是哨兵
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>v<span style="color:#f92672">,</span>a<span style="color:#f92672">[--</span>j<span style="color:#f92672">]));</span>  <span style="color:#75715e">//右子数组的最左侧元素就是哨兵
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>j<span style="color:#f92672">&gt;</span>i<span style="color:#f92672">)</span>
				exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
			<span style="color:#66d9ef">else</span>
				<span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
		<span style="color:#f92672">}</span>
		exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
		<span style="color:#66d9ef">return</span> j<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>
</code></pre></div><hr>
<hr>
<h1 id="改进后的快速排序">改进后的快速排序</h1>
<p>1.三取样切分：切分元素的选取对于快速排序的性能有很大的影响，人们发现将取样大小为3并用大小剧中的元素切分的效果最好。同时，还可以将取样元素放在数组末尾作为“哨兵”来去掉切分中循环的判断条件。但是这样的代价就是要计算3个元素的中位数。</p>
<p>2.切换到快速排序</p>
<p>3.添加哨兵</p>
<p>参考源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ImprovedQuickSort</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> THRESHOLD <span style="color:#f92672">=</span> 8<span style="color:#f92672">;</span>     <span style="color:#75715e">//设定一个数组大小的阈值，小于阈值就切换到快速排序
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">assert</span> isSorted<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>hi <span style="color:#f92672">&lt;=</span> lo<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> hi <span style="color:#f92672">-</span> lo <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;=</span> THRESHOLD<span style="color:#f92672">)</span>           <span style="color:#75715e">//小于阈值就切换到快速排序
</span><span style="color:#75715e"></span>        <span style="color:#f92672">{</span>
            insertionSort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> partition<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> j<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> hi <span style="color:#f92672">-</span> lo <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> medium3<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> lo<span style="color:#f92672">+</span>n<span style="color:#f92672">/</span>2<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>     <span style="color:#75715e">//三取样切分  求a[low],a[mid],a[high]的中间的元素
</span><span style="color:#75715e"></span>        exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> m<span style="color:#f92672">,</span> lo<span style="color:#f92672">);</span>                         <span style="color:#75715e">//以三个元素的中位数作为切分元素最好
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> hi<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span>
        Comparable v <span style="color:#f92672">=</span> a<span style="color:#f92672">[</span>lo<span style="color:#f92672">];</span>

        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
		<span style="color:#f92672">{</span>
			<span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[++</span>i<span style="color:#f92672">],</span> v<span style="color:#f92672">))</span>
			<span style="color:#f92672">{</span>
				<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i<span style="color:#f92672">==</span>hi<span style="color:#f92672">)</span>           <span style="color:#75715e">// a[lo]等于最大的元素值
</span><span style="color:#75715e"></span>				<span style="color:#f92672">{</span>
					<span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
				<span style="color:#f92672">}</span>
			<span style="color:#f92672">}</span>
			<span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> a<span style="color:#f92672">[--</span>j<span style="color:#f92672">]))</span>
			<span style="color:#f92672">{</span>
				<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>j<span style="color:#f92672">==</span>lo<span style="color:#f92672">)</span>        <span style="color:#75715e">// a[lo]等于最小的元素值
</span><span style="color:#75715e"></span>				<span style="color:#f92672">{</span>
					<span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
				<span style="color:#f92672">}</span>
			<span style="color:#f92672">}</span>
			<span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i<span style="color:#f92672">&gt;=</span>j<span style="color:#f92672">)</span>
			<span style="color:#f92672">{</span>
				<span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
			<span style="color:#f92672">}</span>
			exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> i<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
		<span style="color:#f92672">}</span>
		exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>        <span style="color:#75715e">// 将切分元素v放置到a[j]上
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> j<span style="color:#f92672">;</span>
	<span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertionSort</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> lo<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;=</span> hi<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span> j <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">&amp;&amp;</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">-</span>1<span style="color:#f92672">]);</span> j<span style="color:#f92672">--)</span>
            <span style="color:#f92672">{</span>
                exch<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> j<span style="color:#f92672">,</span> j<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">medium3</span><span style="color:#f92672">(</span>Comparable<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> k<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">?</span>
                <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>j<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">])</span> <span style="color:#f92672">?</span>  j <span style="color:#f92672">:</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>k<span style="color:#f92672">])</span> <span style="color:#f92672">?</span> k <span style="color:#f92672">:</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">:</span>
                <span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>k<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>j<span style="color:#f92672">])</span> <span style="color:#f92672">?</span>  j <span style="color:#f92672">:</span> less<span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>k<span style="color:#f92672">],</span> a<span style="color:#f92672">[</span>i<span style="color:#f92672">])</span> <span style="color:#f92672">?</span> k <span style="color:#f92672">:</span> i<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<hr>
<h1 id="非递归的快速排序">非递归的快速排序</h1>
<p>递归的代码虽然有助于我们代码上的阅读，但是非递归的实现方式往往会更加好，因为这样可以预防 StackOverflow 异常。
那么如何将快速排序进行非递归的实现呢？</p>
<p>想法：由于递归本身就是一个栈结构，即递归栈，所以我们可以引入栈结构来实现非递归的快速排序。快速排序多次调用partation(),当子问题规模降低到1时不用处理。partition() 方法中需要传入参数 low 和 high，那么我们就只需要在栈中保留 low 和 high 的信息即可。当high&gt;low时，计算mid=(low+high)/2,并将两个子问题入栈，即push(low,mid-1),push(mid+1,high)。当high&lt;=low时，即为平凡问题，已经有序。且栈正好有FILO的特性，正好保证了先将子数组排好序，当子数组有序了，那么原数组也有序了。</p>
<p>参考源码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.Stack<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NoRecursionType</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>Comparable <span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>a<span style="color:#f92672">==</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">&lt;=</span>0<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> loStack<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> hiStack<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#66d9ef">int</span> lo<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> hi<span style="color:#f92672">=</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> pos<span style="color:#f92672">;</span>

        loStack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>lo<span style="color:#f92672">);</span>
        hiStack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>hi<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(!</span>loStack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span>       <span style="color:#75715e">//对整个数组都排序
</span><span style="color:#75715e"></span>        <span style="color:#f92672">{</span>
            lo<span style="color:#f92672">=</span>loStack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            hi<span style="color:#f92672">=</span>hiStack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            pos<span style="color:#f92672">=</span>partition<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> lo<span style="color:#f92672">,</span> hi<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>lo<span style="color:#f92672">&lt;</span>pos<span style="color:#f92672">-</span>1<span style="color:#f92672">)</span>                <span style="color:#75715e">//只有一个元素的时候就停止递归了
</span><span style="color:#75715e"></span>            <span style="color:#f92672">{</span>
                loStack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>lo<span style="color:#f92672">);</span>       <span style="color:#75715e">//左子问题入栈
</span><span style="color:#75715e"></span>                hiStack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>pos<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>hi<span style="color:#f92672">&gt;</span>pos<span style="color:#f92672">+</span>1<span style="color:#f92672">)</span>
            <span style="color:#f92672">{</span>                           <span style="color:#75715e">//右子问题入栈
</span><span style="color:#75715e"></span>                loStack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>pos<span style="color:#f92672">+</span>1<span style="color:#f92672">);</span>
                hiStack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>hi<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span><span style="color:#f92672">(</span>Comparable <span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> lo<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> hi<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>lo<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>hi<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span>
        Comparable v<span style="color:#f92672">=</span>a<span style="color:#f92672">[</span>lo<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>a<span style="color:#f92672">[++</span>i<span style="color:#f92672">],</span>v<span style="color:#f92672">))</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i<span style="color:#f92672">==</span>hi<span style="color:#f92672">)</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>less<span style="color:#f92672">(</span>v<span style="color:#f92672">,</span>a<span style="color:#f92672">[--</span>j<span style="color:#f92672">]))</span> <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>j<span style="color:#f92672">==</span>lo<span style="color:#f92672">)</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i<span style="color:#f92672">&gt;=</span>j<span style="color:#f92672">)</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            exchange<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>i<span style="color:#f92672">,</span>j<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        exchange<span style="color:#f92672">(</span>a<span style="color:#f92672">,</span>lo<span style="color:#f92672">,</span>j<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> j<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>Comparable <span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span>a<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
        <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>a<span style="color:#f92672">[</span>i<span style="color:#f92672">]+</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> N<span style="color:#f92672">=</span>10<span style="color:#f92672">;</span>
        Integer <span style="color:#f92672">[]</span> a<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">[</span>10<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span>N <span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span>
        <span style="color:#f92672">{</span>
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]=</span>StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">uniform</span><span style="color:#f92672">(</span>20<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        print<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
        sort<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
        print<span style="color:#f92672">(</span>a<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<hr>
<h1 id="螺丝与螺帽问题">螺丝与螺帽问题</h1>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
