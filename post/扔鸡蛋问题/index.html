<!doctype html>
<html lang="en-us">
  <head>
    <title>扔鸡蛋问题 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="扔鸡蛋问题"/>
<meta name="twitter:description" content="问题描述 问题1：有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层？
问题2：更一般的：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &lt;= F &lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？
问题1 明确一个想法：只有一个鸡蛋时，只能一层层的测试。
想法1 对于第一个问题，最简单的想法就是二分查找：先从50层往下扔，碎了的话问题就退化成1个鸡蛋测试1-50层。那么这时只能从第一次开始逐层测试，最坏情况一直测试到第49层。如果没有碎，那还有两个鸡蛋，继续在50-100间进行二分查找，即从75层往下扔。又分为碎和没碎的情况。碎了就退化成为线性测试，没碎就一直二分查找。这个想法最坏的情况是第一次测试在50层碎了，然后一直从第一层测试到第49层，需要进行50次测试。
想法2 二分查找的想法就是对半减小问题的规模，但是对于这题，问题的关键就在于试图减小问题规模的步幅太大。第一次就试图将问题规模减小为原来的一半。这使得对于最坏情况下需要进行N/2次测试。 若采用平凡根，或者斐波那契数来减小规模，可能会有一定的提高。 对于斐波那契数(1,1,2,3,5,8,13,21,34,55,89&hellip;),可以第一次在第1层扔，若鸡蛋不碎，就继续按照斐波那契数进行测试。最坏情况下在第55层没有碎，在89层碎，然后只能从56&ndash;88层逐层测试，一直需要测试到第88层才能得到答案。总得次数为9&#43;23=32次。 对于平方根数，第一次在第10层扔，没碎的话每次加上10继续，若碎了改为线性测试。最坏情况下第90层没碎，然后线性测试到100层。总次数为9&#43;10=19次。
想法3 想法2的两个情况对于想法1有改进，减小了最坏情况下问题的规模，但是这种规模是“不均衡的”。比较好的情况是：若确定一个子问题规模需要的实验次数多，那么子问题的规模就需要小。即把最坏情况平摊到每个子问题中。
想法3：假设问题存在最优解，使得最大测试次数为x，那么在第x层扔就会得到最优解。
简单证明：假设第一次扔在第x&#43;1层，如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。这样一来，我们总共尝试了x&#43;1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x&#43;1层。 假设第二次扔在第x-1层，鸡蛋没有碎，浪费了一次测试，继续在2(x-1)层测试，那么确定子问题测试的次数&#43;对子问题线性测试的次数也一定大于x。 那么第x层就是最好的解。  如果第一次扔鸡蛋没有碎，那么已经消耗了一次测试，问题就变为两个鸡蛋在100-x的楼往下扔，最好情况为x-1次。那么第二次的子问题规模应该弥补第一次没用的测试（实现将最坏情况均分到每个子问题），即第二次应该在x&#43;(x-1)层。
以此类推，得到一个方程 x&#43;(x-1)&#43;(x-2)&#43;&hellip;&#43;1=100.解之得，x=14;
所以，在第一个鸡蛋没有碎的情况下，楼层依次为14,27,39,50,60,69,77,84,90,95,99,100。且最坏情况不会超过14次。
问题1的总结 对于特定的问题：2个鸡蛋，100层楼。我们可以采取特定的方法。对于3个鸡蛋，那么我们可以用两个鸡蛋来缩小子问题的规模(采用2次二分查询/斐波那契/平方数)。但这不具有一般性。
 问题2 这题实际是一个动态规划1的问题。给定K个鸡蛋，N层楼。记作f(K,N)
若一个鸡蛋在第i层碎了，则问题转化为f(K-1,N-i).
若鸡蛋在第i层没碎，则问题转化为f(K,N-i).
  问题留着以后动态规划、分治算法的专题时再来研究 &#x21a9;&#xfe0e;
   "/>

    <meta property="og:title" content="扔鸡蛋问题" />
<meta property="og:description" content="问题描述 问题1：有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层？
问题2：更一般的：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &lt;= F &lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？
问题1 明确一个想法：只有一个鸡蛋时，只能一层层的测试。
想法1 对于第一个问题，最简单的想法就是二分查找：先从50层往下扔，碎了的话问题就退化成1个鸡蛋测试1-50层。那么这时只能从第一次开始逐层测试，最坏情况一直测试到第49层。如果没有碎，那还有两个鸡蛋，继续在50-100间进行二分查找，即从75层往下扔。又分为碎和没碎的情况。碎了就退化成为线性测试，没碎就一直二分查找。这个想法最坏的情况是第一次测试在50层碎了，然后一直从第一层测试到第49层，需要进行50次测试。
想法2 二分查找的想法就是对半减小问题的规模，但是对于这题，问题的关键就在于试图减小问题规模的步幅太大。第一次就试图将问题规模减小为原来的一半。这使得对于最坏情况下需要进行N/2次测试。 若采用平凡根，或者斐波那契数来减小规模，可能会有一定的提高。 对于斐波那契数(1,1,2,3,5,8,13,21,34,55,89&hellip;),可以第一次在第1层扔，若鸡蛋不碎，就继续按照斐波那契数进行测试。最坏情况下在第55层没有碎，在89层碎，然后只能从56&ndash;88层逐层测试，一直需要测试到第88层才能得到答案。总得次数为9&#43;23=32次。 对于平方根数，第一次在第10层扔，没碎的话每次加上10继续，若碎了改为线性测试。最坏情况下第90层没碎，然后线性测试到100层。总次数为9&#43;10=19次。
想法3 想法2的两个情况对于想法1有改进，减小了最坏情况下问题的规模，但是这种规模是“不均衡的”。比较好的情况是：若确定一个子问题规模需要的实验次数多，那么子问题的规模就需要小。即把最坏情况平摊到每个子问题中。
想法3：假设问题存在最优解，使得最大测试次数为x，那么在第x层扔就会得到最优解。
简单证明：假设第一次扔在第x&#43;1层，如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。这样一来，我们总共尝试了x&#43;1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x&#43;1层。 假设第二次扔在第x-1层，鸡蛋没有碎，浪费了一次测试，继续在2(x-1)层测试，那么确定子问题测试的次数&#43;对子问题线性测试的次数也一定大于x。 那么第x层就是最好的解。  如果第一次扔鸡蛋没有碎，那么已经消耗了一次测试，问题就变为两个鸡蛋在100-x的楼往下扔，最好情况为x-1次。那么第二次的子问题规模应该弥补第一次没用的测试（实现将最坏情况均分到每个子问题），即第二次应该在x&#43;(x-1)层。
以此类推，得到一个方程 x&#43;(x-1)&#43;(x-2)&#43;&hellip;&#43;1=100.解之得，x=14;
所以，在第一个鸡蛋没有碎的情况下，楼层依次为14,27,39,50,60,69,77,84,90,95,99,100。且最坏情况不会超过14次。
问题1的总结 对于特定的问题：2个鸡蛋，100层楼。我们可以采取特定的方法。对于3个鸡蛋，那么我们可以用两个鸡蛋来缩小子问题的规模(采用2次二分查询/斐波那契/平方数)。但这不具有一般性。
 问题2 这题实际是一个动态规划1的问题。给定K个鸡蛋，N层楼。记作f(K,N)
若一个鸡蛋在第i层碎了，则问题转化为f(K-1,N-i).
若鸡蛋在第i层没碎，则问题转化为f(K,N-i).
  问题留着以后动态规划、分治算法的专题时再来研究 &#x21a9;&#xfe0e;
   " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/" />
<meta property="article:published_time" content="2020-10-31T22:51:50+08:00" />
<meta property="article:modified_time" content="2020-10-31T22:51:50+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">扔鸡蛋问题</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Oct 31, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="问题描述">问题描述</h1>
<p>问题1：有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层？</p>
<p>问题2：更一般的：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &lt;= F &lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？</p>
<h1 id="问题1">问题1</h1>
<p>明确一个想法：只有一个鸡蛋时，只能一层层的测试。</p>
<h2 id="想法1">想法1</h2>
<p>对于第一个问题，最简单的想法就是二分查找：先从50层往下扔，碎了的话问题就退化成1个鸡蛋测试1-50层。那么这时只能从第一次开始逐层测试，最坏情况一直测试到第49层。如果没有碎，那还有两个鸡蛋，继续在50-100间进行二分查找，即从75层往下扔。又分为碎和没碎的情况。碎了就退化成为线性测试，没碎就一直二分查找。这个想法最坏的情况是第一次测试在50层碎了，然后一直从第一层测试到第49层，需要进行50次测试。</p>
<h2 id="想法2">想法2</h2>
<p>二分查找的想法就是对半减小问题的规模，<strong>但是对于这题，问题的关键就在于试图减小问题规模的步幅太大。第一次就试图将问题规模减小为原来的一半。这使得对于最坏情况下需要进行N/2次测试。</strong>  <br>
若采用平凡根，或者斐波那契数来减小规模，可能会有一定的提高。  <br>
对于斐波那契数(1,1,2,3,5,8,13,21,34,55,89&hellip;),可以第一次在第1层扔，若鸡蛋不碎，就继续按照斐波那契数进行测试。最坏情况下在第55层没有碎，在89层碎，然后只能从56&ndash;88层逐层测试，一直需要测试到第88层才能得到答案。总得次数为9+23=32次。
对于平方根数，第一次在第10层扔，没碎的话每次加上10继续，若碎了改为线性测试。最坏情况下第90层没碎，然后线性测试到100层。总次数为9+10=19次。</p>
<h2 id="想法3">想法3</h2>
<p>想法2的两个情况对于想法1有改进，减小了最坏情况下问题的规模，<strong>但是这种规模是“不均衡的”。比较好的情况是：若确定一个子问题规模需要的实验次数多，那么子问题的规模就需要小。即把最坏情况平摊到每个子问题中。</strong><br>
想法3：<strong>假设问题存在最优解，使得最大测试次数为x，那么在第x层扔就会得到最优解。</strong></p>
<pre><code>简单证明：假设第一次扔在第x+1层，如果第一个鸡蛋碎了，那么第二个鸡蛋只能从第1层开始一层一层扔，一直扔到第x层。这样一来，我们总共尝试了x+1次，和假设尝试x次相悖。由此可见，第一次扔的楼层必须小于x+1层。
假设第二次扔在第x-1层，鸡蛋没有碎，浪费了一次测试，继续在2(x-1)层测试，那么确定子问题测试的次数+对子问题线性测试的次数也一定大于x。
那么第x层就是最好的解。
</code></pre>
<p>如果第一次扔鸡蛋没有碎，那么已经消耗了一次测试，问题就变为两个鸡蛋在100-x的楼往下扔，最好情况为x-1次。那么第二次的子问题规模应该弥补第一次没用的测试（实现将最坏情况均分到每个子问题），即第二次应该在x+(x-1)层。<br>
以此类推，得到一个方程 x+(x-1)+(x-2)+&hellip;+1=100.解之得，x=14;<br>
所以，在第一个鸡蛋没有碎的情况下，楼层依次为14,27,39,50,60,69,77,84,90,95,99,100。且最坏情况不会超过14次。</p>
<h1 id="问题1的总结">问题1的总结</h1>
<p>对于特定的问题：2个鸡蛋，100层楼。我们可以采取特定的方法。对于3个鸡蛋，那么我们可以用两个鸡蛋来缩小子问题的规模(采用2次二分查询/斐波那契/平方数)。但这不具有一般性。</p>
<hr>
<h1 id="问题2">问题2</h1>
<p>这题实际是一个动态规划<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>的问题。给定K个鸡蛋，N层楼。记作f(K,N)<br>
若一个鸡蛋在第i层碎了，则问题转化为f(K-1,N-i).<br>
若鸡蛋在第i层没碎，则问题转化为f(K,N-i).</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>问题留着以后动态规划、分治算法的专题时再来研究 <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
