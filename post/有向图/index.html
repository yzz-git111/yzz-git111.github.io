<!doctype html>
<html lang="en-us">
  <head>
    <title>有向图 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="有向图"/>
<meta name="twitter:description" content="引入 在生活中有这样的一些例子：
 食物链中，存在捕食者和被捕食者。顶点代表物种，边代表捕食关系。 计算机与服务器的连接。顶点代表不同的计算机，边代表连接被连接关系……  对于这些关系的抽象，用无向图将顶点连接起来并不能有效的表示内在的关系。我们需要用一种单向边来连接两个顶点。 有向图和无向图的区别在于无向图的边是双向的，而有向图的边代表了起点与终点的一种特定的关系。
约定：每个顶点都能达到它自己。 简单有向环是一条起点和终点相同且不含有重复的顶点和边的环。路径或者环的长度即为其中所包含的边数。
 数据结构 有向图和无向图类似，都可以用邻接表、邻接矩阵等数据结构表示。唯一不同的就是有向图的边都是由起点指向终点的，这也就是说，在邻接表表示的有向图中每条边只会出现以此，在邻接矩阵表示的有向图中邻接矩阵不是对称矩阵。
邻接矩阵
public class AdjMatrixDigraph { private int V; private int E; private boolean[][] adj; //V*V的boolean型的矩阵 } public AdjMatrixDigraph(int V) { //边为空的构造方法  if (V &lt; 0) throw new RuntimeException(&#34;Number of vertices must be nonnegative&#34;); this.V = V; this.E = 0; this.adj = new boolean[V][V]; } public AdjMatrixDigraph(int V, int E) { //随机E条边的构造方法  this(V); if (E &lt; 0) throw new RuntimeException(&#34;Number of edges must be nonnegative&#34;); if (E &gt; V*V) throw new RuntimeException(&#34;Too many edges&#34;); while (this."/>

    <meta property="og:title" content="有向图" />
<meta property="og:description" content="引入 在生活中有这样的一些例子：
 食物链中，存在捕食者和被捕食者。顶点代表物种，边代表捕食关系。 计算机与服务器的连接。顶点代表不同的计算机，边代表连接被连接关系……  对于这些关系的抽象，用无向图将顶点连接起来并不能有效的表示内在的关系。我们需要用一种单向边来连接两个顶点。 有向图和无向图的区别在于无向图的边是双向的，而有向图的边代表了起点与终点的一种特定的关系。
约定：每个顶点都能达到它自己。 简单有向环是一条起点和终点相同且不含有重复的顶点和边的环。路径或者环的长度即为其中所包含的边数。
 数据结构 有向图和无向图类似，都可以用邻接表、邻接矩阵等数据结构表示。唯一不同的就是有向图的边都是由起点指向终点的，这也就是说，在邻接表表示的有向图中每条边只会出现以此，在邻接矩阵表示的有向图中邻接矩阵不是对称矩阵。
邻接矩阵
public class AdjMatrixDigraph { private int V; private int E; private boolean[][] adj; //V*V的boolean型的矩阵 } public AdjMatrixDigraph(int V) { //边为空的构造方法  if (V &lt; 0) throw new RuntimeException(&#34;Number of vertices must be nonnegative&#34;); this.V = V; this.E = 0; this.adj = new boolean[V][V]; } public AdjMatrixDigraph(int V, int E) { //随机E条边的构造方法  this(V); if (E &lt; 0) throw new RuntimeException(&#34;Number of edges must be nonnegative&#34;); if (E &gt; V*V) throw new RuntimeException(&#34;Too many edges&#34;); while (this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E6%9C%89%E5%90%91%E5%9B%BE/" />
<meta property="article:published_time" content="2020-11-17T16:06:47+08:00" />
<meta property="article:modified_time" content="2020-11-17T16:06:47+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">有向图</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 17, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          8 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="引入">引入</h1>
<p>在生活中有这样的一些例子：</p>
<ul>
<li>食物链中，存在捕食者和被捕食者。顶点代表物种，边代表捕食关系。</li>
<li>计算机与服务器的连接。顶点代表不同的计算机，边代表连接被连接关系……</li>
</ul>
<p>对于这些关系的抽象，用无向图将顶点连接起来并不能有效的表示内在的关系。我们需要用一种单向边来连接两个顶点。  <br>
有向图和无向图的区别在于无向图的边是双向的，而有向图的边代表了起点与终点的一种特定的关系。</p>
<p>约定：每个顶点都能达到它自己。 <br>
简单有向环是一条起点和终点相同且不含有重复的顶点和边的环。路径或者环的长度即为其中所包含的边数。</p>
<p><img src="/chapter4/4.2.1adjacency-lists.png" alt=""></p>
<hr>
<h1 id="数据结构">数据结构</h1>
<p>有向图和无向图类似，都可以用邻接表、邻接矩阵等数据结构表示。唯一不同的就是有向图的边都是由起点指向终点的，这也就是说，在邻接表表示的有向图中每条边只会出现以此，在邻接矩阵表示的有向图中邻接矩阵不是对称矩阵。</p>
<p>邻接矩阵</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AdjMatrixDigraph</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> V<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> E<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[][]</span> adj<span style="color:#f92672">;</span>    <span style="color:#75715e">//V*V的boolean型的矩阵
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AdjMatrixDigraph</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> V<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//边为空的构造方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>V <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Number of vertices must be nonnegative&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">V</span> <span style="color:#f92672">=</span> V<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">E</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>V<span style="color:#f92672">][</span>V<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AdjMatrixDigraph</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> V<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> E<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//随机E条边的构造方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">(</span>V<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>E <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Number of edges must be nonnegative&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>E <span style="color:#f92672">&gt;</span> V<span style="color:#f92672">*</span>V<span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Too many edges&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">E</span> <span style="color:#f92672">!=</span> E<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">uniform</span><span style="color:#f92672">(</span>V<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> StdRandom<span style="color:#f92672">.</span><span style="color:#a6e22e">uniform</span><span style="color:#f92672">(</span>V<span style="color:#f92672">);</span>
        addEdge<span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>邻接表<br>
这里多了一个数组存储每个边的入度,有新的边插入时终点的入读加一</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Digraph</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> V<span style="color:#f92672">;</span>           <span style="color:#75715e">// 有向图中顶点数目 final修饰，不对顶点进行操作
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> E<span style="color:#f92672">;</span>                 <span style="color:#75715e">// 有向图中有向边的数目
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[]</span> adj<span style="color:#f92672">;</span>    <span style="color:#75715e">// 每个顶点都用一个Bag(类似于链表，但是不支持删除操作)存放当前顶点指出的边
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> indegree<span style="color:#f92672">;</span>        <span style="color:#75715e">// 统计每个顶点的入度
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p><img src="/chapter4/4.2.1adjacency-lists.png" alt=""></p>
<p>以邻接表为例，给出几个常用的处理标准图(顶点默认为数组的索引，即用0~V-1来代表V个顶点)的方法:</p>
<ul>
<li>构造方法:（可以重载很多构造方法，最基本的就是构造V个顶点，0条边的图；还有通过输入V，E和边来构造；还有传递一个已有的图来进行构造。后两种比较常用）<br>
与无向图的构造方法类似，不过这里的addEdge只调用了一次</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Digraph</span><span style="color:#f92672">(</span>Scanner in<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//通过输入V，E和边来构造
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>in <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">V</span> <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>  <span style="color:#75715e">//输入顶点数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>V <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;number of vertices in a Digraph must be nonnegative&#34;</span><span style="color:#f92672">);</span>
        indegree <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
        adj <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[])</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            adj<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">int</span> E <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>   <span style="color:#75715e">//输入边数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>E <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;number of edges in a Digraph must be nonnegative&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> E<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> w <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            addEdge<span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>  <span style="color:#75715e">//输入边的信息  v-&gt;w
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>NoSuchElementException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;invalid input format in Digraph constructor&#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Digraph</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>G <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;argument is null&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">//传递一个已有的图来进行构造
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">V</span> <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> 
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">E</span> <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">E</span><span style="color:#f92672">();</span> <span style="color:#75715e">//获取图G的顶点/边数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>V <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Number of vertices in a Digraph must be nonnegative&#34;</span><span style="color:#f92672">);</span>

    indegree <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span> <span style="color:#75715e">//获取图G的每个顶点的入度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">indegree</span><span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">indegree</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>

    adj <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[])</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">[</span>V<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        adj<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//为了保证顺序和图G一致，要逆序插入边
</span><span style="color:#75715e"></span>        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> reverse <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
            reverse<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> reverse<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            adj<span style="color:#f92672">[</span>v<span style="color:#f92672">].</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>插入新的边</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
    validateVertex<span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>  <span style="color:#75715e">//判断顶点是否合法
</span><span style="color:#75715e"></span>    adj<span style="color:#f92672">[</span>v<span style="color:#f92672">].</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>     <span style="color:#75715e">//v-&gt;w的边，插入存储由顶点v指出的边的数据结构中
</span><span style="color:#75715e"></span>    indegree<span style="color:#f92672">[</span>w<span style="color:#f92672">]++;</span>  <span style="color:#75715e">//终点的入度加1
</span><span style="color:#75715e"></span>    E<span style="color:#f92672">++;</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>返回顶点v指出的所有的边</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> adj<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>  <span style="color:#75715e">//adj是Bag类的对象，在Bag类中实现了Interable接口，可以直接返回
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>返回一个顶点的出度和入度信息</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">outdegree</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//由于出度没有记录，所以返回存储v的边的数据结构的大小
</span><span style="color:#75715e"></span>    validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> adj<span style="color:#f92672">[</span>v<span style="color:#f92672">].</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>   
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">indegree</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//返回记录入度的数组对应的元素
</span><span style="color:#75715e"></span>    validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> indegree<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>逆向图(即将所有的边的指向反过来) <br>
对处理其他问题有利</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> Digraph <span style="color:#a6e22e">reverse</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    Digraph reverse <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Digraph<span style="color:#f92672">(</span>V<span style="color:#f92672">);</span>   <span style="color:#75715e">//新new一个Digraph的对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> V<span style="color:#f92672">;</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> adj<span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//本来是v-&gt;w 现在改为w-&gt;v
</span><span style="color:#75715e"></span>            reverse<span style="color:#f92672">.</span><span style="color:#a6e22e">addEdge</span><span style="color:#f92672">(</span>w<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> reverse<span style="color:#f92672">;</span> <span style="color:#75715e">//返回逆向后的图
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><hr>
<h1 id="有向图的可达性">有向图的可达性</h1>
<p>在无向图中，若两个顶点间有路径，就表示这两个顶点是连通的。利用深度优先搜索算法可以很好的解决。</p>
<p>在有向图中，若v-&gt;w有路径，则w对于v是可达的。但是v是否对于w可达不确定。
在有向图这样的可达性问题：</p>
<ul>
<li><strong>单点可达性：给定有向图的一个起点s，是否存在一条从s到达给定顶点v的有向路径</strong>？</li>
<li><strong>多点可达性：给定有向图的多个顶点的集合，是否存在一条从集合中任意顶点到达给定顶点v的有向路径</strong>？</li>
</ul>
<p>对于有向图的可达性问题，用深度优先搜索算法也能够很好的解决。</p>
<p>时间复杂度O(E + V)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DirectedDFS</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>  <span style="color:#75715e">// 标记数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>         <span style="color:#75715e">// 对于给定的起点所有可以达到的顶点的数目
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DirectedDFS</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//单点s所有可达的点
</span><span style="color:#75715e"></span>        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        validateVertex<span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DirectedDFS</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> sources<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//给定的sources集合的多点可达
</span><span style="color:#75715e"></span>        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        validateVertices<span style="color:#f92672">(</span>sources<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> sources<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        count<span style="color:#f92672">++;</span>    <span style="color:#75715e">//可达点数目加一
</span><span style="color:#75715e"></span>        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">marked</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> marked<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 所有可达点的数目
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> count<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">validateVertex</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> V <span style="color:#f92672">=</span> marked<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> v <span style="color:#f92672">&gt;=</span> V<span style="color:#f92672">)</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;vertex &#34;</span> <span style="color:#f92672">+</span> v <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is not between 0 and &#34;</span> <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>V<span style="color:#f92672">-</span>1<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Scanner scanner <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Scanner<span style="color:#f92672">(</span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">in</span><span style="color:#f92672">);</span>
        Digraph G <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Digraph<span style="color:#f92672">(</span>scanner<span style="color:#f92672">);</span>   <span style="color:#75715e">//构造有向图
</span><span style="color:#75715e"></span>
        Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> sources <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bag<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>scanner<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNextInt</span><span style="color:#f92672">())</span>
        <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>scanner<span style="color:#f92672">.</span><span style="color:#a6e22e">nextInt</span><span style="color:#f92672">();</span>
            sources<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span> <span style="color:#75715e">//给定的一个起点s或者一个集合sources
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>

        DirectedDFS dfs <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedDFS<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> sources<span style="color:#f92672">);</span>

        <span style="color:#75715e">//输出所有可达的结点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>dfs<span style="color:#f92672">.</span><span style="color:#a6e22e">marked</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> StdOut<span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>v <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        StdOut<span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><p>这个算法利用深度优先搜索算法，从某个起点/某些起点开始。最后所有标记数组为true的元素就是从给定起点可达的点。另外，算法还实现了通过一个count变量，记录可达顶点的数目，必要时可以调用。</p>
<p><img src="/chapter4/4.2.3.jpg" alt=""></p>
<p>补充一点！<br>
多点可达性重要的应用就是 <em><strong>典型的内存管理系统中</strong></em>，以及 <em><strong>Java垃圾收集</strong></em> 的实现。</p>
<p>内存中很多都不是连续的空间而是通过指针将一块块离散的小空间连接起来的。 <br>
抽象成一幅有向图，一个顶点表示一个对象，一条边则表示一个对象对另一个对象的引用。<br>
对于Java的垃圾收集机制，由于在程序执行的任何时候都有某些对象可以被直接访问的，而不能通过这些对象访问到的所有对象都应该被回收。</p>
<p>系统周期性的运行一个 <em><strong>类似深度优先搜索的有向图可达性算法</strong></em> 来标记所有可以被访问到的对象，然后 <em><strong>回收没有被标记的对象</strong></em>。(每个对象保存一个位作为标记位)</p>
<hr>
<h1 id="有向图的路径">有向图的路径</h1>
<p>刚才解决了是否可达问题，现在考虑对于可达路径，将这条路径表示出来。</p>
<ul>
<li><strong>单点有向路径：给定一个起点s，若s到v有路径，请找出这条路径</strong></li>
<li><strong>单点最短有向路径：找出s到v的最短的有向路径</strong></li>
</ul>
<p>对于是否有路径问题，只需要看标记数组的v是否被标记即可。<br>
而找到这条路径，就需要一个数据结构来保存路径上的各个顶点。</p>
<p>类似于无向图的单点路径/单点最短路径问题，需要一个edgeTo[]数组，存储路径上最后一个顶点。然后从终点v逆向查找路径。如果输出这条路径，还需要一个栈来将路径顺序调整一下。</p>
<p>时间复杂度O(E + V)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DepthFirstDirectedPaths</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>  <span style="color:#75715e">// 标记数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>      <span style="color:#75715e">// 保存路径路径上的最后一个顶点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">;</span>       <span style="color:#75715e">// 起点s
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DepthFirstDirectedPaths</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">s</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">;</span>
        validateVertex<span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>  <span style="color:#75715e">//将v作为新标记的结点的上一个结点存储
</span><span style="color:#75715e"></span>                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasPathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> marked<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>   <span style="color:#75715e">//判断s-&gt;v是否可达
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pathTo</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>hasPathTo<span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span> x <span style="color:#f92672">!=</span> s<span style="color:#f92672">;</span> x <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>x<span style="color:#f92672">])</span>
            path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span>
        path<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> path<span style="color:#f92672">;</span>    <span style="color:#75715e">//利用一个栈将逆序查找的路径顺序变正
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>对于寻找最短的路径，就需要用广度优先搜索算法，先在路径长度为1的所有可达顶点找终点v；找不到再在路径长度为2的可达顶点中找……  <br>
广度优先搜索算法需要用到一个队列。</p>
<p>时间复杂度O(E + V)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BreadthFirstDirectedPaths</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> INFINITY <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>  <span style="color:#75715e">// 标记数组
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>      <span style="color:#75715e">// 记录路径上的最后一个结点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> distTo<span style="color:#f92672">;</span>      <span style="color:#75715e">// 记录路径长度
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BreadthFirstDirectedPaths</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> sources<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        distTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> INFINITY<span style="color:#f92672">;</span>
        validateVertices<span style="color:#f92672">(</span>sources<span style="color:#f92672">);</span>
        bfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> sources<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfs</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> sources<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> q <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> s <span style="color:#f92672">:</span> sources<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            marked<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
            distTo<span style="color:#f92672">[</span>s<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>s<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>q<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">dequeue</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                    edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
                    distTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> distTo<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
                    marked<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                    q<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><hr>
<h1 id="环和有向无环图">环和有向无环图</h1>
<p>原则上来说，一幅有向图可能含有大量的环；而在实际应用中我们只会关注一小部分，比如找到这幅有向图中是否有环。</p>
<ul>
<li><strong>有向环检测：给定的有向图中包含有向环吗？</strong></li>
</ul>
<p>若从起点可以到达所有其他顶点，对起点开始 <em><strong>深度优先搜索算法</strong></em>。同时将正在dfs递归调用访问的顶点用一个数据结构进行保存。若在遍历过程中对某个顶点w继续深度搜索时，它指出的边指向的点v已经被标记了且在这个数据结构中，说明有环。</p>
<p>证明：设w是路径上的某个顶点。一旦我们找到了一条有向边v-&gt;w且w以及存在这个数据结构中了，那么我们就找到了一个环。因为我们找到的是一条w-&gt;v的有向路径，而v-&gt;w刚好补全了这个环。反过来，没有这样的一个边，就说明这幅有向图是没有环的。</p>
<p><img src="/chapter4/4.2.9.jpg" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DirectedCycle</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>        
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> edgeTo<span style="color:#f92672">;</span>     <span style="color:#75715e">//用于返回环
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> onStack<span style="color:#f92672">;</span>       <span style="color:#75715e">// 用标记来表示是否在已经遍历过的路径中
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> cycle<span style="color:#f92672">;</span>    <span style="color:#75715e">// 将环逆序然后正序输出
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DirectedCycle</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        onStack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        edgeTo  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> cycle <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        onStack<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>  <span style="color:#75715e">//从v开始遍历，v先被记录在路径中
</span><span style="color:#75715e"></span>        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>   <span style="color:#75715e">//标记
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 找到了环
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cycle <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 遍历过程中的v的邻接点w没被标记
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                edgeTo<span style="color:#f92672">[</span>w<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>  <span style="color:#75715e">//记录路径上的最后一个顶点
</span><span style="color:#75715e"></span>                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 遍历过程中的v的邻接点w已经在记录的路径中了
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>onStack<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                cycle <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span> x <span style="color:#f92672">!=</span> w<span style="color:#f92672">;</span> x <span style="color:#f92672">=</span> edgeTo<span style="color:#f92672">[</span>x<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                    cycle<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
                cycle<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
                cycle<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        onStack<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>  <span style="color:#75715e">// 若以v为起点的子图没有环 就将它从路径中剔除
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
 
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasCycle</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> cycle <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">cycle</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> cycle<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>我自己的想法是使用一个系统的链表LinkedList来保存从起点开始遍历的所有顶点。然后调用.contains()方法来判断w是否在这个链表中。若在链表中，就将标志变量hasCycle置为true。但是这个的缺陷很多。比如只能判断有向图是否有环，但是不能返回这个环具体的顶点。并且链表在判断是否含有某个结点时需要从头节点进行遍历，每次遍历都是O(E),增加了复杂度。</p>
<p>反观书中给出的实现：</p>
<ul>
<li>
<p>用一个boolean型的数组来表示是否真的在保存的数据结构中，而不是真的把顶点加入到某个数据结构中。然后又可以根据数组的索引很快找到这个顶点。时间复杂度直接为O(1).</p>
</li>
<li>
<p>还可以给出环的具体路径。定义了一个Stack和以前一样的想法来将从终点将顶点逆序。
<img src="/chapter4/4.2.10.jpg" alt=""></p>
</li>
</ul>
<p>有一点很重要，当从路径中的某个顶点深度优先搜索完了返回到原来的顶点时需要把这个顶点从记录路径的数据结构(这里是抽象的栈)删除。即这个顶点开始的子图不存在图，然后继续这个顶点的前一个顶点edgeTo[]继续深度优先搜索。</p>
<p><img src="/chapter4/4.2.8.png" alt=""></p>
<p>如图，从顶点0开始遍历，然后dfs(1),再dfs(2)。2已经完成，删除2。返回到1，1也完成了。这时一定要删除顶点1.意味着以1为起点的子图不存在顶点。继续0的下一个未被访问的顶点3.若不删除，在dfs(3)时，由于1在栈中，会返回有环。这显然是错误的。</p>
<h1 id="拓扑排序">拓扑排序</h1>
<p>有这样一类广泛的模型：给定一组任务并且安排它们的执行顺序，限制条件可能是这些任务的执行方法和起始时间。最终要的一种限制条件叫做 <em>优先级限制</em>，即指明哪些任务必须在哪些任务之前完成。以计算机学习路线为例：首先要学习离散数学和高等数学，然后才能学习数据结构和算法。</p>
<p><strong>优先级限制问题：给定一组需要完成的任务，以及一组关于任务完成的先后顺序的限制。在满足限制条件的前提下如何安排并完成所有任务？</strong></p>
<p><strong>拓扑排序：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素。</strong></p>
<p><img src="/chapter4/4.2.6topological-sort.png" alt=""></p>
<p>实际上，优先级限制下的调度问题 等价于 计算有向无环图的所有顶点的拓扑排序。</p>
<p>注意：强调是 <em><strong>有向无环图</strong></em>。对于存在环的有向图不能进行拓扑排序。 <br>
因为如果一幅有向图含有一个环，它就不可能保证拓扑排序的定义。</p>
<p>对于拓扑排序的实现，我们任然可以采用 <em><strong>深度优先搜索</strong></em> 算法。<br>
深度优先搜索算法的顶点排序有三种典型：</p>
<ul>
<li>前序：在递归调用之 <em>前</em> 将顶点入 <em>队列</em> (第一次访问就入队列)。</li>
<li>后序：在递归调用之 <em>后</em> 将顶点入 <em>队列</em> (完成了才入队列)。</li>
<li>逆后序：在递归调用之 <em>后</em> 将顶点入 <em>栈</em> (将后序逆序)。</li>
</ul>
<p><img src="/chapter4/4.2.5depth-first-orders.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DepthFirstOrder</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>          
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> pre<span style="color:#f92672">;</span>                 <span style="color:#75715e">// pre[v]存储前序排序时在v前面被访问的元素个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> post<span style="color:#f92672">;</span>                <span style="color:#75715e">// post[v]存储后序时在v前面完成的元素个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> preorder<span style="color:#f92672">;</span>   <span style="color:#75715e">// 用队列存储前序排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> postorder<span style="color:#f92672">;</span>  <span style="color:#75715e">// 用队列存储后序排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> preCounter<span style="color:#f92672">;</span>            <span style="color:#75715e">// 记录元素个数初值为0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> postCounter<span style="color:#f92672">;</span>           <span style="color:#75715e">// 初值为0
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DepthFirstOrder</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        pre    <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        post   <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        postorder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        preorder  <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Queue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        marked    <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>       
        <span style="color:#75715e">// 对有向图进行深度优先搜索
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 前序和后序不同在于顶点入队列的顺序
</span><span style="color:#75715e"></span>        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#75715e">//pre[v]存储前序排序时在v前面被访问的元素个数        
</span><span style="color:#75715e"></span>        pre<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> preCounter<span style="color:#f92672">++;</span>
        <span style="color:#75715e">//前序：在递归调用之 *前* 将顶点入 *队列* 
</span><span style="color:#75715e"></span>        preorder<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//后序：在递归调用之 *后* 将顶点入 *队列* 。
</span><span style="color:#75715e"></span>        postorder<span style="color:#f92672">.</span><span style="color:#a6e22e">enqueue</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        post<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> postCounter<span style="color:#f92672">++;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pre</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> pre<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>  <span style="color:#75715e">//pre[v]存储前序排序时在v前面被访问的元素个数
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">post</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> post<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span> <span style="color:#75715e">//post[v]存储后序时在v前面完成的元素个数
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">post</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> postorder<span style="color:#f92672">;</span>   <span style="color:#75715e">//返回前序排序顺序
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">pre</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> preorder<span style="color:#f92672">;</span>    <span style="color:#75715e">//返回后序排序顺序
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">reversePost</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//逆后序排序顺序
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//有一个队列将后续再逆序即可
</span><span style="color:#75715e"></span>        Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> reverse <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> postorder<span style="color:#f92672">)</span>
            reverse<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> reverse<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

<span style="color:#75715e">/*=====   时间复杂度为O(V+E)   =====*/</span>
</code></pre></div><p>实现拓扑排序的基本思想是：深度优先搜索算法正好只会访问每个顶点一次。如果将dfs()的参数顶点保存在一个数据结构中，按一定的顺序遍历整个数据结构实际上就能访问图中的所有顶点。而遍历的顺序为 <em>逆后序</em> 。</p>
<p><img src="/chapter4/4.2.5depth-first-orders.png" alt=""></p>
<p>证明 <strong>一幅有向无环图的拓扑排序即为所有顶点的逆后序排序</strong>： <br>
以上图为例：对于任意边v-&gt;w,在调用dfs(v)时，下面三种情况必然有一种成立</p>
<ul>
<li>dfs(w)已经被调用过(w已经被标记)且已经返回了(如8-&gt;7)。</li>
<li>dfs(w)还没被调用(w还未被标记),因此v-&gt;w会直接或者间接调用并返回dfs(w)，且dfs(w)还会在dfs(v)返回前返回。(如0-&gt;5)</li>
<li>dfs(w)已经被调用但还未返回。但是这在有向无环图中是不可能出现的。因为递归调用链意味着存在w-&gt;v的路径(w在v之前已经被标记了)，但存在v-&gt;w则表示存在一个环。</li>
</ul>
<p>在可能的两种情况中，dfs(w)都会在dfs(v)之前完成，因此在后序排序中w排在前面而在逆后序中w排在v后面。因此任意一条边v-&gt;w都能由排名前的顶点指向排名后的顶点。</p>
<p>有了上述的证明，我们利用深度优先搜索算法解决优先级调度问题(拓扑排序问题)就可以归纳为如下的几步：</p>
<ul>
<li>指明任务和优先级条件。(相当于给定顶点和边的方向)</li>
<li>检测有向图是否含有环，以确保存在解。</li>
<li>使用拓扑排序解决调度问题</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Topological</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> order<span style="color:#f92672">;</span>  <span style="color:#75715e">// 拓扑排序顺序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> rank<span style="color:#f92672">;</span>               <span style="color:#75715e">// rank[v]表示拓扑排序序列中v的顺序
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Topological</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        DirectedCycle finder <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedCycle<span style="color:#f92672">(</span>G<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>finder<span style="color:#f92672">.</span><span style="color:#a6e22e">hasCycle</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">//确保没有环才能进行拓扑排序
</span><span style="color:#75715e"></span>            DepthFirstOrder dfs <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DepthFirstOrder<span style="color:#f92672">(</span>G<span style="color:#f92672">);</span>
            <span style="color:#75715e">//有向无环图的拓扑排序即为所有顶点的逆后序排序
</span><span style="color:#75715e"></span>            order <span style="color:#f92672">=</span> dfs<span style="color:#f92672">.</span><span style="color:#a6e22e">reversePost</span><span style="color:#f92672">();</span>
            rank <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> order<span style="color:#f92672">)</span>
                rank<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Iterable<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">order</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">//返回拓扑排序顺序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> order<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasOrder</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#75715e">//是否有拓扑排序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> order <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isDAG</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span><span style="color:#75715e">//判断是否是有向无环图
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//有向无环图当且仅当拓扑排序存在
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> hasOrder<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>命题：使用深度优先搜索对有向无环图进行拓扑排序的时间复杂度为O(V+E). <br>
其中第一遍深度优先搜索保证不存在有向环，第二遍产生了顶点的逆后序排序。两次都为O(V+E).</p>
<hr>
<h1 id="有向图中的强连通性">有向图中的强连通性</h1>
<p>在有向图中v-&gt;w有路径则w对于v是可达的，并不能称为连通。</p>
<p>只有两个顶点是互相可达的才能称它们为强连通的。   <br>
如果一幅有向图的任意两个顶点都是连通的，则称这幅有向图是强连通有向图。</p>
<p>两个顶点是强连通的  &lt;==&gt;  它们都在一个普通的有向环中。 <br>
有向图中互相均为强连通的顶点组成的子图称为强连通分量。  <br>
整个生态圈就含有强连通分量(每个动物都有天敌，不然就泛滥了)</p>
<p><strong>强连通性问题：给定的两个顶点是强连通的吗？某个有向图中有几个强连通分量？</strong> <br>
Kosaraju算法：使用深度优先搜索查找给定有向图G的反向图G&rsquo;，根据由此得到的所有顶点的逆后序再次使用深度优先搜索处理有向图G，其构造函数中每一次递归调用所标记的顶点都在同一个强连通分量中。 <br>
且可以根据顶点直接返回所在强连通分量的id，支持常数时间的查询操作。</p>
<p>下图是Kosaraju算法正确性的证明： <br>
<img src="/chapter4/4.2.11.jpg" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KosarajuSharirSCC</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[]</span> marked<span style="color:#f92672">;</span>     
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> id<span style="color:#f92672">;</span>             <span style="color:#75715e">// 标记所在强连通分量的id
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>            <span style="color:#75715e">// 强连通分量的数量
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">KosarajuSharirSCC</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#75715e">//计算图G的反向图的逆后序排序
</span><span style="color:#75715e"></span>        DepthFirstOrder dfs <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DepthFirstOrder<span style="color:#f92672">(</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">reverse</span><span style="color:#f92672">());</span>

        marked <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">boolean</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        id <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">:</span> dfs<span style="color:#f92672">.</span><span style="color:#a6e22e">reversePost</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>   <span style="color:#75715e">//对得到的逆后序再次深度优先搜索
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>v<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
                dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
                count<span style="color:#f92672">++;</span>    <span style="color:#75715e">//构造函数中每一次递归调用所标记的顶点都在同一个强连通分量中
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        marked<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        id<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> count<span style="color:#f92672">;</span>  <span style="color:#75715e">// 标记所在强连通分量的id
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> w <span style="color:#f92672">:</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">adj</span><span style="color:#f92672">(</span>v<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>marked<span style="color:#f92672">[</span>w<span style="color:#f92672">])</span> dfs<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> w<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">count</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> count<span style="color:#f92672">;</span>   <span style="color:#75715e">//强连通分量的数量
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">stronglyConnected</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        validateVertex<span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> id<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> id<span style="color:#f92672">[</span>w<span style="color:#f92672">];</span>  <span style="color:#75715e">//所在的强连通分量的id是否一样
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> id<span style="color:#f92672">[</span>v<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

</code></pre></div><p>时间复杂度O(E + V)。 <br>
处理有向图的反向图和两次深度优先搜索都需要O(E+V)。 <br>
反向赋值一幅有向图的空间(空间复杂度)为O(E+V)。</p>
<hr>
<h1 id="顶点对的可达性">顶点对的可达性</h1>
<p><strong>顶点对的可达性：是否存在一条从一个给定顶点v到另一个给定顶点w的路径？</strong>  <br>
对于有向图的一对非强连通的顶点v,w。也许w对于v可达，也许v对于w可达，也许互相不可达。</p>
<p>对于无向图这个就等价于连通性问题，可以通过线性级别时间的预处理来支持常数级别的查询。</p>
<p>对于有向图，实现常数时间的查询需要的代价很大。需要将判断v-&gt;w的可达性以及w-&gt;v的可达性，即需要对每个顶点都进行单点可达性测试。然后将结果具体化为一个V*V的邻接矩阵。  <br>
具体来说，需要V^2的额外的空间存放每个顶点之间互相的可达性，需要V(V+E)的时间对V个顶点都进行O(V+E)的单点可达性算法。  <br>
<img src="/chapter4/4.2.12transitive-closure.png" alt=""></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TransitiveClosure</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> DirectedDFS<span style="color:#f92672">[]</span> tc<span style="color:#f92672">;</span>  <span style="color:#75715e">// 存放DirectedDFS对象的数组
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">TransitiveClosure</span><span style="color:#f92672">(</span>Digraph G<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        tc <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedDFS<span style="color:#f92672">[</span>G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">()];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> v <span style="color:#f92672">&lt;</span> G<span style="color:#f92672">.</span><span style="color:#a6e22e">V</span><span style="color:#f92672">();</span> v<span style="color:#f92672">++)</span>
            tc<span style="color:#f92672">[</span>v<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DirectedDFS<span style="color:#f92672">(</span>G<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>  <span style="color:#75715e">//存放V个对象，每个都进行一次单点的可达性算法
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">reachable</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> v<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> w<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        validateVertex<span style="color:#f92672">(</span>v<span style="color:#f92672">);</span>
        validateVertex<span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> tc<span style="color:#f92672">[</span>v<span style="color:#f92672">].</span><span style="color:#a6e22e">marked</span><span style="color:#f92672">(</span>w<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#75715e">/*
</span><span style="color:#75715e">======时间复杂度O(V(V+E))
</span><span style="color:#75715e">*/</span>
</code></pre></div><h1 id="总结">总结</h1>
<ul>
<li>
<p>有向图的可达性 &mdash;- 深度优先搜索算法 ， marked[]标记数组</p>
</li>
<li>
<p>有向图的路径   &mdash;-  深度优先搜索算法  ，  edgeTo[]标记路径，以及一个栈将路径逆序。</p>
</li>
<li>
<p>有向图最短路径  &mdash;- 广度优先搜索算法  ，edgeTo[]和一个队列用于广度遍历</p>
</li>
<li>
<p>检测是否有环  &mdash;-  深度优先搜索算法  ， marked[],onStack[]用于标记是否在当前栈中</p>
</li>
<li>
<p>拓扑排序/优先级调度  &mdash;- 深度优先搜索算法  ，  顶点的逆后序</p>
</li>
<li>
<p>强连通分量    &mdash;- Kosaraju算法</p>
</li>
<li>
<p>顶点对可达性  &mdash;- O(V(V+E))的预处理来保证O(1)的查询</p>
</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
