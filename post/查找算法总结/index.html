<!doctype html>
<html lang="en-us">
  <head>
    <title>查找算法总结 // </title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.3" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="yzz帅的一匹" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://yzz-git111.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="查找算法总结"/>
<meta name="twitter:description" content="回顾 查找，或者借助《算法四》中的名词“符号表”的关键就是键值对&lt;Key,Value&gt;：给出一个键，返回相对应的值;插入新的键值对;删除或修改原来的键值对。
在书中介绍了几种符号表来实现查找算法：基于数组或者链表的初级实现、基于二叉查找树实现、基于平衡二叉查找树实现、基于哈希表实现。
  先给出了符号表的基本API接口：查找键对应的值get()、插入新的键值对put()、删除一对键值对delete()、判断键是否在表中contains()、返回键值对的数量size()、判断表是否为空isEmpty()等。 其中对于有序的符号表，还可以定义更多的API接口：返回最大/最小的键min()/max()、返回小于等于给定的键的最大的键floor()、返回大于等于给定的键的最小的键ceiling()、返回小于给定的键的排名(返回给定的键在键序列中的排名)rank()、返回排名为给定数值的键select()、删除最大/最小的键deleteMin()/deleteMax()等。
  首先最开始我们的想法就是用最基本的数据结构：数组和链表来实现。
  链表的实现：通过定义内部类，即结点类，结点存放了Key类型的键和Value类型的值，同时还存放了下一个结点的引用(相当于C/C&#43;&#43;的指针)。
对于链表实现无序的符号表，优点是插入时可以直接在头插入，时间复杂度仅为O(1)。但是查找和删除时就需要遍历整个链表才能找到指定的键值对。这时复杂度达到了O(N)。
对于链表实现有序的符号表，其唯一的优点：插入，这时为了找寻插入的位置，也需要遍历链表。那么查询，插入，删除的复杂度都达到了O(N)。
  数组的实现：通过定义两个数组，数组的各个元素一一对应，一个Key[]数组存放键，一个Value[]数组用于存放值。
对于数组实现的无序符号表，插入可以随机在数组下一个位置插入，也很简单。但是无序列表的查找和删除就需要遍历整个数组，复杂度为O(N)。(删除时可以直接将最后一个元素赋值给当前的元素，然后N&ndash;即可完成快速删除)。 对于数组实现的有序符号表，在插入和删除时为了维护符号表的有序性，需要从前往后的删除和从后往前的插入，复杂度为O(N)。 但是数组实现的符号表的查询可以借助著名的二分查找算法，每次将问题分解为一半能够快速的进行查询。
  但是注意：二分查找算法只适用于有序的序列，对于无序的序列不能使用。
并且二分查找不适用于链表。
    借助二分查找和树的想法，将二叉树应用在查找中：保证对任意的子树，其根结点键的值大于左子树的所有结点且小于右子树的所有结点。这样的二叉树称作二叉查找树(BST)。且二叉查找树的中序遍历可以得到一个键的递增序列。
  具体实现：定义一个BST类，类中只有一个Node类型的变量root，用于存放根结点的引用。Node为在BST的内部类，即树的结点类。类中有一个Key类型的变量存放键，一个Value类型的变量存放值，Node类型的变量left和right存放左右子树的引用，还有一个int型的变量N存放以该结点为根的子树的所有结点个数(为了方便实现某些方法)。
  二叉查找树的查找每次和当前结点比较，然后递归的在左、右子树进行查找，直到遇到了空链接&ndash;未命中，或者查找到了，在逐层返回。这种思想类似于二分查找。
  二叉查找树的插入：递归的查找新的键待插入的顺序，然后返回一个新的结点即可。
删除：当待删除结点只有一个子结点(或者没有子结点)，直接用子结点代替待删除结点即可(没有子结点用null代替).当待删除结点有两个子结点时，用它的后继结点(中序遍历的后一个结点)代替该结点，然后删除该结点右子树的最小结点deleteMin(x.right)。
  二叉树的有关操作都要有递归的思想。
  但是二叉查找树的形态和键值对的插入顺序有关，最好情况下的二叉查找树是完全二叉树的形态，高度仅为（log2N取下整&#43;1）。最坏情况即键是递增/递减的插入，这样构造出来的二叉查找树高度达到N,直接退化成了链表。
    平衡查找树的引入：为了克服二叉查找树的缺点，引入平衡树。对于平衡二叉搜索树(AVL树)，它可以通过左旋/右旋来使得每个结点的平衡因子绝对值不超过1。但是这样的操作的成本是很高的。通过在二叉查找树的结点中假如一个新的变量color就能较轻易的实现平衡。即红黑树。
  首先引入了2-3查找树的概念，二叉查找树是一棵平衡查找树，且2-3查找树的所有空链接到根结点的距离是相等的。2-3查找树的构造过程保证了即使对于二叉查找树的最坏情况，2-3查找树也是能很好应对的。
  红黑二叉查找树与2-3查找树都是一一对应的。虽然2-3查找树不是严格意义的平衡查找树(不看结点的颜色时它可能不平衡)，但是红黑树保证了树的黑色平衡(任意黑色空链接到根结点的路径上的黑链接数量相同)。
  红黑树的插入，删除操作较为复杂，但是由于红黑树是一棵二叉查找树，所以可以借助二叉查找树所有与颜色变量color无关的方法。比如查找。
  红黑树较二叉查找树只增加了一个color变量便实现了平衡，平均情况下将查找和插入的复杂度从1.39logN降低到1.00logN 。
    值得注意的是：书中介绍的只是红黑树的一种实现。在其他的实现中有的允许红色右链接和4-结点。 书中规定只允许左链接是为了代码实现的方便。"/>

    <meta property="og:title" content="查找算法总结" />
<meta property="og:description" content="回顾 查找，或者借助《算法四》中的名词“符号表”的关键就是键值对&lt;Key,Value&gt;：给出一个键，返回相对应的值;插入新的键值对;删除或修改原来的键值对。
在书中介绍了几种符号表来实现查找算法：基于数组或者链表的初级实现、基于二叉查找树实现、基于平衡二叉查找树实现、基于哈希表实现。
  先给出了符号表的基本API接口：查找键对应的值get()、插入新的键值对put()、删除一对键值对delete()、判断键是否在表中contains()、返回键值对的数量size()、判断表是否为空isEmpty()等。 其中对于有序的符号表，还可以定义更多的API接口：返回最大/最小的键min()/max()、返回小于等于给定的键的最大的键floor()、返回大于等于给定的键的最小的键ceiling()、返回小于给定的键的排名(返回给定的键在键序列中的排名)rank()、返回排名为给定数值的键select()、删除最大/最小的键deleteMin()/deleteMax()等。
  首先最开始我们的想法就是用最基本的数据结构：数组和链表来实现。
  链表的实现：通过定义内部类，即结点类，结点存放了Key类型的键和Value类型的值，同时还存放了下一个结点的引用(相当于C/C&#43;&#43;的指针)。
对于链表实现无序的符号表，优点是插入时可以直接在头插入，时间复杂度仅为O(1)。但是查找和删除时就需要遍历整个链表才能找到指定的键值对。这时复杂度达到了O(N)。
对于链表实现有序的符号表，其唯一的优点：插入，这时为了找寻插入的位置，也需要遍历链表。那么查询，插入，删除的复杂度都达到了O(N)。
  数组的实现：通过定义两个数组，数组的各个元素一一对应，一个Key[]数组存放键，一个Value[]数组用于存放值。
对于数组实现的无序符号表，插入可以随机在数组下一个位置插入，也很简单。但是无序列表的查找和删除就需要遍历整个数组，复杂度为O(N)。(删除时可以直接将最后一个元素赋值给当前的元素，然后N&ndash;即可完成快速删除)。 对于数组实现的有序符号表，在插入和删除时为了维护符号表的有序性，需要从前往后的删除和从后往前的插入，复杂度为O(N)。 但是数组实现的符号表的查询可以借助著名的二分查找算法，每次将问题分解为一半能够快速的进行查询。
  但是注意：二分查找算法只适用于有序的序列，对于无序的序列不能使用。
并且二分查找不适用于链表。
    借助二分查找和树的想法，将二叉树应用在查找中：保证对任意的子树，其根结点键的值大于左子树的所有结点且小于右子树的所有结点。这样的二叉树称作二叉查找树(BST)。且二叉查找树的中序遍历可以得到一个键的递增序列。
  具体实现：定义一个BST类，类中只有一个Node类型的变量root，用于存放根结点的引用。Node为在BST的内部类，即树的结点类。类中有一个Key类型的变量存放键，一个Value类型的变量存放值，Node类型的变量left和right存放左右子树的引用，还有一个int型的变量N存放以该结点为根的子树的所有结点个数(为了方便实现某些方法)。
  二叉查找树的查找每次和当前结点比较，然后递归的在左、右子树进行查找，直到遇到了空链接&ndash;未命中，或者查找到了，在逐层返回。这种思想类似于二分查找。
  二叉查找树的插入：递归的查找新的键待插入的顺序，然后返回一个新的结点即可。
删除：当待删除结点只有一个子结点(或者没有子结点)，直接用子结点代替待删除结点即可(没有子结点用null代替).当待删除结点有两个子结点时，用它的后继结点(中序遍历的后一个结点)代替该结点，然后删除该结点右子树的最小结点deleteMin(x.right)。
  二叉树的有关操作都要有递归的思想。
  但是二叉查找树的形态和键值对的插入顺序有关，最好情况下的二叉查找树是完全二叉树的形态，高度仅为（log2N取下整&#43;1）。最坏情况即键是递增/递减的插入，这样构造出来的二叉查找树高度达到N,直接退化成了链表。
    平衡查找树的引入：为了克服二叉查找树的缺点，引入平衡树。对于平衡二叉搜索树(AVL树)，它可以通过左旋/右旋来使得每个结点的平衡因子绝对值不超过1。但是这样的操作的成本是很高的。通过在二叉查找树的结点中假如一个新的变量color就能较轻易的实现平衡。即红黑树。
  首先引入了2-3查找树的概念，二叉查找树是一棵平衡查找树，且2-3查找树的所有空链接到根结点的距离是相等的。2-3查找树的构造过程保证了即使对于二叉查找树的最坏情况，2-3查找树也是能很好应对的。
  红黑二叉查找树与2-3查找树都是一一对应的。虽然2-3查找树不是严格意义的平衡查找树(不看结点的颜色时它可能不平衡)，但是红黑树保证了树的黑色平衡(任意黑色空链接到根结点的路径上的黑链接数量相同)。
  红黑树的插入，删除操作较为复杂，但是由于红黑树是一棵二叉查找树，所以可以借助二叉查找树所有与颜色变量color无关的方法。比如查找。
  红黑树较二叉查找树只增加了一个color变量便实现了平衡，平均情况下将查找和插入的复杂度从1.39logN降低到1.00logN 。
    值得注意的是：书中介绍的只是红黑树的一种实现。在其他的实现中有的允许红色右链接和4-结点。 书中规定只允许左链接是为了代码实现的方便。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yzz-git111.github.io/post/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" />
<meta property="article:published_time" content="2020-11-08T13:32:15+08:00" />
<meta property="article:modified_time" content="2020-11-08T13:32:15+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://yzz-git111.github.io/"><img class="app-header-avatar" src="/avatar.jpeg" alt="yzz帅的一匹" /></a>
      <h1></h1>
      <p>yzz也想变成学霸</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/yzz-git111" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">查找算法总结</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Nov 8, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <h1 id="回顾">回顾</h1>
<p>查找，或者借助《算法四》中的名词“符号表”的关键就是<del>键值对</del>&lt;Key,Value&gt;：<em><strong>给出一个键，返回相对应的值;插入新的键值对;删除或修改原来的键值对。</strong></em></p>
<p>在书中介绍了几种符号表来实现查找算法：基于数组或者链表的初级实现、基于二叉查找树实现、基于平衡二叉查找树实现、基于哈希表实现。</p>
<ol>
<li>
<p>先给出了符号表的基本API接口：查找键对应的值get()、插入新的键值对put()、删除一对键值对delete()、判断键是否在表中contains()、返回键值对的数量size()、判断表是否为空isEmpty()等。        <br>
其中对于有序的符号表，还可以定义更多的API接口：返回最大/最小的键min()/max()、返回小于等于给定的键的最大的键floor()、返回大于等于给定的键的最小的键ceiling()、返回小于给定的键的排名(返回给定的键在键序列中的排名)rank()、返回排名为给定数值的键select()、删除最大/最小的键deleteMin()/deleteMax()等。</p>
</li>
<li>
<p>首先最开始我们的想法就是用最基本的数据结构：数组和链表来实现。</p>
<ul>
<li>
<p>链表的实现：通过定义内部类，即结点类，结点存放了Key类型的键和Value类型的值，同时还存放了下一个结点的引用(相当于C/C++的指针)。<br>
对于链表实现无序的符号表，优点是插入时可以直接在头插入，时间复杂度仅为O(1)。但是查找和删除时就需要遍历整个链表才能找到指定的键值对。这时复杂度达到了O(N)。<br>
对于链表实现有序的符号表，其唯一的优点：插入，这时为了找寻插入的位置，也需要遍历链表。那么查询，插入，删除的复杂度都达到了O(N)。</p>
</li>
<li>
<p>数组的实现：通过定义两个数组，数组的各个元素一一对应，一个Key[]数组存放键，一个Value[]数组用于存放值。<br>
对于数组实现的无序符号表，插入可以随机在数组下一个位置插入，也很简单。但是无序列表的查找和删除就需要遍历整个数组，复杂度为O(N)。(删除时可以直接将最后一个元素赋值给当前的元素，然后N&ndash;即可完成快速删除)。 <br>
对于数组实现的有序符号表，在插入和删除时为了维护符号表的有序性，需要从前往后的删除和从后往前的插入，复杂度为O(N)。
但是数组实现的符号表的查询可以借助著名的二分查找算法，每次将问题分解为一半能够快速的进行查询。</p>
</li>
<li>
<p>但是注意：二分查找算法只适用于<em>有序</em>的序列，对于无序的序列不能使用。<br>
并且二分查找不适用于链表。</p>
</li>
</ul>
</li>
<li>
<p>借助二分查找和树的想法，将二叉树应用在查找中：保证对任意的子树，其根结点键的值大于左子树的所有结点且小于右子树的所有结点。这样的二叉树称作二叉查找树(BST)。且<strong>二叉查找树的中序遍历可以得到一个键的递增序列。</strong></p>
<ul>
<li>
<p>具体实现：定义一个BST类，类中只有一个Node类型的变量root，用于存放根结点的引用。Node为在BST的内部类，即树的结点类。类中有一个Key类型的变量存放键，一个Value类型的变量存放值，Node类型的变量left和right存放左右子树的引用，还有一个int型的变量N存放以该结点为根的子树的所有结点个数(为了方便实现某些方法)。</p>
</li>
<li>
<p>二叉查找树的查找每次和当前结点比较，然后递归的在左、右子树进行查找，直到遇到了空链接&ndash;未命中，或者查找到了，在逐层返回。这种思想类似于二分查找。</p>
</li>
<li>
<p>二叉查找树的插入：递归的查找新的键待插入的顺序，然后返回一个新的结点即可。<br>
删除：当待删除结点只有一个子结点(或者没有子结点)，直接用子结点代替待删除结点即可(没有子结点用null代替).当待删除结点有两个子结点时，用它的后继结点(中序遍历的后一个结点)代替该结点，然后删除该结点右子树的最小结点deleteMin(x.right)。</p>
</li>
<li>
<p>二叉树的有关操作都要有递归的思想。</p>
</li>
<li>
<p>但是二叉查找树的形态和键值对的插入顺序有关，最好情况下的二叉查找树是完全二叉树的形态，高度仅为（log2N取下整+1）。最坏情况即键是递增/递减的插入，这样构造出来的二叉查找树高度达到N,直接退化成了链表。</p>
</li>
</ul>
</li>
<li>
<p>平衡查找树的引入：为了克服二叉查找树的缺点，引入平衡树。对于平衡二叉搜索树(AVL树)，它可以通过左旋/右旋来使得每个结点的平衡因子绝对值不超过1。但是这样的操作的成本是很高的。通过在二叉查找树的结点中假如一个新的变量color就能较轻易的实现平衡。即红黑树。</p>
<ul>
<li>
<p>首先引入了2-3查找树的概念，二叉查找树是一棵平衡查找树，且2-3查找树的所有空链接到根结点的距离是相等的。2-3查找树的构造过程保证了即使对于二叉查找树的最坏情况，2-3查找树也是能很好应对的。</p>
</li>
<li>
<p>红黑二叉查找树与2-3查找树都是一一对应的。虽然2-3查找树不是严格意义的平衡查找树(不看结点的颜色时它可能不平衡)，但是红黑树保证了树的黑色平衡(任意黑色空链接到根结点的路径上的黑链接数量相同)。</p>
</li>
<li>
<p>红黑树的插入，删除操作较为复杂，但是由于红黑树是一棵二叉查找树，所以可以借助二叉查找树所有与颜色变量color无关的方法。比如查找。</p>
</li>
<li>
<p>红黑树较二叉查找树只增加了一个color变量便实现了平衡，平均情况下将查找和插入的复杂度从1.39logN降低到1.00logN 。</p>
</li>
</ul>
</li>
</ol>
<p><del>值得注意的是：书中介绍的只是红黑树的一种实现。<em><strong>在其他的实现中有的允许红色右链接和4-结点。</strong></em> 书中规定只允许左链接是为了代码实现的方便。</del></p>
<ol start="5">
<li>
<p>哈希表(散列表)。当所有的键都是 <em><strong>小整数</strong></em> 时，可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中键i处存储的就是它对应的值。<br>
将键转化为数组的索引来访问数组中的键值对。<br>
使用哈希表分为两个步骤：1.确定散列函数，使用散列函数将被查找的键转化为数组的一个索引。2.处理冲突。</p>
<ul>
<li>
<p>散列函数的选取有多种。<br>
最常用的就是 <em><strong>除留余数法</strong></em>。除数通常取一个质数，保证能够使用到哈希表的每个元素。<br>
直接定址法。<br>
随机数法等&hellip;&hellip;</p>
</li>
<li>
<p>基于拉链法的散列表 <br>
拉链法的思想就是：数组的每个元素都存储一个链表，将索引散列值相同的键通过一个链表存储起来。<br>
查找时先找到与散列值相同的数组的索引，然后在这个索引的链表中顺序查找。<br>
插入时先找到与散列值相同的数组的索引，然后在这个索引的链表中插入。<br>
这里可以调用之前实现的链表，或者直接调用基于链表实现的无序的符号表。<br>
拉链法需要控制每个链表的长度，通过调整数组的大小M来保证每个链表的长度都很小。不至于退化成基于链表实现的无序的符号表。</p>
</li>
<li>
<p>基于开放地址法的散列表  <br>
开放地址法的思想：建立一个比键值对数目大的散列表,当发生碰撞时，就使用还未被占用的位置。 <br>
其中最基础的就是线性探测法，即发生碰撞时继续检测下一个索引，如果下一个索引未被占用就放在下一个索引内。  <br>
线性探测法的查找：先计算散列值，如果散列值处的键与待查找的键相同就命中。否则继续顺序往下找，直到遇到了一个索引里的键未null，说明未命中。 <br>
开放地址法需要关注关注散列因子α，α越大，发生碰撞的概率越多，进行探测的次数也就越多。α约为1/2时，既不浪费空间，又能在短时间查找到。</p>
</li>
</ul>
</li>
</ol>
<p>散列表在平均情况下虽然能够在常数时间能完成查找和插入。<br>
但是散列表有一个很大的缺点：有关有序性的操作很难实现。 <br>
且很多时候好的散列函数的选取是很难的。</p>
<p><img src="/chapter3/3.5.1.jpg" alt=""></p>
<hr>
<h2 id="如何选择">如何选择</h2>
<p>在大多数情况下，散列表是最好的选择。<br>
而在有序性操作比较多的时候，通常选择二叉查找树。<br>
更进一步的，如果对于最坏情况也有要求时，就需要选择红黑树(或者AVL树).</p>
<hr>
<h2 id="改进">改进</h2>
<p>在某些情况下，我们可以使用原始数据类型而不用标准的引用的数据类型。<br>
假设我们有一张符号表，其中整型的键对应浮点型的值。而如果用引用的数据类型，即创建Integer和Double类的对象来存储。这样会需要两个额外的引用来访问每个键值对。而直接用原始数据类型就可以不用引用，减少内存。</p>
<h2 id="重复键">重复键</h2>
<p>在之前的实现中，都默认不存在有重复的键，对与重复的键，都使用新的键值对将以前的覆盖。<br>
而在实际中，可能需要为一个键绑定不同的值。比如：在一个交易处理系统中，多笔交易的客户属性都是相同的。</p>
<h2 id="典型的用例">典型的用例</h2>
<blockquote>
<p>电子邮件程序<br>
假设有一个有一个符号表，里面存储的是好友的邮箱地址。对于收邮件来说，每次调用contain判断发送方是不是好友。不是则将其视为垃圾邮件。</p>
</blockquote>
<blockquote>
<p>字典类</p>
</blockquote>
<ul>
<li>电话黄页     键：人名&mdash;&mdash;值：电话号码</li>
<li>编译器          键：变量名&mdash;&mdash;值：内存地址</li>
<li>DNS     键： 网站&mdash;&mdash;-值：IP地址</li>
</ul>
<h2 id="java标准库">Java标准库</h2>
<p>Java的 java.util.TreeMap 和 java.util.HashMap 分别是基于红黑树和拉链法的散列表的实现。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
